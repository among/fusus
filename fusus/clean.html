<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fusus.clean API documentation</title>
<meta name="description" content="Wipe marks from images â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fusus.clean</code></h1>
</header>
<section id="section-intro">
<p>Wipe marks from images.</p>
<p>Cleaning marks from images is based on
<a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html#template-matching">OpenCV's template matching</a></p>
<p>This is fuzzy matching, so we have to employ considerable sophistication to
get the true results and to discard the fake results.</p>
<p>One particular way to discard fake results is to mind the connectedness of the ink
of a candidate mark with the surrounding ink.
If there is such a connection, it is a strong indication that the candidate is not
a mark to be removed, but part of a glyph.</p>
<p>See <img alt="bordering" src="images/isolation.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/6cc4c6ea093dfbb0062b9bde174eb761909c327f/fusus/clean.py#L0-L312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Wipe marks from images.

Cleaning marks from images is based on
[OpenCV&#39;s template matching](https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_template_matching/py_template_matching.html#template-matching)

This is fuzzy matching, so we have to employ considerable sophistication to
get the true results and to discard the fake results.

One particular way to discard fake results is to mind the connectedness of the ink
of a candidate mark with the surrounding ink.
If there is such a connection, it is a strong indication that the candidate is not
a mark to be removed, but part of a glyph.

See ![bordering](images/isolation.png)

&#34;&#34;&#34;

import numpy as np
import cv2

from .lib import FONT


def cluster(points, match):
    &#34;&#34;&#34;Cluster points that are in a source.

    When searching images for image templates,
    we get a match image: for each point in the image a measure of how good the
    match is at that point.

    Typically, if a point has a high match value, surrounding points also have good
    match values. We want to cluster such points, so that we can identify a match
    with exactly one cluster.

    Parameters
    ----------
    points: iterable
        Points where the image template matches the source image good enough
    match: image as np array
        The match image

    Returns
    -------
    list
        The list of clusters, where each cluster is represented as a pair of
        point and the strength of the match in that point.
        This point is the point in the cluster with the highest match value.
    &#34;&#34;&#34;

    def d(p1, p2):
        if p1 == p2:
            return 0
        (x1, y1) = p1
        (x2, y2) = p2
        return abs(x1 - x2) + abs(y1 - y2)

    clusters = []
    for (i, p) in enumerate(points):
        stored = False
        rp = match[p]
        for c in clusters:
            (q, rq) = c
            if d(p, q) &lt;= 8:
                if rp &gt; rq:
                    c[0] = p
                    c[1] = rp
                stored = True
                break
        if not stored:
            clusters.append([p, rp])
    return clusters


def measure(borderInside, borderOutside, threshold):
    &#34;&#34;&#34;Measure the amount of ink that crosses the border of a certain region.

    It is used to reject certain matches of image templates, where templates
    contain strokes of ink. If a match is such that the stroke of ink connects
    with the ink in the environment, the match is not a true example of the stroke
    and will be rejected.

    !!! note &#34;Where to look for ink&#34;
        We look for ink in the image itself,
        the ink in the search template is not relevant.

    Parameters
    ----------
    borderInside: image as np array
        The part of the image bordering inside an area where the search template matches
    borderOutside: image as np array
        The part of the image bordering outside an area where the search template matches

    Returns
    -------
    float
        The ratio between the size of the ink connections across the border and the
        total size of the border.
    &#34;&#34;&#34;

    connections = borderInside * borderOutside
    return np.where(connections &gt; threshold)[0].size / borderOutside.size


def connected(markH, markW, bw, threshold, img, hitPoint, sides=None):
    &#34;&#34;&#34;Determine how much ink borders on a given rectangle.

    Parameters
    ----------
    markH: integer
        height of the rectangle
    markW: integer
        width of the rectangle
    bw: integer
        width of the border around the rectangle that will be used to detect connections
    threshold:
        the value above which a connection is detected
    img: np array
        the source image
    hitPoint: (int, int)
        Y and X coordinate of top left corner of the rectangle in the image
    sides: string, optional `None`
        If `None`, computes connections on all sides.
        Otherwise it should be a string consisting of at most these characters:
        `l` (left), `r` (right), `t` (top), `b` (bottom).
        Only these sides will be computed.
    &#34;&#34;&#34;

    (textH, textW) = img.shape
    (hitY, hitX) = hitPoint

    connDegree = 0
    nparts = 0

    realBw = min((bw, markW, markH))

    # left boundary

    fo = max((0, hitX - realBw)) if hitX &gt; 0 else None
    if fo is not None and (sides is None or &#34;l&#34; in sides):
        to = hitX
        texto = np.array(
            (255 - img[hitY : hitY + markH, fo:to]).max(axis=1), dtype=np.uint16
        )
        fi = hitX
        ti = hitX + realBw
        texti = np.array(
            (255 - img[hitY : hitY + markH, fi:ti]).max(axis=1), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    # right boundary

    to = (
        min((textW, hitX + markW + realBw + 1))
        if hitX + markW + realBw &lt; textW
        else None
    )
    if to is not None and (sides is None or &#34;r&#34; in sides):
        fo = hitX + markW
        texto = np.array(
            (255 - img[hitY : hitY + markH, fo:to]).max(axis=1), dtype=np.uint16
        )
        fi = hitX + markW - realBw
        ti = hitX + markW
        texti = np.array(
            (255 - img[hitY : hitY + markH, fi:ti]).max(axis=1), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    # top boundary

    f = max((0, hitY - realBw)) if hitY &gt; 0 else None
    if f is not None and (sides is None or &#34;t&#34; in sides):
        t = hitY
        texto = np.array(
            (255 - img[f:t, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        fi = hitY
        ti = hitY + realBw + 1
        texti = np.array(
            (255 - img[fi:ti, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    # bottom boundary

    t = (
        min((textH - 1, hitY + markH + realBw + 1))
        if hitY + markH + realBw &lt; textH
        else None
    )
    if t is not None and (sides is None or &#34;b&#34; in sides):
        f = hitY + markH
        texto = np.array(
            (255 - img[f:t, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        ti = hitY + markH
        fi = hitY + markH - realBw
        texti = np.array(
            (255 - img[fi:ti, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    return connDegree


def reborder(gray, bw, color, crop=False):
    &#34;&#34;&#34;Add a border around a grayscale image, optionally remove white margins first.

    The border will add to the size of the image.

    Parameters
    ----------
    gray: np array
        A grayscale image.
    bw: int
        Width of the new border.
    color: int
        Color of the new border (grayscale).
    crop: boolean, optional `False`
        If `True`, the image will be cropped first such as to remove all surrounding
        white margins.
    &#34;&#34;&#34;

    if crop:
        inv = 255 * (gray &lt; 128).astype(np.uint8)
        coords = cv2.findNonZero(inv)
        x, y, w, h = cv2.boundingRect(coords)
        cropped = gray[y : y + h, x : x + w]
    else:
        cropped = gray
    bordered = cv2.copyMakeBorder(
        cropped, bw, bw, bw, bw, cv2.BORDER_CONSTANT, value=color
    )
    return bordered


def addBox(C, img, left, top, right, bottom, kept, band, seq, connDegree):
    &#34;&#34;&#34;Add a box around a mark that is to be cleaned.

    When we display the marks that will be wiped from the image, we do so by
    putting colored boxes around them.
    This function adds one such box.

    Parameters

    C: object
        The configuration object of the book engine.
    img: image as np array
        the image to operate on
    left, top, right, bottom: int
        specification of the rectangle of the box
    kept: boolean
        Whether the mark is to be kept. Kept marks and wiped marks will get
        different colors.
    band: string
        The name of the band in which the mark is searched for. It will be displayed
        near the box.
    seq: integer
        The number of the mark.
    connDegree: integer
        The degree of ink connection for this mark occurrence. It will be displayed
        near the box.

    Returns
    -------
    None
        The source image receives a modification.
    &#34;&#34;&#34;

    fill = C.boxRemainRGB if kept else C.boxDeleteRGB
    fillN = C.boxRemainNRGB if kept else C.boxDeleteNRGB
    border = C.boxBorder

    size = 0.5
    weight = 1

    colorDeg = (100, 100, 255)

    ptSeq = (left, top - border - 2)
    ptDeg = (left, bottom + border + 8)

    cv2.rectangle(img, (left, top), (right, bottom), fill, border)
    cv2.putText(
        img,
        f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;,
        ptSeq,
        FONT,
        size,
        fillN,
        weight,
        cv2.LINE_AA,
    )
    connectionDegree = int(round(connDegree * 100))
    if connectionDegree:
        cv2.putText(
            img,
            str(connectionDegree),
            ptDeg,
            FONT,
            size,
            colorDeg,
            weight,
            cv2.LINE_AA,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fusus.clean.addBox"><code class="name flex">
<span>def <span class="ident">addBox</span></span>(<span>C, img, left, top, right, bottom, kept, band, seq, connDegree)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a box around a mark that is to be cleaned.</p>
<p>When we display the marks that will be wiped from the image, we do so by
putting colored boxes around them.
This function adds one such box.</p>
<p>Parameters</p>
<p>C: object
The configuration object of the book engine.
img: image as np array
the image to operate on
left, top, right, bottom: int
specification of the rectangle of the box
kept: boolean
Whether the mark is to be kept. Kept marks and wiped marks will get
different colors.
band: string
The name of the band in which the mark is searched for. It will be displayed
near the box.
seq: integer
The number of the mark.
connDegree: integer
The degree of ink connection for this mark occurrence. It will be displayed
near the box.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The source image receives a modification.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/6cc4c6ea093dfbb0062b9bde174eb761909c327f/fusus/clean.py#L246-L313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addBox(C, img, left, top, right, bottom, kept, band, seq, connDegree):
    &#34;&#34;&#34;Add a box around a mark that is to be cleaned.

    When we display the marks that will be wiped from the image, we do so by
    putting colored boxes around them.
    This function adds one such box.

    Parameters

    C: object
        The configuration object of the book engine.
    img: image as np array
        the image to operate on
    left, top, right, bottom: int
        specification of the rectangle of the box
    kept: boolean
        Whether the mark is to be kept. Kept marks and wiped marks will get
        different colors.
    band: string
        The name of the band in which the mark is searched for. It will be displayed
        near the box.
    seq: integer
        The number of the mark.
    connDegree: integer
        The degree of ink connection for this mark occurrence. It will be displayed
        near the box.

    Returns
    -------
    None
        The source image receives a modification.
    &#34;&#34;&#34;

    fill = C.boxRemainRGB if kept else C.boxDeleteRGB
    fillN = C.boxRemainNRGB if kept else C.boxDeleteNRGB
    border = C.boxBorder

    size = 0.5
    weight = 1

    colorDeg = (100, 100, 255)

    ptSeq = (left, top - border - 2)
    ptDeg = (left, bottom + border + 8)

    cv2.rectangle(img, (left, top), (right, bottom), fill, border)
    cv2.putText(
        img,
        f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;,
        ptSeq,
        FONT,
        size,
        fillN,
        weight,
        cv2.LINE_AA,
    )
    connectionDegree = int(round(connDegree * 100))
    if connectionDegree:
        cv2.putText(
            img,
            str(connectionDegree),
            ptDeg,
            FONT,
            size,
            colorDeg,
            weight,
            cv2.LINE_AA,
        )</code></pre>
</details>
</dd>
<dt id="fusus.clean.cluster"><code class="name flex">
<span>def <span class="ident">cluster</span></span>(<span>points, match)</span>
</code></dt>
<dd>
<div class="desc"><p>Cluster points that are in a source.</p>
<p>When searching images for image templates,
we get a match image: for each point in the image a measure of how good the
match is at that point.</p>
<p>Typically, if a point has a high match value, surrounding points also have good
match values. We want to cluster such points, so that we can identify a match
with exactly one cluster.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Points where the image template matches the source image good enough</dd>
<dt><strong><code>match</code></strong> :&ensp;<code>image as np array</code></dt>
<dd>The match image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The list of clusters, where each cluster is represented as a pair of
point and the strength of the match in that point.
This point is the point in the cluster with the highest match value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/6cc4c6ea093dfbb0062b9bde174eb761909c327f/fusus/clean.py#L24-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cluster(points, match):
    &#34;&#34;&#34;Cluster points that are in a source.

    When searching images for image templates,
    we get a match image: for each point in the image a measure of how good the
    match is at that point.

    Typically, if a point has a high match value, surrounding points also have good
    match values. We want to cluster such points, so that we can identify a match
    with exactly one cluster.

    Parameters
    ----------
    points: iterable
        Points where the image template matches the source image good enough
    match: image as np array
        The match image

    Returns
    -------
    list
        The list of clusters, where each cluster is represented as a pair of
        point and the strength of the match in that point.
        This point is the point in the cluster with the highest match value.
    &#34;&#34;&#34;

    def d(p1, p2):
        if p1 == p2:
            return 0
        (x1, y1) = p1
        (x2, y2) = p2
        return abs(x1 - x2) + abs(y1 - y2)

    clusters = []
    for (i, p) in enumerate(points):
        stored = False
        rp = match[p]
        for c in clusters:
            (q, rq) = c
            if d(p, q) &lt;= 8:
                if rp &gt; rq:
                    c[0] = p
                    c[1] = rp
                stored = True
                break
        if not stored:
            clusters.append([p, rp])
    return clusters</code></pre>
</details>
</dd>
<dt id="fusus.clean.connected"><code class="name flex">
<span>def <span class="ident">connected</span></span>(<span>markH, markW, bw, threshold, img, hitPoint, sides=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine how much ink borders on a given rectangle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>markH</code></strong> :&ensp;<code>integer</code></dt>
<dd>height of the rectangle</dd>
<dt><strong><code>markW</code></strong> :&ensp;<code>integer</code></dt>
<dd>width of the rectangle</dd>
<dt><strong><code>bw</code></strong> :&ensp;<code>integer</code></dt>
<dd>width of the border around the rectangle that will be used to detect connections</dd>
<dt>threshold:</dt>
<dt>the value above which a connection is detected</dt>
<dt><strong><code>img</code></strong> :&ensp;<code>np array</code></dt>
<dd>the source image</dd>
<dt><strong><code>hitPoint</code></strong> :&ensp;<code>(int, int)</code></dt>
<dd>Y and X coordinate of top left corner of the rectangle in the image</dd>
<dt><strong><code>sides</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If <code>None</code>, computes connections on all sides.
Otherwise it should be a string consisting of at most these characters:
<code>l</code> (left), <code>r</code> (right), <code>t</code> (top), <code>b</code> (bottom).
Only these sides will be computed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/6cc4c6ea093dfbb0062b9bde174eb761909c327f/fusus/clean.py#L104-L212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def connected(markH, markW, bw, threshold, img, hitPoint, sides=None):
    &#34;&#34;&#34;Determine how much ink borders on a given rectangle.

    Parameters
    ----------
    markH: integer
        height of the rectangle
    markW: integer
        width of the rectangle
    bw: integer
        width of the border around the rectangle that will be used to detect connections
    threshold:
        the value above which a connection is detected
    img: np array
        the source image
    hitPoint: (int, int)
        Y and X coordinate of top left corner of the rectangle in the image
    sides: string, optional `None`
        If `None`, computes connections on all sides.
        Otherwise it should be a string consisting of at most these characters:
        `l` (left), `r` (right), `t` (top), `b` (bottom).
        Only these sides will be computed.
    &#34;&#34;&#34;

    (textH, textW) = img.shape
    (hitY, hitX) = hitPoint

    connDegree = 0
    nparts = 0

    realBw = min((bw, markW, markH))

    # left boundary

    fo = max((0, hitX - realBw)) if hitX &gt; 0 else None
    if fo is not None and (sides is None or &#34;l&#34; in sides):
        to = hitX
        texto = np.array(
            (255 - img[hitY : hitY + markH, fo:to]).max(axis=1), dtype=np.uint16
        )
        fi = hitX
        ti = hitX + realBw
        texti = np.array(
            (255 - img[hitY : hitY + markH, fi:ti]).max(axis=1), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    # right boundary

    to = (
        min((textW, hitX + markW + realBw + 1))
        if hitX + markW + realBw &lt; textW
        else None
    )
    if to is not None and (sides is None or &#34;r&#34; in sides):
        fo = hitX + markW
        texto = np.array(
            (255 - img[hitY : hitY + markH, fo:to]).max(axis=1), dtype=np.uint16
        )
        fi = hitX + markW - realBw
        ti = hitX + markW
        texti = np.array(
            (255 - img[hitY : hitY + markH, fi:ti]).max(axis=1), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    # top boundary

    f = max((0, hitY - realBw)) if hitY &gt; 0 else None
    if f is not None and (sides is None or &#34;t&#34; in sides):
        t = hitY
        texto = np.array(
            (255 - img[f:t, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        fi = hitY
        ti = hitY + realBw + 1
        texti = np.array(
            (255 - img[fi:ti, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    # bottom boundary

    t = (
        min((textH - 1, hitY + markH + realBw + 1))
        if hitY + markH + realBw &lt; textH
        else None
    )
    if t is not None and (sides is None or &#34;b&#34; in sides):
        f = hitY + markH
        texto = np.array(
            (255 - img[f:t, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        ti = hitY + markH
        fi = hitY + markH - realBw
        texti = np.array(
            (255 - img[fi:ti, hitX : hitX + markW]).max(axis=0), dtype=np.uint16
        )
        val = measure(texto, texti, threshold)
        connDegree += val
        nparts += 1

    return connDegree</code></pre>
</details>
</dd>
<dt id="fusus.clean.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>borderInside, borderOutside, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Measure the amount of ink that crosses the border of a certain region.</p>
<p>It is used to reject certain matches of image templates, where templates
contain strokes of ink. If a match is such that the stroke of ink connects
with the ink in the environment, the match is not a true example of the stroke
and will be rejected.</p>
<div class="admonition note">
<p class="admonition-title">Where to look for ink</p>
<p>We look for ink in the image itself,
the ink in the search template is not relevant.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>borderInside</code></strong> :&ensp;<code>image as np array</code></dt>
<dd>The part of the image bordering inside an area where the search template matches</dd>
<dt><strong><code>borderOutside</code></strong> :&ensp;<code>image as np array</code></dt>
<dd>The part of the image bordering outside an area where the search template matches</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The ratio between the size of the ink connections across the border and the
total size of the border.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/6cc4c6ea093dfbb0062b9bde174eb761909c327f/fusus/clean.py#L74-L101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def measure(borderInside, borderOutside, threshold):
    &#34;&#34;&#34;Measure the amount of ink that crosses the border of a certain region.

    It is used to reject certain matches of image templates, where templates
    contain strokes of ink. If a match is such that the stroke of ink connects
    with the ink in the environment, the match is not a true example of the stroke
    and will be rejected.

    !!! note &#34;Where to look for ink&#34;
        We look for ink in the image itself,
        the ink in the search template is not relevant.

    Parameters
    ----------
    borderInside: image as np array
        The part of the image bordering inside an area where the search template matches
    borderOutside: image as np array
        The part of the image bordering outside an area where the search template matches

    Returns
    -------
    float
        The ratio between the size of the ink connections across the border and the
        total size of the border.
    &#34;&#34;&#34;

    connections = borderInside * borderOutside
    return np.where(connections &gt; threshold)[0].size / borderOutside.size</code></pre>
</details>
</dd>
<dt id="fusus.clean.reborder"><code class="name flex">
<span>def <span class="ident">reborder</span></span>(<span>gray, bw, color, crop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a border around a grayscale image, optionally remove white margins first.</p>
<p>The border will add to the size of the image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gray</code></strong> :&ensp;<code>np array</code></dt>
<dd>A grayscale image.</dd>
<dt><strong><code>bw</code></strong> :&ensp;<code>int</code></dt>
<dd>Width of the new border.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>int</code></dt>
<dd>Color of the new border (grayscale).</dd>
<dt><strong><code>crop</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, the image will be cropped first such as to remove all surrounding
white margins.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/6cc4c6ea093dfbb0062b9bde174eb761909c327f/fusus/clean.py#L215-L243" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reborder(gray, bw, color, crop=False):
    &#34;&#34;&#34;Add a border around a grayscale image, optionally remove white margins first.

    The border will add to the size of the image.

    Parameters
    ----------
    gray: np array
        A grayscale image.
    bw: int
        Width of the new border.
    color: int
        Color of the new border (grayscale).
    crop: boolean, optional `False`
        If `True`, the image will be cropped first such as to remove all surrounding
        white margins.
    &#34;&#34;&#34;

    if crop:
        inv = 255 * (gray &lt; 128).astype(np.uint8)
        coords = cv2.findNonZero(inv)
        x, y, w, h = cv2.boundingRect(coords)
        cropped = gray[y : y + h, x : x + w]
    else:
        cropped = gray
    bordered = cv2.copyMakeBorder(
        cropped, bw, bw, bw, bw, cv2.BORDER_CONSTANT, value=color
    )
    return bordered</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/among" title="among Digital Manuscripts on GitHub"><img src="../fusus/images/fusus-small.png"></a></p>
<p><a href="../fusus/index.html">fusus home</a> -
<a href="../fusus/about/howto.html">HowTo</a>
<a href="https://github.com/among/fusus" title="GitHub repo"><img src="../fusus/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fusus" href="index.html">fusus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fusus.clean.addBox" href="#fusus.clean.addBox">addBox</a></code></li>
<li><code><a title="fusus.clean.cluster" href="#fusus.clean.cluster">cluster</a></code></li>
<li><code><a title="fusus.clean.connected" href="#fusus.clean.connected">connected</a></code></li>
<li><code><a title="fusus.clean.measure" href="#fusus.clean.measure">measure</a></code></li>
<li><code><a title="fusus.clean.reborder" href="#fusus.clean.reborder">reborder</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://digitalorientalist.com/about-cornelis-van-lit/">Cornelis van Lit</a>
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../fusus/images/dans.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>