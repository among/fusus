<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fusus.ocr API documentation</title>
<meta name="description" content="Kraken Arabic model: …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fusus.ocr</code></h1>
</header>
<section id="section-intro">
<p>Kraken Arabic model:</p>
<p><a href="https://github.com/OpenITI/OCR_GS_Data/blob/master/ara/abhath/arabic_generalized.mlmodel">OpenITI</a></p>
<p>We can call Kraken with a batch of images.</p>
<p>We can call binarization and segmentation and ocr in one call, but then
we do not get the line segmentation json file.</p>
<p>So we split it up in three batch calls: one for binarize, one for segmentation,
and one for ocr.</p>
<p>Alternatively, we can do binarization and segmentation in our preprocessing, and
use Kraken for OCR only.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L0-L460" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Kraken Arabic model:

[OpenITI](https://github.com/OpenITI/OCR_GS_Data/blob/master/ara/abhath/arabic_generalized.mlmodel)


We can call Kraken with a batch of images.

We can call binarization and segmentation and ocr in one call, but then
we do not get the line segmentation json file.

So we split it up in three batch calls: one for binarize, one for segmentation,
and one for ocr.

Alternatively, we can do binarization and segmentation in our preprocessing, and
use Kraken for OCR only.
&#34;&#34;&#34;

import warnings
from itertools import chain

from IPython.display import display, HTML

from kraken.lib.util import array2pil, pil2array
from kraken.lib.models import load_any
from kraken.binarization import nlbin
from kraken.rpred import rpred

from tf.core.helpers import unexpanduser

from .char import UChar
from .lib import DEFAULT_EXTENSION


RL = &#34;horizontal-rl&#34;
TEMPLATE = dict(
    line=&#34;&#34;&#34;\
&lt;div
    class=&#34;l&#34;
    style=&#34;
        left: «left»px;
        top: «top»px;
        width: «width»px;
        height: «height»px;
    &#34;
&gt;
    &lt;span class=&#34;n&#34;&gt;«text»&lt;/span&gt;
&lt;/div&gt;
&#34;&#34;&#34;,
    word=&#34;&#34;&#34;\
&lt;div
    class=&#34;w&#34;
    style=&#34;
        left: «left»px;
        top: «top»px;
        width: «width»px;
        height: «height»px;
        background-color: «background»;
    &#34;
&gt;
    &lt;span class=&#34;a&#34;&gt;«text»&lt;/span&gt;
&lt;/div&gt;
&#34;&#34;&#34;,
    char=&#34;&#34;&#34;\
&lt;div
    class=&#34;c&#34;
    style=&#34;
        left: «left»px;
        top: «top»px;
        width: «width»px;
        height: «height»px;
        background-color: «background»;
    &#34;
&gt;
    &lt;span class=&#34;b&#34;&gt;«text»&lt;/span&gt;
&lt;/div&gt;
&#34;&#34;&#34;,
    doc=&#34;&#34;&#34;\
&lt;html&gt;
  &lt;head&gt;
  &lt;meta charset=&#34;utf-8&#34;/&gt;
&lt;style&gt;
body {
  position: absolute;
  width: «width»px;
  height: «height»px;
}
div.page {
  position: absolute;
  width: «width»px;
  height: «height»px;
}
.img {
  position: absolute;
  width: «width»px;
}
.l {
  position: absolute;
  border-color: hsla(180, 100%, 50%, 0.3);
  border-width: 4px;
  border-style: solid;
  text-align: left;
}
.w {
  position: absolute;
  border-color: hsla(180, 100%, 50%, 0.5);
  border-width: 2px;
  border-style: solid;
  border-top-style: none;
}
.c {
  position: absolute;
  border-color: hsla(180, 100%, 50%, 0.7);
  border-width: 1px;
  border-style: solid;
  border-top-style: none;
  text-align: right;
}
.n {
  position: absolute;
  right: -1em;
  font-family: sans-serif;
  font-size: medium;
  color: #4400bb;
  vertical-align: top;
}
.a {
  position: absolute;
  top: -10px;
  right: 0px;
  font-family: Arial;
  font-size: x-large;
  color: #4400bb;
  vertical-align: top;
}
.b {
  position: absolute;
  top: -10px;
  right: 0px;
  font-family: Arial;
  font-size: large;
  color: #4400bb;
  vertical-align: top;
}
&lt;/style&gt;
  &lt;/head&gt;
&lt;body&gt;
  &lt;div class=&#34;page&#34;&gt;
    &lt;img class=&#34;img&#34; style=&#34;left: 0; top: 0;&#34; src=&#34;«source»&#34;&gt;
    «lines»
    «boxes»
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&#34;&#34;&#34;,
)


CONF_COLOR = (
    (0, 50, 0, 10, 30, 40, 0.6, 0.6),
    (50, 80, 10, 30, 40, 50, 0.6, 0.5),
    (80, 100, 30, 90, 50, 60, 0.5, 0.3),
    (90, 100, 90, 120, 60, 70, 0.3, 0.1),
)


def getProofColor(conf, test=False):
    for (
        fromConf,
        toConf,
        fromHue,
        toHue,
        fromLight,
        toLight,
        fromOpacity,
        toOpacity,
    ) in CONF_COLOR:
        if conf &gt; toConf:
            continue
        spread = toConf - fromConf
        slopeHue = (toHue - fromHue) / spread
        slopeOpacity = (toOpacity - fromOpacity) / spread
        slopeLight = (toLight - fromLight) / spread
        excess = conf - fromConf
        hue = fromHue + int(round(excess * slopeHue))
        opacity = fromOpacity + excess * slopeOpacity
        light = fromLight + int(round(excess * slopeLight))
        break
    hsla = f&#34;hsla({hue}, 100%, {light}%, {opacity:.2f})&#34;
    if test:
        display(
            HTML(
                f&#34;&#34;&#34;
&lt;p style=&#34;background-color: {hsla}; font-family: monospace;&#34;&gt;
    conf={conf:&gt;3} ⇒ hue={hue:&gt;3} op={opacity:.2f}
&lt;/p&gt;
                &#34;&#34;&#34;
            )
        )
    return hsla


def showConf(stage, results, label=&#34;notes&#34;):
    header = f&#34;&#34;&#34;
    &lt;tr&gt;
        &lt;th&gt;item&lt;/th&gt;
        &lt;th&gt;# of {stage}s&lt;/th&gt;
        &lt;th&gt;min&lt;/th&gt;
        &lt;th&gt;max&lt;/th&gt;
        &lt;th&gt;average&lt;/th&gt;
        &lt;th style=&#34;text-align: left;&#34;&gt;{label}&lt;/th&gt;
    &lt;/tr&gt;
    &#34;&#34;&#34;

    rows = [header]
    style = &#39;&#39;&#39; style=&#34;background-color: {};&#34;&#39;&#39;&#39;
    for (label, n, minC, maxC, totC, notes) in results:
        avC = int(round(totC / n))

        minCol = getProofColor(minC)
        maxCol = getProofColor(maxC)
        avCol = getProofColor(avC)

        minSt = style.format(minCol)
        maxSt = style.format(maxCol)
        avSt = style.format(avCol)

        row = f&#34;&#34;&#34;
    &lt;tr&gt;
        &lt;th&gt;{label}&lt;/th&gt;
        &lt;td&gt;{n}&lt;/td&gt;
        &lt;td{minSt}&gt;{minC}&lt;/td&gt;
        &lt;td{maxSt}&gt;{maxC}&lt;/td&gt;
        &lt;td{avSt}&gt;{avC}&lt;/td&gt;
        &lt;td style=&#34;text-align: left;&#34;&gt;{notes}&lt;/td&gt;
    &lt;/tr&gt;
        &#34;&#34;&#34;
        rows.append(row)

    html = f&#34;&#34;&#34;
&lt;table&gt;
{&#34;&#34;.join(rows[0:10])}
&lt;/table&gt;
&#34;&#34;&#34;
    if len(rows) &gt; 10:
        html += f&#34;&#34;&#34;
&lt;details&gt;
    &lt;summary&gt;see {len(rows) - 10} more:&lt;/summary&gt;
&lt;table&gt;
{header}
{&#34;&#34;.join(rows[10:])}
&lt;/table&gt;
&lt;/details&gt;
        &#34;&#34;&#34;
    display(HTML(html))


class OCR(UChar):
    def __init__(self, engine):
        &#34;&#34;&#34;Sets up OCR with Kraken.&#34;&#34;&#34;

        super().__init__()

        self.engine = engine
        self.model = None

    def ensureLoaded(self):
        if self.model is None:
            engine = self.engine
            C = engine.C
            tm = engine.tm
            info = tm.info
            modelPath = C.modelPath

            info(f&#34;Loading for Kraken: {unexpanduser(modelPath)}&#34;, force=True)
            with warnings.catch_warnings():
                warnings.filterwarnings(&#34;ignore&#34;)
                model = load_any(modelPath)
            info(&#34;model loaded&#34;, force=True)

            self.model = model
        return self.model

    def read(self, page):
        &#34;&#34;&#34;Perfoms OCR with Kraken.&#34;&#34;&#34;

        stages = page.stages
        scan = stages.get(&#34;clean&#34;, None)
        if scan is None:
            return None

        nonLetter = self.nonLetter

        model = self.ensureLoaded()

        blocks = page.blocks
        ocrChars = []
        ocrWords = []
        ocrLines = []
        stages[&#34;char&#34;] = ocrChars
        stages[&#34;word&#34;] = ocrWords
        stages[&#34;line&#34;] = ocrLines
        binary = pil2array(nlbin(array2pil(scan)))

        for ((stripe, block), data) in blocks.items():
            (left, top, right, bottom) = data[&#34;inner&#34;]
            thisBinary = binary[top:bottom, left:right]
            lines = data[&#34;bands&#34;][&#34;main&#34;][&#34;lines&#34;]
            for (ln, (up, lo)) in enumerate(lines):
                lln = ln + 1
                roi = thisBinary[up : lo + 1]
                (b, e, roi) = removeMargins(roi, keep=16)
                ocrLines.append((stripe, block, lln, left + b, top + up, left + e, top + lo))
                (roiH, roiW) = roi.shape[0:2]
                roi = array2pil(roi)
                bounds = dict(boxes=([0, 0, roiW, roiH],), text_direction=RL)

                # adapt the boxes, because they corresponds to peaks of recognition,
                # not to character extends
                #
                # See https://github.com/mittagessen/kraken/issues/184

                adaptedPreds = []
                for (c, (le, to, ri, bo), conf) in chain.from_iterable(
                    rpred(model, roi, bounds, pad=0, bidi_reordering=True)
                ):
                    if adaptedPreds:
                        prevPred = adaptedPreds[-1]
                        prevEdge = prevPred[1][0]
                    else:
                        prevEdge = roiW
                    correction = int(round((prevEdge - ri) / 2))
                    thisRi = ri + correction
                    if adaptedPreds:
                        adaptedPreds[-1][1][0] -= correction
                    adaptedPreds.append([c, [le, to, thisRi, bo], conf])
                if adaptedPreds:
                    adaptedPreds[-1][1][0] = 0

                # divide into words, not only on spaces, but also on punctuation

                curWord = [[], []]
                inWord = True

                for (c, (le, to, ri, bo), conf) in adaptedPreds:
                    offsetW = left + b
                    offsetH = top + up
                    pos = (le + offsetW, to + offsetH, ri + offsetW, bo + offsetH)
                    conf = int(round(conf * 100))
                    ocrChars.append((stripe, block, lln, *pos, conf, c))

                    spaceSeen = c == &#34; &#34;
                    changeWord = not inWord and c not in nonLetter
                    element = (c, pos, conf)

                    if spaceSeen:
                        curWord[1].append(element)
                    if spaceSeen or changeWord:
                        if curWord[0] or curWord[1]:
                            ocrWords.append((stripe, block, lln, *addWord(curWord)))
                            curWord = [[], []]
                            inWord = True
                            continue

                    if inWord:
                        if c in nonLetter:
                            inWord = False
                    dest = 0 if inWord else 1
                    curWord[dest].append(element)
                if curWord[0] or curWord[1]:
                    ocrWords.append((stripe, block, lln, *addWord(curWord)))

        page.write(stage=&#34;line,word,char&#34;)

    def proofing(self, page):
        &#34;&#34;&#34;Produces an OCR proof page&#34;&#34;&#34;

        stages = page.stages

        ocrLines = stages[&#34;line&#34;]
        normalized = stages[&#34;normalized&#34;]
        (h, w) = normalized.shape[:2]

        scale = 1 if w == 0 else 1000 / w

        def g(m, asStr=True):
            scaledM = m if scale == 1 else int(round(m * scale))
            return str(scaledM) if asStr else scaledM

        page.proofW = g(w, asStr=False)
        page.proofH = g(h, asStr=False)

        linesHtml = &#34;&#34;.join(
            TEMPLATE[&#34;line&#34;]
            .replace(&#34;«left»&#34;, g(left))
            .replace(&#34;«top»&#34;, g(top))
            .replace(&#34;«width»&#34;, g(right - left))
            .replace(&#34;«height»&#34;, g(bottom - top))
            .replace(&#34;«text»&#34;, f&#34;{ln:&gt;01}&#34;)
            for (stripe, block, ln, left, top, right, bottom) in ocrLines
        )

        for stage in (&#34;char&#34;, &#34;word&#34;):
            stageData = stages.get(stage, [])
            boxesHtml = []
            for (
                stripe,
                block,
                ln,
                left,
                top,
                right,
                bottom,
                conf,
                *rest,
            ) in stageData:
                boxesHtml.append(
                    TEMPLATE[stage]
                    .replace(&#34;«left»&#34;, g(left))
                    .replace(&#34;«top»&#34;, g(top))
                    .replace(&#34;«width»&#34;, g(right - left))
                    .replace(&#34;«height»&#34;, g(bottom - top))
                    .replace(&#34;«background»&#34;, getProofColor(conf))
                    .replace(&#34;«text»&#34;, &#34;&#34;.join(rest))
                )

            boxesHtml = &#34;&#34;.join(boxesHtml)
            proofData = (
                TEMPLATE[&#34;doc&#34;]
                .replace(&#34;«width»&#34;, g(w))
                .replace(&#34;«height»&#34;, g(h))
                .replace(&#34;«source»&#34;, f&#34;{page.bare}.{DEFAULT_EXTENSION}&#34;)
                .replace(&#34;«lines»&#34;, linesHtml)
                .replace(&#34;«boxes»&#34;, boxesHtml)
            )
            proofStage = f&#34;proof{stage}&#34;
            with open(page.stagePath(proofStage), &#34;w&#34;) as f:
                f.write(proofData)
            stages[proofStage] = f&#34;see proof at {stage} level&#34;


def removeMargins(img, keep=0):
    mask = img &lt; 255
    w = img.shape[1]
    mask0 = mask.any(0)
    (start, end) = (mask0.argmax(), w - mask0[::-1].argmax())
    (start, end) = (max((0, start - keep)), min((w, end + keep)))
    return (start, end, img[:, start:end])


def addWord(curWord):
    letters = &#34;&#34;.join(x[0] for x in curWord[0])
    punc = &#34;&#34;.join(x[0] for x in curWord[1])
    allChars = curWord[0] + curWord[1]
    conf = int(round(sum(x[-1] for x in allChars) / len(allChars)))
    left = min(x[1][0] for x in allChars)
    top = min(x[1][1] for x in allChars)
    right = max(x[1][2] for x in allChars)
    bot = max(x[1][3] for x in allChars)

    return (left, top, right, bot, conf, letters, punc)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fusus.ocr.addWord"><code class="name flex">
<span>def <span class="ident">addWord</span></span>(<span>curWord)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L451-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addWord(curWord):
    letters = &#34;&#34;.join(x[0] for x in curWord[0])
    punc = &#34;&#34;.join(x[0] for x in curWord[1])
    allChars = curWord[0] + curWord[1]
    conf = int(round(sum(x[-1] for x in allChars) / len(allChars)))
    left = min(x[1][0] for x in allChars)
    top = min(x[1][1] for x in allChars)
    right = max(x[1][2] for x in allChars)
    bot = max(x[1][3] for x in allChars)

    return (left, top, right, bot, conf, letters, punc)</code></pre>
</details>
</dd>
<dt id="fusus.ocr.getProofColor"><code class="name flex">
<span>def <span class="ident">getProofColor</span></span>(<span>conf, test=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L167-L200" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getProofColor(conf, test=False):
    for (
        fromConf,
        toConf,
        fromHue,
        toHue,
        fromLight,
        toLight,
        fromOpacity,
        toOpacity,
    ) in CONF_COLOR:
        if conf &gt; toConf:
            continue
        spread = toConf - fromConf
        slopeHue = (toHue - fromHue) / spread
        slopeOpacity = (toOpacity - fromOpacity) / spread
        slopeLight = (toLight - fromLight) / spread
        excess = conf - fromConf
        hue = fromHue + int(round(excess * slopeHue))
        opacity = fromOpacity + excess * slopeOpacity
        light = fromLight + int(round(excess * slopeLight))
        break
    hsla = f&#34;hsla({hue}, 100%, {light}%, {opacity:.2f})&#34;
    if test:
        display(
            HTML(
                f&#34;&#34;&#34;
&lt;p style=&#34;background-color: {hsla}; font-family: monospace;&#34;&gt;
    conf={conf:&gt;3} ⇒ hue={hue:&gt;3} op={opacity:.2f}
&lt;/p&gt;
                &#34;&#34;&#34;
            )
        )
    return hsla</code></pre>
</details>
</dd>
<dt id="fusus.ocr.removeMargins"><code class="name flex">
<span>def <span class="ident">removeMargins</span></span>(<span>img, keep=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L442-L448" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def removeMargins(img, keep=0):
    mask = img &lt; 255
    w = img.shape[1]
    mask0 = mask.any(0)
    (start, end) = (mask0.argmax(), w - mask0[::-1].argmax())
    (start, end) = (max((0, start - keep)), min((w, end + keep)))
    return (start, end, img[:, start:end])</code></pre>
</details>
</dd>
<dt id="fusus.ocr.showConf"><code class="name flex">
<span>def <span class="ident">showConf</span></span>(<span>stage, results, label='notes')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L203-L255" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showConf(stage, results, label=&#34;notes&#34;):
    header = f&#34;&#34;&#34;
    &lt;tr&gt;
        &lt;th&gt;item&lt;/th&gt;
        &lt;th&gt;# of {stage}s&lt;/th&gt;
        &lt;th&gt;min&lt;/th&gt;
        &lt;th&gt;max&lt;/th&gt;
        &lt;th&gt;average&lt;/th&gt;
        &lt;th style=&#34;text-align: left;&#34;&gt;{label}&lt;/th&gt;
    &lt;/tr&gt;
    &#34;&#34;&#34;

    rows = [header]
    style = &#39;&#39;&#39; style=&#34;background-color: {};&#34;&#39;&#39;&#39;
    for (label, n, minC, maxC, totC, notes) in results:
        avC = int(round(totC / n))

        minCol = getProofColor(minC)
        maxCol = getProofColor(maxC)
        avCol = getProofColor(avC)

        minSt = style.format(minCol)
        maxSt = style.format(maxCol)
        avSt = style.format(avCol)

        row = f&#34;&#34;&#34;
    &lt;tr&gt;
        &lt;th&gt;{label}&lt;/th&gt;
        &lt;td&gt;{n}&lt;/td&gt;
        &lt;td{minSt}&gt;{minC}&lt;/td&gt;
        &lt;td{maxSt}&gt;{maxC}&lt;/td&gt;
        &lt;td{avSt}&gt;{avC}&lt;/td&gt;
        &lt;td style=&#34;text-align: left;&#34;&gt;{notes}&lt;/td&gt;
    &lt;/tr&gt;
        &#34;&#34;&#34;
        rows.append(row)

    html = f&#34;&#34;&#34;
&lt;table&gt;
{&#34;&#34;.join(rows[0:10])}
&lt;/table&gt;
&#34;&#34;&#34;
    if len(rows) &gt; 10:
        html += f&#34;&#34;&#34;
&lt;details&gt;
    &lt;summary&gt;see {len(rows) - 10} more:&lt;/summary&gt;
&lt;table&gt;
{header}
{&#34;&#34;.join(rows[10:])}
&lt;/table&gt;
&lt;/details&gt;
        &#34;&#34;&#34;
    display(HTML(html))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fusus.ocr.OCR"><code class="flex name class">
<span>class <span class="ident">OCR</span></span>
<span>(</span><span>engine)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets up OCR with Kraken.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L258-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class OCR(UChar):
    def __init__(self, engine):
        &#34;&#34;&#34;Sets up OCR with Kraken.&#34;&#34;&#34;

        super().__init__()

        self.engine = engine
        self.model = None

    def ensureLoaded(self):
        if self.model is None:
            engine = self.engine
            C = engine.C
            tm = engine.tm
            info = tm.info
            modelPath = C.modelPath

            info(f&#34;Loading for Kraken: {unexpanduser(modelPath)}&#34;, force=True)
            with warnings.catch_warnings():
                warnings.filterwarnings(&#34;ignore&#34;)
                model = load_any(modelPath)
            info(&#34;model loaded&#34;, force=True)

            self.model = model
        return self.model

    def read(self, page):
        &#34;&#34;&#34;Perfoms OCR with Kraken.&#34;&#34;&#34;

        stages = page.stages
        scan = stages.get(&#34;clean&#34;, None)
        if scan is None:
            return None

        nonLetter = self.nonLetter

        model = self.ensureLoaded()

        blocks = page.blocks
        ocrChars = []
        ocrWords = []
        ocrLines = []
        stages[&#34;char&#34;] = ocrChars
        stages[&#34;word&#34;] = ocrWords
        stages[&#34;line&#34;] = ocrLines
        binary = pil2array(nlbin(array2pil(scan)))

        for ((stripe, block), data) in blocks.items():
            (left, top, right, bottom) = data[&#34;inner&#34;]
            thisBinary = binary[top:bottom, left:right]
            lines = data[&#34;bands&#34;][&#34;main&#34;][&#34;lines&#34;]
            for (ln, (up, lo)) in enumerate(lines):
                lln = ln + 1
                roi = thisBinary[up : lo + 1]
                (b, e, roi) = removeMargins(roi, keep=16)
                ocrLines.append((stripe, block, lln, left + b, top + up, left + e, top + lo))
                (roiH, roiW) = roi.shape[0:2]
                roi = array2pil(roi)
                bounds = dict(boxes=([0, 0, roiW, roiH],), text_direction=RL)

                # adapt the boxes, because they corresponds to peaks of recognition,
                # not to character extends
                #
                # See https://github.com/mittagessen/kraken/issues/184

                adaptedPreds = []
                for (c, (le, to, ri, bo), conf) in chain.from_iterable(
                    rpred(model, roi, bounds, pad=0, bidi_reordering=True)
                ):
                    if adaptedPreds:
                        prevPred = adaptedPreds[-1]
                        prevEdge = prevPred[1][0]
                    else:
                        prevEdge = roiW
                    correction = int(round((prevEdge - ri) / 2))
                    thisRi = ri + correction
                    if adaptedPreds:
                        adaptedPreds[-1][1][0] -= correction
                    adaptedPreds.append([c, [le, to, thisRi, bo], conf])
                if adaptedPreds:
                    adaptedPreds[-1][1][0] = 0

                # divide into words, not only on spaces, but also on punctuation

                curWord = [[], []]
                inWord = True

                for (c, (le, to, ri, bo), conf) in adaptedPreds:
                    offsetW = left + b
                    offsetH = top + up
                    pos = (le + offsetW, to + offsetH, ri + offsetW, bo + offsetH)
                    conf = int(round(conf * 100))
                    ocrChars.append((stripe, block, lln, *pos, conf, c))

                    spaceSeen = c == &#34; &#34;
                    changeWord = not inWord and c not in nonLetter
                    element = (c, pos, conf)

                    if spaceSeen:
                        curWord[1].append(element)
                    if spaceSeen or changeWord:
                        if curWord[0] or curWord[1]:
                            ocrWords.append((stripe, block, lln, *addWord(curWord)))
                            curWord = [[], []]
                            inWord = True
                            continue

                    if inWord:
                        if c in nonLetter:
                            inWord = False
                    dest = 0 if inWord else 1
                    curWord[dest].append(element)
                if curWord[0] or curWord[1]:
                    ocrWords.append((stripe, block, lln, *addWord(curWord)))

        page.write(stage=&#34;line,word,char&#34;)

    def proofing(self, page):
        &#34;&#34;&#34;Produces an OCR proof page&#34;&#34;&#34;

        stages = page.stages

        ocrLines = stages[&#34;line&#34;]
        normalized = stages[&#34;normalized&#34;]
        (h, w) = normalized.shape[:2]

        scale = 1 if w == 0 else 1000 / w

        def g(m, asStr=True):
            scaledM = m if scale == 1 else int(round(m * scale))
            return str(scaledM) if asStr else scaledM

        page.proofW = g(w, asStr=False)
        page.proofH = g(h, asStr=False)

        linesHtml = &#34;&#34;.join(
            TEMPLATE[&#34;line&#34;]
            .replace(&#34;«left»&#34;, g(left))
            .replace(&#34;«top»&#34;, g(top))
            .replace(&#34;«width»&#34;, g(right - left))
            .replace(&#34;«height»&#34;, g(bottom - top))
            .replace(&#34;«text»&#34;, f&#34;{ln:&gt;01}&#34;)
            for (stripe, block, ln, left, top, right, bottom) in ocrLines
        )

        for stage in (&#34;char&#34;, &#34;word&#34;):
            stageData = stages.get(stage, [])
            boxesHtml = []
            for (
                stripe,
                block,
                ln,
                left,
                top,
                right,
                bottom,
                conf,
                *rest,
            ) in stageData:
                boxesHtml.append(
                    TEMPLATE[stage]
                    .replace(&#34;«left»&#34;, g(left))
                    .replace(&#34;«top»&#34;, g(top))
                    .replace(&#34;«width»&#34;, g(right - left))
                    .replace(&#34;«height»&#34;, g(bottom - top))
                    .replace(&#34;«background»&#34;, getProofColor(conf))
                    .replace(&#34;«text»&#34;, &#34;&#34;.join(rest))
                )

            boxesHtml = &#34;&#34;.join(boxesHtml)
            proofData = (
                TEMPLATE[&#34;doc&#34;]
                .replace(&#34;«width»&#34;, g(w))
                .replace(&#34;«height»&#34;, g(h))
                .replace(&#34;«source»&#34;, f&#34;{page.bare}.{DEFAULT_EXTENSION}&#34;)
                .replace(&#34;«lines»&#34;, linesHtml)
                .replace(&#34;«boxes»&#34;, boxesHtml)
            )
            proofStage = f&#34;proof{stage}&#34;
            with open(page.stagePath(proofStage), &#34;w&#34;) as f:
                f.write(proofData)
            stages[proofStage] = f&#34;see proof at {stage} level&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fusus.char.UChar" href="char.html#fusus.char.UChar">UChar</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fusus.ocr.OCR.ensureLoaded"><code class="name flex">
<span>def <span class="ident">ensureLoaded</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L267-L282" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ensureLoaded(self):
    if self.model is None:
        engine = self.engine
        C = engine.C
        tm = engine.tm
        info = tm.info
        modelPath = C.modelPath

        info(f&#34;Loading for Kraken: {unexpanduser(modelPath)}&#34;, force=True)
        with warnings.catch_warnings():
            warnings.filterwarnings(&#34;ignore&#34;)
            model = load_any(modelPath)
        info(&#34;model loaded&#34;, force=True)

        self.model = model
    return self.model</code></pre>
</details>
</dd>
<dt id="fusus.ocr.OCR.proofing"><code class="name flex">
<span>def <span class="ident">proofing</span></span>(<span>self, page)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces an OCR proof page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L375-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def proofing(self, page):
    &#34;&#34;&#34;Produces an OCR proof page&#34;&#34;&#34;

    stages = page.stages

    ocrLines = stages[&#34;line&#34;]
    normalized = stages[&#34;normalized&#34;]
    (h, w) = normalized.shape[:2]

    scale = 1 if w == 0 else 1000 / w

    def g(m, asStr=True):
        scaledM = m if scale == 1 else int(round(m * scale))
        return str(scaledM) if asStr else scaledM

    page.proofW = g(w, asStr=False)
    page.proofH = g(h, asStr=False)

    linesHtml = &#34;&#34;.join(
        TEMPLATE[&#34;line&#34;]
        .replace(&#34;«left»&#34;, g(left))
        .replace(&#34;«top»&#34;, g(top))
        .replace(&#34;«width»&#34;, g(right - left))
        .replace(&#34;«height»&#34;, g(bottom - top))
        .replace(&#34;«text»&#34;, f&#34;{ln:&gt;01}&#34;)
        for (stripe, block, ln, left, top, right, bottom) in ocrLines
    )

    for stage in (&#34;char&#34;, &#34;word&#34;):
        stageData = stages.get(stage, [])
        boxesHtml = []
        for (
            stripe,
            block,
            ln,
            left,
            top,
            right,
            bottom,
            conf,
            *rest,
        ) in stageData:
            boxesHtml.append(
                TEMPLATE[stage]
                .replace(&#34;«left»&#34;, g(left))
                .replace(&#34;«top»&#34;, g(top))
                .replace(&#34;«width»&#34;, g(right - left))
                .replace(&#34;«height»&#34;, g(bottom - top))
                .replace(&#34;«background»&#34;, getProofColor(conf))
                .replace(&#34;«text»&#34;, &#34;&#34;.join(rest))
            )

        boxesHtml = &#34;&#34;.join(boxesHtml)
        proofData = (
            TEMPLATE[&#34;doc&#34;]
            .replace(&#34;«width»&#34;, g(w))
            .replace(&#34;«height»&#34;, g(h))
            .replace(&#34;«source»&#34;, f&#34;{page.bare}.{DEFAULT_EXTENSION}&#34;)
            .replace(&#34;«lines»&#34;, linesHtml)
            .replace(&#34;«boxes»&#34;, boxesHtml)
        )
        proofStage = f&#34;proof{stage}&#34;
        with open(page.stagePath(proofStage), &#34;w&#34;) as f:
            f.write(proofData)
        stages[proofStage] = f&#34;see proof at {stage} level&#34;</code></pre>
</details>
</dd>
<dt id="fusus.ocr.OCR.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, page)</span>
</code></dt>
<dd>
<div class="desc"><p>Perfoms OCR with Kraken.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/ocr.py#L284-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, page):
    &#34;&#34;&#34;Perfoms OCR with Kraken.&#34;&#34;&#34;

    stages = page.stages
    scan = stages.get(&#34;clean&#34;, None)
    if scan is None:
        return None

    nonLetter = self.nonLetter

    model = self.ensureLoaded()

    blocks = page.blocks
    ocrChars = []
    ocrWords = []
    ocrLines = []
    stages[&#34;char&#34;] = ocrChars
    stages[&#34;word&#34;] = ocrWords
    stages[&#34;line&#34;] = ocrLines
    binary = pil2array(nlbin(array2pil(scan)))

    for ((stripe, block), data) in blocks.items():
        (left, top, right, bottom) = data[&#34;inner&#34;]
        thisBinary = binary[top:bottom, left:right]
        lines = data[&#34;bands&#34;][&#34;main&#34;][&#34;lines&#34;]
        for (ln, (up, lo)) in enumerate(lines):
            lln = ln + 1
            roi = thisBinary[up : lo + 1]
            (b, e, roi) = removeMargins(roi, keep=16)
            ocrLines.append((stripe, block, lln, left + b, top + up, left + e, top + lo))
            (roiH, roiW) = roi.shape[0:2]
            roi = array2pil(roi)
            bounds = dict(boxes=([0, 0, roiW, roiH],), text_direction=RL)

            # adapt the boxes, because they corresponds to peaks of recognition,
            # not to character extends
            #
            # See https://github.com/mittagessen/kraken/issues/184

            adaptedPreds = []
            for (c, (le, to, ri, bo), conf) in chain.from_iterable(
                rpred(model, roi, bounds, pad=0, bidi_reordering=True)
            ):
                if adaptedPreds:
                    prevPred = adaptedPreds[-1]
                    prevEdge = prevPred[1][0]
                else:
                    prevEdge = roiW
                correction = int(round((prevEdge - ri) / 2))
                thisRi = ri + correction
                if adaptedPreds:
                    adaptedPreds[-1][1][0] -= correction
                adaptedPreds.append([c, [le, to, thisRi, bo], conf])
            if adaptedPreds:
                adaptedPreds[-1][1][0] = 0

            # divide into words, not only on spaces, but also on punctuation

            curWord = [[], []]
            inWord = True

            for (c, (le, to, ri, bo), conf) in adaptedPreds:
                offsetW = left + b
                offsetH = top + up
                pos = (le + offsetW, to + offsetH, ri + offsetW, bo + offsetH)
                conf = int(round(conf * 100))
                ocrChars.append((stripe, block, lln, *pos, conf, c))

                spaceSeen = c == &#34; &#34;
                changeWord = not inWord and c not in nonLetter
                element = (c, pos, conf)

                if spaceSeen:
                    curWord[1].append(element)
                if spaceSeen or changeWord:
                    if curWord[0] or curWord[1]:
                        ocrWords.append((stripe, block, lln, *addWord(curWord)))
                        curWord = [[], []]
                        inWord = True
                        continue

                if inWord:
                    if c in nonLetter:
                        inWord = False
                dest = 0 if inWord else 1
                curWord[dest].append(element)
            if curWord[0] or curWord[1]:
                ocrWords.append((stripe, block, lln, *addWord(curWord)))

    page.write(stage=&#34;line,word,char&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fusus.char.UChar" href="char.html#fusus.char.UChar">UChar</a></b></code>:
<ul class="hlist">
<li><code><a title="fusus.char.UChar.arabic" href="char.html#fusus.char.UChar.arabic">arabic</a></code></li>
<li><code><a title="fusus.char.UChar.arabicLetters" href="char.html#fusus.char.UChar.arabicLetters">arabicLetters</a></code></li>
<li><code><a title="fusus.char.UChar.arabicPresentational" href="char.html#fusus.char.UChar.arabicPresentational">arabicPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.bracketMap" href="char.html#fusus.char.UChar.bracketMap">bracketMap</a></code></li>
<li><code><a title="fusus.char.UChar.diacriticLike" href="char.html#fusus.char.UChar.diacriticLike">diacriticLike</a></code></li>
<li><code><a title="fusus.char.UChar.diacritics" href="char.html#fusus.char.UChar.diacritics">diacritics</a></code></li>
<li><code><a title="fusus.char.UChar.finalSpace" href="char.html#fusus.char.UChar.finalSpace">finalSpace</a></code></li>
<li><code><a title="fusus.char.UChar.greekPresentational" href="char.html#fusus.char.UChar.greekPresentational">greekPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.hebrew" href="char.html#fusus.char.UChar.hebrew">hebrew</a></code></li>
<li><code><a title="fusus.char.UChar.hebrewPresentational" href="char.html#fusus.char.UChar.hebrewPresentational">hebrewPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.latinPresentational" href="char.html#fusus.char.UChar.latinPresentational">latinPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.neutrals" href="char.html#fusus.char.UChar.neutrals">neutrals</a></code></li>
<li><code><a title="fusus.char.UChar.nonLetter" href="char.html#fusus.char.UChar.nonLetter">nonLetter</a></code></li>
<li><code><a title="fusus.char.UChar.nospacings" href="char.html#fusus.char.UChar.nospacings">nospacings</a></code></li>
<li><code><a title="fusus.char.UChar.presentational" href="char.html#fusus.char.UChar.presentational">presentational</a></code></li>
<li><code><a title="fusus.char.UChar.presentationalC" href="char.html#fusus.char.UChar.presentationalC">presentationalC</a></code></li>
<li><code><a title="fusus.char.UChar.presentationalD" href="char.html#fusus.char.UChar.presentationalD">presentationalD</a></code></li>
<li><code><a title="fusus.char.UChar.puas" href="char.html#fusus.char.UChar.puas">puas</a></code></li>
<li><code><a title="fusus.char.UChar.punct" href="char.html#fusus.char.UChar.punct">punct</a></code></li>
<li><code><a title="fusus.char.UChar.rls" href="char.html#fusus.char.UChar.rls">rls</a></code></li>
<li><code><a title="fusus.char.UChar.semis" href="char.html#fusus.char.UChar.semis">semis</a></code></li>
<li><code><a title="fusus.char.UChar.stops" href="char.html#fusus.char.UChar.stops">stops</a></code></li>
<li><code><a title="fusus.char.UChar.syriac" href="char.html#fusus.char.UChar.syriac">syriac</a></code></li>
<li><code><a title="fusus.char.UChar.wordRe" href="char.html#fusus.char.UChar.wordRe">wordRe</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/among" title="among Digital Manuscripts on GitHub"><img src="../fusus/images/fusus-small.png"></a></p>
<p><a href="../fusus/index.html">fusus home</a> -
<a href="../fusus/about/howto.html">HowTo</a>
<a href="https://github.com/among/fusus" title="GitHub repo"><img src="../fusus/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fusus" href="index.html">fusus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fusus.ocr.addWord" href="#fusus.ocr.addWord">addWord</a></code></li>
<li><code><a title="fusus.ocr.getProofColor" href="#fusus.ocr.getProofColor">getProofColor</a></code></li>
<li><code><a title="fusus.ocr.removeMargins" href="#fusus.ocr.removeMargins">removeMargins</a></code></li>
<li><code><a title="fusus.ocr.showConf" href="#fusus.ocr.showConf">showConf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fusus.ocr.OCR" href="#fusus.ocr.OCR">OCR</a></code></h4>
<ul class="">
<li><code><a title="fusus.ocr.OCR.ensureLoaded" href="#fusus.ocr.OCR.ensureLoaded">ensureLoaded</a></code></li>
<li><code><a title="fusus.ocr.OCR.proofing" href="#fusus.ocr.OCR.proofing">proofing</a></code></li>
<li><code><a title="fusus.ocr.OCR.read" href="#fusus.ocr.OCR.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://digitalorientalist.com/about-cornelis-van-lit/">Cornelis van Lit</a>
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../fusus/images/dans.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>