<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fusus.char API documentation</title>
<meta name="description" content="Character knowledge â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fusus.char</code></h1>
</header>
<section id="section-intro">
<p>Character knowledge.</p>
<p>This module collects all character knowledge that we need to parse the
Lakhnawi PDF and makes it available to programs.</p>
<p>It contains definitions for things as character classes,
e.g. <em>symbols</em>, <em>presentational characters</em>, <em>punctuation</em>,
<em>bracket-like characters</em>, etc.</p>
<p>See <code><a title="fusus.char.UChar" href="#fusus.char.UChar">UChar</a></code> below.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L0-L454" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Character knowledge.

This module collects all character knowledge that we need to parse the
Lakhnawi PDF and makes it available to programs.

It contains definitions for things as character classes,
e.g. *symbols*, *presentational characters*, *punctuation*,
*bracket-like characters*, etc.

See `UChar` below.
&#34;&#34;&#34;

import re
from unicodedata import name as uname, normalize


NFKC = &#34;NFKC&#34;
NFKD = &#34;NFKD&#34;

EMSPACE = &#34;\u2003&#34;

PUA_RANGES = ((&#34;e000&#34;, &#34;f8ff&#34;),)

LATIN_PRESENTATIONAL_RANGES = ((&#34;00c0&#34;, &#34;024f&#34;), (&#34;1e00&#34;, &#34;1eff&#34;), (&#34;fb00&#34;, &#34;fb06&#34;))

GREEK_PRESENTATIONAL_RANGES = ((&#34;1f00&#34;, &#34;1fff&#34;),)

ARABIC_RANGES = (
    (&#34;0600&#34;, &#34;06ff&#34;),
    (&#34;0750&#34;, &#34;077f&#34;),
    (&#34;08a0&#34;, &#34;08ff&#34;),
    (&#34;206a&#34;, &#34;206f&#34;),
    (&#34;fb50&#34;, &#34;fdc7&#34;),
    (&#34;fdf0&#34;, &#34;fdfd&#34;),
    (&#34;fe70&#34;, &#34;fefc&#34;),
)
ARABIC_SYMBOL_RANGES = (
    (&#34;060c&#34;, &#34;060c&#34;),
    (&#34;061b&#34;, &#34;061f&#34;),
    (&#34;fd3e&#34;, &#34;fd3f&#34;),
)
STOP_RANGES = (
    (&#34;002e&#34;, &#34;002e&#34;),
    (&#34;06d4&#34;, &#34;06d4&#34;),
)

PUNCT_RANGES = (
    (&#34;0021&#34;, &#34;0021&#34;),
    (&#34;002c&#34;, &#34;002c&#34;),
    (&#34;003a&#34;, &#34;003b&#34;),
    (&#34;003f&#34;, &#34;003f&#34;),
    (&#34;00a1&#34;, &#34;00a1&#34;),
    (&#34;00bf&#34;, &#34;00bf&#34;),
    (&#34;037e&#34;, &#34;037e&#34;),
    (&#34;0387&#34;, &#34;0387&#34;),
    (&#34;05c3&#34;, &#34;05c3&#34;),
    (&#34;060c&#34;, &#34;060c&#34;),
    (&#34;061b&#34;, &#34;061b&#34;),
    (&#34;061e&#34;, &#34;061f&#34;),
)

ARABIC_PRESENTATIONAL_RANGES = ((&#34;fb50&#34;, &#34;feff&#34;),)

SYRIAC_RANGES = (
    (&#34;0700&#34;, &#34;074f&#34;),
    (&#34;2670&#34;, &#34;2671&#34;),
)

HEBREW_RANGES = (
    (&#34;0590&#34;, &#34;05ff&#34;),
    (&#34;fb1d&#34;, &#34;fb4f&#34;),
)

HEBREW_PRESENTATIONAL_RANGES = ((&#34;fb1d&#34;, &#34;fb4f&#34;),)

SYMBOL_RANGES = (
    (&#34;0021&#34;, &#34;0027&#34;),  # exclamation, prime, dollar, etc
    (&#34;002a&#34;, &#34;002f&#34;),  # star, comma, minus, stop, slash
    (&#34;003a&#34;, &#34;003b&#34;),  # colon, semicolon
    (&#34;003d&#34;, &#34;003d&#34;),  # equals
    (&#34;003f&#34;, &#34;0040&#34;),  # question mark, commercial
    (&#34;02b0&#34;, &#34;036f&#34;),  # modifiers, combiners, accents
    (&#34;2010&#34;, &#34;2017&#34;),  # dashes
    (&#34;201a&#34;, &#34;201b&#34;),  # single quotation marks
    (&#34;201e&#34;, &#34;201f&#34;),  # double quotation marks
    (&#34;2020&#34;, &#34;2029&#34;),  # dagger, bullet, leader, ellipsis
)

BRACKET_RANGES = (
    (&#34;0028&#34;, &#34;0029&#34;),  # parentheses
    (&#34;003c&#34;, &#34;003c&#34;),  # less than
    (&#34;003e&#34;, &#34;003e&#34;),  # greater than
    (&#34;005b&#34;, &#34;005b&#34;),  # left  sq bracket
    (&#34;005d&#34;, &#34;005d&#34;),  # right sq bracket
    (&#34;007b&#34;, &#34;007b&#34;),  # left  brace
    (&#34;007d&#34;, &#34;007d&#34;),  # right brace
    (&#34;00ab&#34;, &#34;00ab&#34;),  # left  guillemet double
    (&#34;00bb&#34;, &#34;00bb&#34;),  # right guillemet double
    (&#34;2018&#34;, &#34;2019&#34;),  # quotation marks directed
    (&#34;201c&#34;, &#34;201d&#34;),  # quotation marks directed
    (&#34;2039&#34;, &#34;203a&#34;),  # guillemets single
    (&#34;2045&#34;, &#34;2046&#34;),  # sqare brackets with quill
    (&#34;204c&#34;, &#34;204d&#34;),  # bullets directed
)

BRACKET_PAIRS = (
    (&#34;0028&#34;, &#34;0029&#34;),  # parentheses
    (&#34;003c&#34;, &#34;003e&#34;),  # less than, greater than
    (&#34;005b&#34;, &#34;005d&#34;),  # sq brackets
    (&#34;007b&#34;, &#34;007d&#34;),  # braces
    (&#34;00ab&#34;, &#34;00bb&#34;),  # guillemets double
    (&#34;2018&#34;, &#34;2019&#34;),  # qutation marks directed
    (&#34;201c&#34;, &#34;201d&#34;),  # qutation marks directed
    (&#34;2045&#34;, &#34;2046&#34;),  # sqare brackets with quill
    (&#34;204c&#34;, &#34;204d&#34;),  # bullets directed
)

DIRECTION_RANGES = (
    (&#34;202a&#34;, &#34;202e&#34;),  # control writing direction
    (&#34;2066&#34;, &#34;2069&#34;),  # control writing direction
)

NEUTRAL_DIRECTION_RANGES = (
    (&#34;0009&#34;, &#34;0009&#34;),
    (&#34;0020&#34;, &#34;0020&#34;),
    (&#34;002e&#34;, &#34;002e&#34;),
    (&#34;2000&#34;, &#34;2017&#34;),
    (&#34;201e&#34;, &#34;2029&#34;),
    (&#34;202f&#34;, &#34;2038&#34;),
    (&#34;203b&#34;, &#34;2044&#34;),
    (&#34;204a&#34;, &#34;2044&#34;),
    (&#34;2056&#34;, &#34;2064&#34;),
    (&#34;201e&#34;, &#34;206f&#34;),
)

NO_SPACING_RANGES = (
    (&#34;060c&#34;, &#34;060c&#34;),
    (&#34;064b&#34;, &#34;065f&#34;),
    (&#34;fc5e&#34;, &#34;fc63&#34;),
    (&#34;fcf2&#34;, &#34;fcf4&#34;),
    (&#34;fe77&#34;, &#34;fe77&#34;),
    (&#34;fe79&#34;, &#34;fe79&#34;),
    (&#34;fe7b&#34;, &#34;fe7b&#34;),
    (&#34;fe7d&#34;, &#34;fe7d&#34;),
    (&#34;fe7f&#34;, &#34;fe7f&#34;),
)

DIACRITIC_RANGES = (
    (&#34;064b&#34;, &#34;065f&#34;),
    (&#34;064b&#34;, &#34;065f&#34;),
    (&#34;fc5e&#34;, &#34;fc63&#34;),
    (&#34;fcf2&#34;, &#34;fcf4&#34;),
    (&#34;fe77&#34;, &#34;fe77&#34;),
    (&#34;fe79&#34;, &#34;fe79&#34;),
    (&#34;fe7b&#34;, &#34;fe7b&#34;),
    (&#34;fe7d&#34;, &#34;fe7d&#34;),
    (&#34;fe7f&#34;, &#34;fe7f&#34;),
)
PSEUDO_DIACRITIC_RANGES = ((&#34;0621&#34;, &#34;0621&#34;),)

AR_DIGIT_RANGES = ((&#34;0660&#34;, &#34;0669&#34;),)
EU_DIGIT_RANGES = ((&#34;0030&#34;, &#34;0039&#34;),)

FINAL_SPACE_CODES = &#34;&#34;&#34;
    fbfd
    fc32
    fc43
    fc5d
    fc8d
    fc90
    fc94
    fe90
    fe94
    fe96
    fe9a
    fe9e
    fea2
    fea6
    feb2
    feb6
    feba
    febe
    fec2
    fec6
    feca
    fece
    fed2
    fed6
    feda
    fede
    fee2
    fee6
    feea
    fef2
&#34;&#34;&#34;.strip().split()


def uName(c):
    try:
        un = uname(c)
    except Exception:
        un = &#34;NO NAME&#34;
    return un


def getSetFromCodes(codes):
    result = set()
    for c in codes:
        uc = int(c, base=16)
        result.add(chr(uc))
    return result


def getSetFromRanges(rngs):
    result = set()
    for (b, e) in rngs:
        for uc in range(int(b, base=16), int(e, base=16) + 1):
            result.add(chr(uc))
    return result


ISOLATED = &#34;ISOLATED&#34;
INITIAL = &#34;INITIAL&#34;
FINAL = &#34;FINAL&#34;
ALEF = &#34;ALEF&#34;
ALEF_FINAL = &#34;\ufe8e&#34;
WAW = &#34;\u0648&#34;
LO = &#34;Lo&#34;
ALEFS = {&#34;\u0627&#34;, &#34;\u0622&#34;, &#34;\u0623&#34;, &#34;\u0625&#34;, &#34;\u0671&#34;}
WAWS = {&#34;\u0648&#34;, &#34;\u0624&#34;, &#34;\u0676&#34;, &#34;&#34;}
PROCLITICS = ALEFS | WAWS
HYPHENS = {&#34;\u2010&#34;, &#34;\u2011&#34;, &#34;\u2012&#34;, &#34;\u2013&#34;, &#34;\u2014&#34;, &#34;\u002d&#34;, &#34;\u00ad&#34;}

AR_DIGITS = getSetFromRanges(AR_DIGIT_RANGES)
EU_DIGITS = getSetFromRanges(EU_DIGIT_RANGES)

MEEM = &#34;MEEM&#34;
YEH = &#34;YEH&#34;


def getSetFromDef(defs):
    return {chr(int(item, base=16)) for item in defs.strip().split(&#34;\n&#34;)}


def getMapFromPairs(pairs):
    result = {}
    for (b, e) in pairs:
        bc = chr(int(b, base=16))
        ec = chr(int(e, base=16))
        result[bc] = ec
        result[ec] = bc
    return result


def normalizeC(x):
    return normalize(NFKC, x)


def normalizeD(x):
    return normalize(NFKD, x)


def isAlefFinal(x):
    return x == ALEF_FINAL


def isMeemOrYeh(x):
    nm = uname(x)
    return MEEM in nm or YEH in x


def isWaw(x):
    return x == WAW


def isArDigit(x):
    return x in AR_DIGITS


def isEuDigit(x):
    return x in EU_DIGITS


class UChar:
    def __init__(self):
        self.puas = getSetFromRanges(PUA_RANGES)
        &#34;&#34;&#34;Private use character codes as defined by the unicode standard.&#34;&#34;&#34;

        self.arabic = getSetFromRanges(ARABIC_RANGES)
        &#34;&#34;&#34;All Arabic unicode characters&#34;&#34;&#34;

        self.hebrew = getSetFromRanges(HEBREW_RANGES)
        &#34;&#34;&#34;All Hebrew unicode characters&#34;&#34;&#34;

        self.syriac = getSetFromRanges(SYRIAC_RANGES)
        &#34;&#34;&#34;All Syriac unicode characters&#34;&#34;&#34;

        self.latinPresentational = getSetFromRanges(LATIN_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Latin script&#34;&#34;&#34;

        self.greekPresentational = getSetFromRanges(GREEK_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Greek script&#34;&#34;&#34;

        self.arabicPresentational = getSetFromRanges(ARABIC_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Arabic script&#34;&#34;&#34;

        self.hebrewPresentational = getSetFromRanges(HEBREW_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Hebrew script&#34;&#34;&#34;

        self.presentationalC = self.arabicPresentational | self.hebrewPresentational
        &#34;&#34;&#34;Ligatures and special letter forms (C)

        These are the ones that are best normalized with `NFKC`: Arabic and Hebrew.
        &#34;&#34;&#34;

        self.presentationalD = self.latinPresentational | self.greekPresentational
        &#34;&#34;&#34;Ligatures and special letter forms (D)

        These are the ones that are best normalized with `NFKD`: Latin and Greek.
        &#34;&#34;&#34;

        self.presentational = self.presentationalC | self.presentationalD
        &#34;&#34;&#34;Ligatures and special letter forms various scripts&#34;&#34;&#34;

        arabicSymbols = getSetFromRanges(ARABIC_SYMBOL_RANGES)
        &#34;&#34;&#34;Arabic characters that act as symbols.

        E.g. the ornate parentheses (used for Quran quotes).
        &#34;&#34;&#34;

        symbols = getSetFromRanges(SYMBOL_RANGES)
        &#34;&#34;&#34;Characters that act as symbols in various scripts.&#34;&#34;&#34;

        self.stops = getSetFromRanges(STOP_RANGES)
        &#34;&#34;&#34;Characters that have the function of a full stop in several scripts.&#34;&#34;&#34;

        self.punct = getSetFromRanges(PUNCT_RANGES) | self.stops
        &#34;&#34;&#34;Punctuation characters in several scripts.&#34;&#34;&#34;

        self.semis = self.arabic | self.hebrew | self.syriac
        &#34;&#34;&#34;Characters in semitic scripts.

        These scripts have a right-to-left writing direction.
        &#34;&#34;&#34;

        self.rls = self.semis
        &#34;&#34;&#34;Characters that belong to the right-to-left writing direction.

        Identical with the `UChar.semis` category.
        But the Lakhnawi conversion will insert the private use characters
        to this category.
        &#34;&#34;&#34;

        brackets = getSetFromRanges(BRACKET_RANGES)
        &#34;&#34;&#34;Characters used for bracketing.

        Only when they have distinct left and right forms.
        &#34;&#34;&#34;

        self.bracketMap = getMapFromPairs(BRACKET_PAIRS)
        &#34;&#34;&#34;Mapping between left and right versions of brackets.

        Due to Unicode algorithms, left and right brackets will be displayed
        flipped when used in right-to-left writing direction.

        !!! caution &#34;hard flipping&#34;
            The Lakhnawi PDF contains brackets that have been hard flipped in order
            to display correctly in rtl direction.
            But after text extraction, we can rely on the Unicode algorithm,
            so we have to unflip these characters.
        &#34;&#34;&#34;

        nonLetter = symbols | arabicSymbols | brackets
        self.nonLetter = nonLetter
        &#34;&#34;&#34;Characters that act as symbols.

        More precisely, these are the non letters that we may encounter in
        *Arabic* script, including symbols from other scripts and brackets.
        &#34;&#34;&#34;

        self.neutrals = getSetFromRanges(NEUTRAL_DIRECTION_RANGES) | brackets | symbols
        &#34;&#34;&#34;Characters that are neutral with respect to writing direction.

        These are the characters that should not trigger a change in writing direction.
        For example, a latin full stop amidst Arabic characters should not trigger
        a character range consisting of that full stop with ltr writing direction.
        &#34;&#34;&#34;

        self.nospacings = getSetFromRanges(NO_SPACING_RANGES)
        &#34;&#34;&#34;Characters that will be ignored when figuring out horizontal white space.

        These are characters that appear to have bounding boxes in the Lakhnawi PDF
        that are not helpful in determining horizontal white space.

        When using this category in the Lakhnawi text extraction, extra characters
        will be added to this category, namely the diacritics in the private use
        area. But this is dependent on the Lakhnawi PDF and the Lakhnawi text
        extraction will take care of this.
        &#34;&#34;&#34;

        self.diacritics = getSetFromRanges(DIACRITIC_RANGES)
        &#34;&#34;&#34;Diacritical characters in various scripts.&#34;&#34;&#34;

        self.diacriticLike = getSetFromRanges(PSEUDO_DIACRITIC_RANGES) | self.diacritics
        &#34;&#34;&#34;Diacritical characters in various scripts plus the Arabic Hamza 0621.&#34;&#34;&#34;

        self.arabicLetters = self.arabic - self.diacritics
        &#34;&#34;&#34;Arabic characters with exception of the Arabic diacritics.&#34;&#34;&#34;

        self.finalSpace = getSetFromCodes(FINAL_SPACE_CODES)
        &#34;&#34;&#34;Space insertion triggered by final characters.

        Some characters imply a word-boundary after them.

        Characters marked as &#34;FINAL&#34; by Unicode are candidates, but not all of them
        have this behaviour.
        Here is the exact set of characters after which
        we need to trigger a word boundary.
        &#34;&#34;&#34;

        nonLetterRange = re.escape(&#34;&#34;.join(sorted(nonLetter)))

        wordRe = re.compile(
            fr&#34;&#34;&#34;
            (
                [^{nonLetterRange}]+
            )
            |
            (
                [{nonLetterRange}]+
            )
    &#34;&#34;&#34;,
            re.X,
        )
        self.wordRe = wordRe
        &#34;&#34;&#34;Regular expression that matches word stretches and non word stretches.

        When we split strings up into words using spaces, we are left with
        strings that contain letters and punctuation.
        This pattern can be used to separate letters from non-letters in such strings.

        Each time this pattern matches, you either get a string consisting of
        stuff that fits in a word (letters, diacritics, etc.),
        or stuff that does not fit in a word (punctuation, symbols, brackets, etc.).

        The policy is to split each string first on space, and then chunk it into
        chunks that are completely word-like or completely non-word-like.

        We then partition this list of chunks into pairs consisting of a
        word-like chunk followed by a non-word-like chunk.

        If the first chunk is non-word-like, we insert an empty chunk before it.

        If the last chunk is word-like, we insert an empty chunk after it.
        &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fusus.char.getMapFromPairs"><code class="name flex">
<span>def <span class="ident">getMapFromPairs</span></span>(<span>pairs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L245-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getMapFromPairs(pairs):
    result = {}
    for (b, e) in pairs:
        bc = chr(int(b, base=16))
        ec = chr(int(e, base=16))
        result[bc] = ec
        result[ec] = bc
    return result</code></pre>
</details>
</dd>
<dt id="fusus.char.getSetFromCodes"><code class="name flex">
<span>def <span class="ident">getSetFromCodes</span></span>(<span>codes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L206-L211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSetFromCodes(codes):
    result = set()
    for c in codes:
        uc = int(c, base=16)
        result.add(chr(uc))
    return result</code></pre>
</details>
</dd>
<dt id="fusus.char.getSetFromDef"><code class="name flex">
<span>def <span class="ident">getSetFromDef</span></span>(<span>defs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L241-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSetFromDef(defs):
    return {chr(int(item, base=16)) for item in defs.strip().split(&#34;\n&#34;)}</code></pre>
</details>
</dd>
<dt id="fusus.char.getSetFromRanges"><code class="name flex">
<span>def <span class="ident">getSetFromRanges</span></span>(<span>rngs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L214-L219" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSetFromRanges(rngs):
    result = set()
    for (b, e) in rngs:
        for uc in range(int(b, base=16), int(e, base=16) + 1):
            result.add(chr(uc))
    return result</code></pre>
</details>
</dd>
<dt id="fusus.char.isAlefFinal"><code class="name flex">
<span>def <span class="ident">isAlefFinal</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L263-L264" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isAlefFinal(x):
    return x == ALEF_FINAL</code></pre>
</details>
</dd>
<dt id="fusus.char.isArDigit"><code class="name flex">
<span>def <span class="ident">isArDigit</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L276-L277" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isArDigit(x):
    return x in AR_DIGITS</code></pre>
</details>
</dd>
<dt id="fusus.char.isEuDigit"><code class="name flex">
<span>def <span class="ident">isEuDigit</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L280-L281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isEuDigit(x):
    return x in EU_DIGITS</code></pre>
</details>
</dd>
<dt id="fusus.char.isMeemOrYeh"><code class="name flex">
<span>def <span class="ident">isMeemOrYeh</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L267-L269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isMeemOrYeh(x):
    nm = uname(x)
    return MEEM in nm or YEH in x</code></pre>
</details>
</dd>
<dt id="fusus.char.isWaw"><code class="name flex">
<span>def <span class="ident">isWaw</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L272-L273" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isWaw(x):
    return x == WAW</code></pre>
</details>
</dd>
<dt id="fusus.char.normalizeC"><code class="name flex">
<span>def <span class="ident">normalizeC</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L255-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalizeC(x):
    return normalize(NFKC, x)</code></pre>
</details>
</dd>
<dt id="fusus.char.normalizeD"><code class="name flex">
<span>def <span class="ident">normalizeD</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L259-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalizeD(x):
    return normalize(NFKD, x)</code></pre>
</details>
</dd>
<dt id="fusus.char.uName"><code class="name flex">
<span>def <span class="ident">uName</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L198-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uName(c):
    try:
        un = uname(c)
    except Exception:
        un = &#34;NO NAME&#34;
    return un</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fusus.char.UChar"><code class="flex name class">
<span>class <span class="ident">UChar</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5d918842bc76b9a44c35f79bccc1ddcfd8fb6aaf/fusus/char.py#L284-L455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class UChar:
    def __init__(self):
        self.puas = getSetFromRanges(PUA_RANGES)
        &#34;&#34;&#34;Private use character codes as defined by the unicode standard.&#34;&#34;&#34;

        self.arabic = getSetFromRanges(ARABIC_RANGES)
        &#34;&#34;&#34;All Arabic unicode characters&#34;&#34;&#34;

        self.hebrew = getSetFromRanges(HEBREW_RANGES)
        &#34;&#34;&#34;All Hebrew unicode characters&#34;&#34;&#34;

        self.syriac = getSetFromRanges(SYRIAC_RANGES)
        &#34;&#34;&#34;All Syriac unicode characters&#34;&#34;&#34;

        self.latinPresentational = getSetFromRanges(LATIN_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Latin script&#34;&#34;&#34;

        self.greekPresentational = getSetFromRanges(GREEK_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Greek script&#34;&#34;&#34;

        self.arabicPresentational = getSetFromRanges(ARABIC_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Arabic script&#34;&#34;&#34;

        self.hebrewPresentational = getSetFromRanges(HEBREW_PRESENTATIONAL_RANGES)
        &#34;&#34;&#34;Ligatures and special letter forms in the Hebrew script&#34;&#34;&#34;

        self.presentationalC = self.arabicPresentational | self.hebrewPresentational
        &#34;&#34;&#34;Ligatures and special letter forms (C)

        These are the ones that are best normalized with `NFKC`: Arabic and Hebrew.
        &#34;&#34;&#34;

        self.presentationalD = self.latinPresentational | self.greekPresentational
        &#34;&#34;&#34;Ligatures and special letter forms (D)

        These are the ones that are best normalized with `NFKD`: Latin and Greek.
        &#34;&#34;&#34;

        self.presentational = self.presentationalC | self.presentationalD
        &#34;&#34;&#34;Ligatures and special letter forms various scripts&#34;&#34;&#34;

        arabicSymbols = getSetFromRanges(ARABIC_SYMBOL_RANGES)
        &#34;&#34;&#34;Arabic characters that act as symbols.

        E.g. the ornate parentheses (used for Quran quotes).
        &#34;&#34;&#34;

        symbols = getSetFromRanges(SYMBOL_RANGES)
        &#34;&#34;&#34;Characters that act as symbols in various scripts.&#34;&#34;&#34;

        self.stops = getSetFromRanges(STOP_RANGES)
        &#34;&#34;&#34;Characters that have the function of a full stop in several scripts.&#34;&#34;&#34;

        self.punct = getSetFromRanges(PUNCT_RANGES) | self.stops
        &#34;&#34;&#34;Punctuation characters in several scripts.&#34;&#34;&#34;

        self.semis = self.arabic | self.hebrew | self.syriac
        &#34;&#34;&#34;Characters in semitic scripts.

        These scripts have a right-to-left writing direction.
        &#34;&#34;&#34;

        self.rls = self.semis
        &#34;&#34;&#34;Characters that belong to the right-to-left writing direction.

        Identical with the `UChar.semis` category.
        But the Lakhnawi conversion will insert the private use characters
        to this category.
        &#34;&#34;&#34;

        brackets = getSetFromRanges(BRACKET_RANGES)
        &#34;&#34;&#34;Characters used for bracketing.

        Only when they have distinct left and right forms.
        &#34;&#34;&#34;

        self.bracketMap = getMapFromPairs(BRACKET_PAIRS)
        &#34;&#34;&#34;Mapping between left and right versions of brackets.

        Due to Unicode algorithms, left and right brackets will be displayed
        flipped when used in right-to-left writing direction.

        !!! caution &#34;hard flipping&#34;
            The Lakhnawi PDF contains brackets that have been hard flipped in order
            to display correctly in rtl direction.
            But after text extraction, we can rely on the Unicode algorithm,
            so we have to unflip these characters.
        &#34;&#34;&#34;

        nonLetter = symbols | arabicSymbols | brackets
        self.nonLetter = nonLetter
        &#34;&#34;&#34;Characters that act as symbols.

        More precisely, these are the non letters that we may encounter in
        *Arabic* script, including symbols from other scripts and brackets.
        &#34;&#34;&#34;

        self.neutrals = getSetFromRanges(NEUTRAL_DIRECTION_RANGES) | brackets | symbols
        &#34;&#34;&#34;Characters that are neutral with respect to writing direction.

        These are the characters that should not trigger a change in writing direction.
        For example, a latin full stop amidst Arabic characters should not trigger
        a character range consisting of that full stop with ltr writing direction.
        &#34;&#34;&#34;

        self.nospacings = getSetFromRanges(NO_SPACING_RANGES)
        &#34;&#34;&#34;Characters that will be ignored when figuring out horizontal white space.

        These are characters that appear to have bounding boxes in the Lakhnawi PDF
        that are not helpful in determining horizontal white space.

        When using this category in the Lakhnawi text extraction, extra characters
        will be added to this category, namely the diacritics in the private use
        area. But this is dependent on the Lakhnawi PDF and the Lakhnawi text
        extraction will take care of this.
        &#34;&#34;&#34;

        self.diacritics = getSetFromRanges(DIACRITIC_RANGES)
        &#34;&#34;&#34;Diacritical characters in various scripts.&#34;&#34;&#34;

        self.diacriticLike = getSetFromRanges(PSEUDO_DIACRITIC_RANGES) | self.diacritics
        &#34;&#34;&#34;Diacritical characters in various scripts plus the Arabic Hamza 0621.&#34;&#34;&#34;

        self.arabicLetters = self.arabic - self.diacritics
        &#34;&#34;&#34;Arabic characters with exception of the Arabic diacritics.&#34;&#34;&#34;

        self.finalSpace = getSetFromCodes(FINAL_SPACE_CODES)
        &#34;&#34;&#34;Space insertion triggered by final characters.

        Some characters imply a word-boundary after them.

        Characters marked as &#34;FINAL&#34; by Unicode are candidates, but not all of them
        have this behaviour.
        Here is the exact set of characters after which
        we need to trigger a word boundary.
        &#34;&#34;&#34;

        nonLetterRange = re.escape(&#34;&#34;.join(sorted(nonLetter)))

        wordRe = re.compile(
            fr&#34;&#34;&#34;
            (
                [^{nonLetterRange}]+
            )
            |
            (
                [{nonLetterRange}]+
            )
    &#34;&#34;&#34;,
            re.X,
        )
        self.wordRe = wordRe
        &#34;&#34;&#34;Regular expression that matches word stretches and non word stretches.

        When we split strings up into words using spaces, we are left with
        strings that contain letters and punctuation.
        This pattern can be used to separate letters from non-letters in such strings.

        Each time this pattern matches, you either get a string consisting of
        stuff that fits in a word (letters, diacritics, etc.),
        or stuff that does not fit in a word (punctuation, symbols, brackets, etc.).

        The policy is to split each string first on space, and then chunk it into
        chunks that are completely word-like or completely non-word-like.

        We then partition this list of chunks into pairs consisting of a
        word-like chunk followed by a non-word-like chunk.

        If the first chunk is non-word-like, we insert an empty chunk before it.

        If the last chunk is word-like, we insert an empty chunk after it.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fusus.lakhnawi.Lakhnawi" href="lakhnawi.html#fusus.lakhnawi.Lakhnawi">Lakhnawi</a></li>
<li><a title="fusus.ocr.OCR" href="ocr.html#fusus.ocr.OCR">OCR</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fusus.char.UChar.arabic"><code class="name">var <span class="ident">arabic</span></code></dt>
<dd>
<div class="desc"><p>All Arabic unicode characters</p></div>
</dd>
<dt id="fusus.char.UChar.arabicLetters"><code class="name">var <span class="ident">arabicLetters</span></code></dt>
<dd>
<div class="desc"><p>Arabic characters with exception of the Arabic diacritics.</p></div>
</dd>
<dt id="fusus.char.UChar.arabicPresentational"><code class="name">var <span class="ident">arabicPresentational</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms in the Arabic script</p></div>
</dd>
<dt id="fusus.char.UChar.bracketMap"><code class="name">var <span class="ident">bracketMap</span></code></dt>
<dd>
<div class="desc"><p>Mapping between left and right versions of brackets.</p>
<p>Due to Unicode algorithms, left and right brackets will be displayed
flipped when used in right-to-left writing direction.</p>
<div class="admonition caution">
<p class="admonition-title">hard flipping</p>
<p>The Lakhnawi PDF contains brackets that have been hard flipped in order
to display correctly in rtl direction.
But after text extraction, we can rely on the Unicode algorithm,
so we have to unflip these characters.</p>
</div></div>
</dd>
<dt id="fusus.char.UChar.diacriticLike"><code class="name">var <span class="ident">diacriticLike</span></code></dt>
<dd>
<div class="desc"><p>Diacritical characters in various scripts plus the Arabic Hamza 0621.</p></div>
</dd>
<dt id="fusus.char.UChar.diacritics"><code class="name">var <span class="ident">diacritics</span></code></dt>
<dd>
<div class="desc"><p>Diacritical characters in various scripts.</p></div>
</dd>
<dt id="fusus.char.UChar.finalSpace"><code class="name">var <span class="ident">finalSpace</span></code></dt>
<dd>
<div class="desc"><p>Space insertion triggered by final characters.</p>
<p>Some characters imply a word-boundary after them.</p>
<p>Characters marked as "FINAL" by Unicode are candidates, but not all of them
have this behaviour.
Here is the exact set of characters after which
we need to trigger a word boundary.</p></div>
</dd>
<dt id="fusus.char.UChar.greekPresentational"><code class="name">var <span class="ident">greekPresentational</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms in the Greek script</p></div>
</dd>
<dt id="fusus.char.UChar.hebrew"><code class="name">var <span class="ident">hebrew</span></code></dt>
<dd>
<div class="desc"><p>All Hebrew unicode characters</p></div>
</dd>
<dt id="fusus.char.UChar.hebrewPresentational"><code class="name">var <span class="ident">hebrewPresentational</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms in the Hebrew script</p></div>
</dd>
<dt id="fusus.char.UChar.latinPresentational"><code class="name">var <span class="ident">latinPresentational</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms in the Latin script</p></div>
</dd>
<dt id="fusus.char.UChar.neutrals"><code class="name">var <span class="ident">neutrals</span></code></dt>
<dd>
<div class="desc"><p>Characters that are neutral with respect to writing direction.</p>
<p>These are the characters that should not trigger a change in writing direction.
For example, a latin full stop amidst Arabic characters should not trigger
a character range consisting of that full stop with ltr writing direction.</p></div>
</dd>
<dt id="fusus.char.UChar.nonLetter"><code class="name">var <span class="ident">nonLetter</span></code></dt>
<dd>
<div class="desc"><p>Characters that act as symbols.</p>
<p>More precisely, these are the non letters that we may encounter in
<em>Arabic</em> script, including symbols from other scripts and brackets.</p></div>
</dd>
<dt id="fusus.char.UChar.nospacings"><code class="name">var <span class="ident">nospacings</span></code></dt>
<dd>
<div class="desc"><p>Characters that will be ignored when figuring out horizontal white space.</p>
<p>These are characters that appear to have bounding boxes in the Lakhnawi PDF
that are not helpful in determining horizontal white space.</p>
<p>When using this category in the Lakhnawi text extraction, extra characters
will be added to this category, namely the diacritics in the private use
area. But this is dependent on the Lakhnawi PDF and the Lakhnawi text
extraction will take care of this.</p></div>
</dd>
<dt id="fusus.char.UChar.presentational"><code class="name">var <span class="ident">presentational</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms various scripts</p></div>
</dd>
<dt id="fusus.char.UChar.presentationalC"><code class="name">var <span class="ident">presentationalC</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms (C)</p>
<p>These are the ones that are best normalized with <code>NFKC</code>: Arabic and Hebrew.</p></div>
</dd>
<dt id="fusus.char.UChar.presentationalD"><code class="name">var <span class="ident">presentationalD</span></code></dt>
<dd>
<div class="desc"><p>Ligatures and special letter forms (D)</p>
<p>These are the ones that are best normalized with <code>NFKD</code>: Latin and Greek.</p></div>
</dd>
<dt id="fusus.char.UChar.puas"><code class="name">var <span class="ident">puas</span></code></dt>
<dd>
<div class="desc"><p>Private use character codes as defined by the unicode standard.</p></div>
</dd>
<dt id="fusus.char.UChar.punct"><code class="name">var <span class="ident">punct</span></code></dt>
<dd>
<div class="desc"><p>Punctuation characters in several scripts.</p></div>
</dd>
<dt id="fusus.char.UChar.rls"><code class="name">var <span class="ident">rls</span></code></dt>
<dd>
<div class="desc"><p>Characters that belong to the right-to-left writing direction.</p>
<p>Identical with the <code><a title="fusus.char.UChar.semis" href="#fusus.char.UChar.semis">UChar.semis</a></code> category.
But the Lakhnawi conversion will insert the private use characters
to this category.</p></div>
</dd>
<dt id="fusus.char.UChar.semis"><code class="name">var <span class="ident">semis</span></code></dt>
<dd>
<div class="desc"><p>Characters in semitic scripts.</p>
<p>These scripts have a right-to-left writing direction.</p></div>
</dd>
<dt id="fusus.char.UChar.stops"><code class="name">var <span class="ident">stops</span></code></dt>
<dd>
<div class="desc"><p>Characters that have the function of a full stop in several scripts.</p></div>
</dd>
<dt id="fusus.char.UChar.syriac"><code class="name">var <span class="ident">syriac</span></code></dt>
<dd>
<div class="desc"><p>All Syriac unicode characters</p></div>
</dd>
<dt id="fusus.char.UChar.wordRe"><code class="name">var <span class="ident">wordRe</span></code></dt>
<dd>
<div class="desc"><p>Regular expression that matches word stretches and non word stretches.</p>
<p>When we split strings up into words using spaces, we are left with
strings that contain letters and punctuation.
This pattern can be used to separate letters from non-letters in such strings.</p>
<p>Each time this pattern matches, you either get a string consisting of
stuff that fits in a word (letters, diacritics, etc.),
or stuff that does not fit in a word (punctuation, symbols, brackets, etc.).</p>
<p>The policy is to split each string first on space, and then chunk it into
chunks that are completely word-like or completely non-word-like.</p>
<p>We then partition this list of chunks into pairs consisting of a
word-like chunk followed by a non-word-like chunk.</p>
<p>If the first chunk is non-word-like, we insert an empty chunk before it.</p>
<p>If the last chunk is word-like, we insert an empty chunk after it.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/among" title="among Digital Manuscripts on GitHub"><img src="../fusus/images/fusus-small.png"></a></p>
<p><a href="../fusus/index.html">fusus home</a> -
<a href="../fusus/about/howto.html">HowTo</a>
<a href="https://github.com/among/fusus" title="GitHub repo"><img src="../fusus/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fusus" href="index.html">fusus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="fusus.char.getMapFromPairs" href="#fusus.char.getMapFromPairs">getMapFromPairs</a></code></li>
<li><code><a title="fusus.char.getSetFromCodes" href="#fusus.char.getSetFromCodes">getSetFromCodes</a></code></li>
<li><code><a title="fusus.char.getSetFromDef" href="#fusus.char.getSetFromDef">getSetFromDef</a></code></li>
<li><code><a title="fusus.char.getSetFromRanges" href="#fusus.char.getSetFromRanges">getSetFromRanges</a></code></li>
<li><code><a title="fusus.char.isAlefFinal" href="#fusus.char.isAlefFinal">isAlefFinal</a></code></li>
<li><code><a title="fusus.char.isArDigit" href="#fusus.char.isArDigit">isArDigit</a></code></li>
<li><code><a title="fusus.char.isEuDigit" href="#fusus.char.isEuDigit">isEuDigit</a></code></li>
<li><code><a title="fusus.char.isMeemOrYeh" href="#fusus.char.isMeemOrYeh">isMeemOrYeh</a></code></li>
<li><code><a title="fusus.char.isWaw" href="#fusus.char.isWaw">isWaw</a></code></li>
<li><code><a title="fusus.char.normalizeC" href="#fusus.char.normalizeC">normalizeC</a></code></li>
<li><code><a title="fusus.char.normalizeD" href="#fusus.char.normalizeD">normalizeD</a></code></li>
<li><code><a title="fusus.char.uName" href="#fusus.char.uName">uName</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fusus.char.UChar" href="#fusus.char.UChar">UChar</a></code></h4>
<ul class="">
<li><code><a title="fusus.char.UChar.arabic" href="#fusus.char.UChar.arabic">arabic</a></code></li>
<li><code><a title="fusus.char.UChar.arabicLetters" href="#fusus.char.UChar.arabicLetters">arabicLetters</a></code></li>
<li><code><a title="fusus.char.UChar.arabicPresentational" href="#fusus.char.UChar.arabicPresentational">arabicPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.bracketMap" href="#fusus.char.UChar.bracketMap">bracketMap</a></code></li>
<li><code><a title="fusus.char.UChar.diacriticLike" href="#fusus.char.UChar.diacriticLike">diacriticLike</a></code></li>
<li><code><a title="fusus.char.UChar.diacritics" href="#fusus.char.UChar.diacritics">diacritics</a></code></li>
<li><code><a title="fusus.char.UChar.finalSpace" href="#fusus.char.UChar.finalSpace">finalSpace</a></code></li>
<li><code><a title="fusus.char.UChar.greekPresentational" href="#fusus.char.UChar.greekPresentational">greekPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.hebrew" href="#fusus.char.UChar.hebrew">hebrew</a></code></li>
<li><code><a title="fusus.char.UChar.hebrewPresentational" href="#fusus.char.UChar.hebrewPresentational">hebrewPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.latinPresentational" href="#fusus.char.UChar.latinPresentational">latinPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.neutrals" href="#fusus.char.UChar.neutrals">neutrals</a></code></li>
<li><code><a title="fusus.char.UChar.nonLetter" href="#fusus.char.UChar.nonLetter">nonLetter</a></code></li>
<li><code><a title="fusus.char.UChar.nospacings" href="#fusus.char.UChar.nospacings">nospacings</a></code></li>
<li><code><a title="fusus.char.UChar.presentational" href="#fusus.char.UChar.presentational">presentational</a></code></li>
<li><code><a title="fusus.char.UChar.presentationalC" href="#fusus.char.UChar.presentationalC">presentationalC</a></code></li>
<li><code><a title="fusus.char.UChar.presentationalD" href="#fusus.char.UChar.presentationalD">presentationalD</a></code></li>
<li><code><a title="fusus.char.UChar.puas" href="#fusus.char.UChar.puas">puas</a></code></li>
<li><code><a title="fusus.char.UChar.punct" href="#fusus.char.UChar.punct">punct</a></code></li>
<li><code><a title="fusus.char.UChar.rls" href="#fusus.char.UChar.rls">rls</a></code></li>
<li><code><a title="fusus.char.UChar.semis" href="#fusus.char.UChar.semis">semis</a></code></li>
<li><code><a title="fusus.char.UChar.stops" href="#fusus.char.UChar.stops">stops</a></code></li>
<li><code><a title="fusus.char.UChar.syriac" href="#fusus.char.UChar.syriac">syriac</a></code></li>
<li><code><a title="fusus.char.UChar.wordRe" href="#fusus.char.UChar.wordRe">wordRe</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://digitalorientalist.com/about-cornelis-van-lit/">Cornelis van Lit</a>
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../fusus/images/dans.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>