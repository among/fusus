<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fusus.page API documentation</title>
<meta name="description" content="Single page processing." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fusus.page</code></h1>
</header>
<section id="section-intro">
<p>Single page processing.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L0-L1100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Single page processing.
&#34;&#34;&#34;

import os
import json
import pprint
import cv2
import numpy as np
from IPython.display import HTML, display

from tf.core.helpers import unexpanduser

from .lib import (
    DEFAULT_EXTENSION,
    parseStages,
    parseBands,
    parseMarks,
    cropBorders,
    removeBorders,
    showImage,
    writeImage,
    splitext,
    getNbLink,
)
from .clean import addBox, cluster, connected, reborder
from .lines import getInkDistribution
from .layout import (
    applyHRules,
    getBlocks,
    getStretches,
    getStripes,
    grayInterBlocks,
    overlay,
)


MARK_HEADERS = &#34;&#34;&#34;
    band
    seq
    mark
    kept
    value
    connectdegree
    connectborder
    top
    bottom
    left
    right
&#34;&#34;&#34;.strip().split()

HEADERS = tuple(
    &#34;&#34;&#34;
    page
    stripe
    block
    line
    left
    top
    right
    bottom
    confidence
    letters
    punc
&#34;&#34;&#34;.strip().split()
)
DATA_TYPES = tuple(
    &#34;&#34;&#34;
    int
    str
    int
    int
    int
    int
    int
    int
    str
    str
&#34;&#34;&#34;.strip().split()
)


class Page:
    def __init__(
        self, engine, f, minimal=False, sizeW=1, sizeH=1, batch=False, boxed=True
    ):
        &#34;&#34;&#34;All processing steps for a single page.

        Parameters
        ----------
        engine: object
            The `fusus.book.Book` object
        f: string
            The file name of the scanned page with extension, without directory
        sizeW: float, default 1
            If the image is a fraction of a page, this is the fraction of the width
        sizeH: float, default 1
            If the image is a fraction of a page, this is the fraction of the size
        minimal: boolean, optional `False`
            If true, do not read image files, just initialize data structures
        batch: boolean, optional `False`
            Whether to run in batch mode.
            In batch mode everything is geared to the final output.
            Less intermediate results are computed and stored.
            Less feedback happens on the console.
        boxed: boolean, optional `True`
            If in batch mode, produce also images that display the cleaned marks
            in boxes.
        &#34;&#34;&#34;

        self.engine = engine
        C = engine.C
        tm = engine.tm
        error = tm.error
        self.file = f
        (self.bare, self.ext) = splitext(f, withDot=False)
        self.empty = False
        self.batch = batch
        self.boxed = boxed
        self.stages = {}
        self.blocks = {}
        self.dataHeaders = dict(char=HEADERS[0:-1], word=HEADERS, line=HEADERS[0:-3])
        self.dataTypes = dict(
            char=DATA_TYPES[0:-1], word=DATA_TYPES, line=DATA_TYPES[0:-3]
        )

        if minimal:
            self.stages = {}
        else:
            inDir = C.inDir
            path = f&#34;{inDir}/{f}&#34;
            if not batch and not os.path.exists(path):
                error(f&#34;Page file not found: {path}&#34;)
                return

            orig = cv2.imread(path)
            (maxH, maxW) = orig.shape[0:2]
            self.pageH = maxH if not sizeH or sizeH == 1 else int(round(maxH / sizeH))
            self.pageW = maxW if not sizeW or sizeW == 1 else int(round(maxW / sizeW))

            self.stages = {&#34;orig&#34;: orig}

    def show(self, stage=None, band=None, mark=None, **displayParams):
        &#34;&#34;&#34;Displays processing stages of an page.

        See `fusus.parameters.STAGES`.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.
        band: string | iterable, optional `None`
            If no band is passed, no bands are indicated.
            Otherwise, the indicated bands are shown.
            If a string, it may be a comma-separated list of band names.
            Otherwise it is an iterable of band names.
        mark: string | iterable, optional `None`
            If `None` is passed, no marks are shown.
            If `&#34;&#34;` is passed, all marks on the selected bands are shown.
            Otherwise, the indicated mark boxes are shown, irrespective
            of their bands:
            If given as a string, it may be a comma-separated list of mark names.
            Otherwise it is an iterable of mark names.
            This information will be taken from the result of the `markData` stage.
        display: dict, optional
            A set of display parameters, such as `width`, `height`
            (anything accepted by `IPython.display.Image`).

        Notes
        -----
        The mark option works for the &#34;boxed&#34; stage:
        All marks not specified in the mark parameter will not be shown.

        But this option also works for all other image stages: the marks
        will be displayed on a fresh copy of that stage.

        When used for a grayscale stage, the color of the mark boxes is lost.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C
        cd = engine.cd

        stages = self.stages
        marks = engine.marks
        blocks = self.blocks

        for s in parseStages(stage, set(stages), C.stageOrder, error):
            stageData = stages[s]

            (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]
            white = C.whiteRGB if stageColor else C.whiteGRS
            if stageType == &#34;data&#34;:
                display(HTML(f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: &lt;i&gt;data:&lt;/i&gt;&lt;/div&gt;&#34;))
                self._serial(s, stageData, stageExt)
            elif stageType == &#34;link&#34;:
                path = self.stagePath(s)
                if os.path.exists(path):
                    showPath = unexpanduser(f&#34;{cd}{path}&#34;)
                    nbLink = getNbLink(showPath, stageData)
                    if nbLink is None:
                        display(HTML(f&#34;{stageData} in {showPath}&#34;))
                    else:
                        display(
                            HTML(
                                f&#34;&#34;&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: {nbLink}&#34;&#34;&#34;
                                f&#34;&#34;&#34; (local file: {showPath})&lt;/div&gt;&#34;&#34;&#34;
                            )
                        )
                else:
                    display(
                        HTML(
                            f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: &#34;
                            f&#34;&lt;i&gt;{showPath} does not exist.&lt;/i&gt;&lt;/div&gt;&#34;
                        )
                    )
            else:
                img = stageData

                headingInfo = []

                if band is not None or mark is not None:
                    img = (
                        stages[&#34;demarginedC&#34;]
                        if s == &#34;boxed&#34; and mark is not None
                        else stageData
                    ).copy()
                    for ((stripe, block), data) in blocks.items():

                        bands = data[&#34;bands&#34;]
                        doBands = (
                            () if band is None else parseBands(band, set(bands), error)
                        )
                        doBandSet = set(doBands)
                        bandRep = f&#34; with bands {&#39;, &#39;.join(doBands)}&#34; if doBands else &#34;&#34;
                        doMarks = (
                            set()
                            if mark is None
                            else parseMarks(mark, marks, set(doBands), error)
                        )
                        markRep = (
                            f&#34; with marks {&#39;, &#39;.join(sorted(doMarks))}&#34;
                            if doMarks
                            else &#34;&#34;
                        )
                        headingInfo.append(
                            f&#34;&lt;b&gt;{stripe}{block}&lt;/b&gt; {bandRep}{markRep}&#34;
                        )

                        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                        imBW = rightB - leftB
                        for band in doBands:
                            bandInfo = bands[band]
                            lines = bandInfo[&#34;lines&#34;]
                            bColor = bandInfo[&#34;color&#34;]
                            for (up, lo) in lines:
                                theUpper = topB + up
                                theLower = topB + lo
                                theLeft = leftB + 10
                                theRight = leftB + imBW - 10
                                cv2.rectangle(
                                    img,
                                    (theLeft, theUpper),
                                    (theRight, theLower),
                                    bColor,
                                    2,
                                )
                                overlay(
                                    img,
                                    leftB,
                                    theUpper,
                                    theLeft,
                                    theLower,
                                    white,
                                    bColor,
                                )
                                overlay(
                                    img,
                                    theRight,
                                    theUpper,
                                    leftB + imBW,
                                    theLower,
                                    white,
                                    bColor,
                                )
                    markData = stages.get(&#34;markData&#34;, {})
                    markLegend = {}

                    for (band, bandMarks) in markData.items():
                        if doBands and band not in doBandSet:
                            continue
                        for ((seq, mrk), hits) in bandMarks.items():
                            if mrk not in doMarks:
                                continue
                            markKey = f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;
                            markValue = (band, mrk, len(hits))
                            markLegend[markKey] = markValue
                            for (
                                kept,
                                value,
                                connDegree,
                                connectBorder,
                                stripe,
                                block,
                                left,
                                top,
                                right,
                                bottom,
                            ) in hits:
                                addBox(
                                    C,
                                    img,
                                    left,
                                    top,
                                    right,
                                    bottom,
                                    kept,
                                    band,
                                    seq,
                                    connDegree,
                                )

                    if markLegend:
                        html = []
                        html.append(
                            &#34;&lt;details open&gt;&lt;summary&gt;Mark legend&lt;/summary&gt;&lt;table&gt;&#34;
                        )
                        html.append(
                            &#34;&lt;tr&gt;&lt;th&gt;acro&lt;/th&gt;&lt;th&gt;band&lt;/th&gt;&#34;
                            &#34;&lt;th&gt;mark&lt;/th&gt;&lt;th&gt;hits&lt;/th&gt;&lt;/tr&gt;&#34;
                        )
                        for (k, (b, m, n)) in sorted(markLegend.items()):
                            html.append(
                                f&#34;&lt;tr&gt;&lt;td&gt;{k}&lt;/td&gt;&lt;td&gt;{b}&lt;/td&gt;&#34;
                                f&#34;&lt;td&gt;{m}&lt;/td&gt;&lt;td&gt;{n}&lt;/td&gt;&lt;/tr&gt;&#34;
                            )
                        html.append(&#34;&lt;/table&gt;&lt;/details&gt;&#34;)
                        display(HTML(&#34;&#34;.join(html)))
                display(HTML(f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt; {&#39;;&#39;.join(headingInfo)}&lt;/div&gt;&#34;))
                showImage(img, **displayParams)

    def stagePath(self, stage, inter=None):
        engine = self.engine
        C = engine.C

        bare = self.bare
        ext = self.ext

        (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[stage]
        dest = getattr(C, stageDir or &#34;interDir&#34;)
        inter = &#34;&#34; if inter is None else f&#34;-{inter}&#34;
        trail = stage if stagePart is None else &#34;&#34; if not stagePart else stagePart
        trail = &#34;&#34; if not trail else f&#34;-{trail}&#34;
        ext = DEFAULT_EXTENSION if stageType == &#34;image&#34; else (stageExt or ext)
        base = f&#34;{dest}/{bare}{inter}{trail}&#34;
        return f&#34;{base}.{ext}&#34;

    def read(self, stage=None):
        &#34;&#34;&#34;Reads processing data for selected stages from disk

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages will be read, if corresponding files
            are present.
            Otherwise, the indicated stages are read.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C

        stages = self.stages

        for s in parseStages(stage, set(C.stages), C.stageOrder, error):
            (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]

            if stageType == &#34;link&#34;:
                # stages of type link will be written to disk upon creation
                # and not stored and need not be retrieved
                pass
            else:
                sPath = self.stagePath(s)
                if not os.path.exists(sPath):
                    stages[s] = None
                    if s in {&#34;normalized&#34;, &#34;char&#34;, &#34;word&#34;}:
                        self.empty = True
                    continue
                if stageType == &#34;image&#34;:
                    stages[s] = cv2.imread(sPath)
                elif stageType == &#34;data&#34;:
                    with open(sPath) as f:
                        stages[s] = self._ingest(s, stageType, stageExt, f)

    def write(self, stage=None, perBlock=False):
        &#34;&#34;&#34;Writes processing stages of an page to disk.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.
        perBlock: boolean, optional `False`
            If True, the stage output will be split into blocks and written
            to disk separately. The stripe and block are appended
            to the file name.

        Returns
        -------
        None
            The stages are written into the `inter` or `clean` subdirectory,
            with the name of the stage appended to the file name.
            If `clean`, the name of the stage is omitted.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C

        stages = self.stages
        blocks = self.blocks

        for s in parseStages(stage, set(C.stages), C.stageOrder, error):
            if s not in stages:
                continue
            stageData = stages[s]
            (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]

            if stageType == &#34;image&#34;:
                if perBlock:
                    for ((stripe, block), data) in blocks.items():
                        blockSpec = f&#34;{stripe:02d}{block}&#34;
                        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                        roi = stageData[topB:bottomB, leftB:rightB]
                        thisPath = self.stagePath(stage, inter=blockSpec)
                        writeImage(roi, thisPath)
                else:
                    writeImage(stageData, self.stagePath(s))
            elif stageType == &#34;data&#34;:
                with open(self.stagePath(s), &#34;w&#34;) as f:
                    self._serial(s, stageData, stageExt, handle=f)
            elif stageType == &#34;link&#34;:
                # stages of type link will be written to disk upon creation
                # and not stored
                pass

    def _serial(self, stage, data, extension, handle=None):
        &#34;&#34;&#34;serializes data in accordance with file type.

        Parameters
        ----------
        stage: string
            The processing stage to which the data belongs
        data: any
            The data to serialize. The type of data must be compatible with
            the *extension*.
        extension: string
            The file type according to which the data must be serialized.
        handle: string, optional `None`
            If `None`, output is prepared for display in a Jupter notebook,
            else it is a file handle and the data is serialized
            in the canonical way and written to that file.

        Returns
        -------
        string
            The serialized data.
            If the extension does not match a recognized file type,
            the Python `repr` of the data is returned.

        Notes
        -----
        The following data type/extension combinations are supported:

        extension | data type
        --- | ---
        html | html text
        tsv | tuple/list of tuple/list
        json | json
        &#34;&#34;&#34;

        headers = self.dataHeaders.get(stage, None)
        header = &#34;\t&#34;.join(str(head) for head in headers) if headers else None

        if handle:
            if stage == &#34;markData&#34;:
                source = data
                data = []
                data.append(MARK_HEADERS)

                for (band, markInfo) in sorted(source.items()):
                    for ((seq, mark), entries) in sorted(markInfo.items()):
                        for entry in sorted(entries):
                            data.append((band, seq, mark, *entry))

            if header:
                handle.write(f&#34;{header}\n&#34;)
            handle.write(
                &#34;&#34;.join(&#34;\t&#34;.join(str(field) for field in row) + &#34;\n&#34; for row in data)
                if extension == &#34;tsv&#34;
                else json.dumps(data)
                if extension == &#34;json&#34;
                else data
                if extension == &#34;html&#34;
                else repr(data)
            )
        else:
            if header:
                print(header)
            if stage == &#34;markData&#34;:
                self._showCleanInfo()
            elif extension == &#34;tsv&#34;:
                for row in data:
                    print(&#34;\t&#34;.join(str(col) for col in row))
            else:
                pprint.pp(data)

    def _ingest(self, stage, tp, extension, f):
        &#34;&#34;&#34;ingests stage data in accordance with file type.

        Parameters
        ----------
        stage: string
            The processing stage to which the data belongs
        tp: string
            The type of processing stage
        extension: string
            The file type according to which the data must be serialized.
        f: string
            A file handle of the file that contains the data to be ingested.

        Returns
        -------
        data:
            The data read from disk.
            The data will be structured according to the type of stage and file.

        Notes
        -----
        The following data type/extension combinations are supported:

        extension | data type
        --- | ---
        html | html text
        tsv | tuple/list of tuple/list
        json | json
        &#34;&#34;&#34;

        if extension == &#34;tsv&#34;:
            dataTypes = self.dataTypes[stage]
            data = []
            next(f)  # header line
            for line in f:
                fields = line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;)
                fields = tuple(
                    int(x) if dataTypes[i] == &#34;int&#34; else x
                    for (i, x) in enumerate(fields)
                )
                data.append(fields)
        elif extension == &#34;json&#34;:
            data = json.load(f)
        elif extension == &#34;html&#34;:
            pass
        else:
            data = f.read()

        return data

    def doNormalize(self):
        &#34;&#34;&#34;Normalizes a page.

        Previously needed to unskew pages.
        But now we assume pages are already skewed.

        Skewing turned out to be risky: when pages are filled in unusual
        ways, we got unexpected and unwanted rotations.
        So we don&#39;t do that anymore.

        If the input page images have skew artefacts
        (black sharp triangles in the corners)
        as a result of previous skewing these will be removed.

        Normalization produces the stages:

        * *gray*: grayscale version of *orig*
        * *blurred*: inverted, black-white, blurred without skew artefacts,
          needed for histograms later on;
        * *normalized*: *gray* without skew artefacts;
        * *normalizedC*: *orig* without skew artefacts.

        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        tm = engine.tm
        info = tm.info
        C = engine.C

        batch = self.batch
        boxed = self.boxed
        stages = self.stages
        orig = stages[&#34;orig&#34;]
        gray = cv2.cvtColor(orig, cv2.COLOR_BGR2GRAY)
        stages[&#34;gray&#34;] = gray
        blurredGray = cv2.GaussianBlur(gray, (C.blurX, C.blurY), 0, 0)
        (th, blurredGray) = cv2.threshold(
            blurredGray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )
        crop = cropBorders(blurredGray)

        normalized = gray.copy()
        removeBorders(normalized, crop, C.whiteGRS)
        stages[&#34;normalized&#34;] = normalized

        if not batch or boxed:
            normalizedC = orig.copy()
            removeBorders(normalizedC, crop, C.whiteRGB)
            stages[&#34;normalizedC&#34;] = normalizedC

        blurred = cv2.GaussianBlur(normalized, (C.blurX, C.blurY), 0, 0)

        (th, blurred) = cv2.threshold(
            blurred, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )

        stages[&#34;blurred&#34;] = blurred

        # detect if the image is empty

        pts = cv2.findNonZero(blurred)
        if pts is None:
            self.empty = True
            if not batch:
                info(&#34;empty page&#34;)
            return

        self.empty = False

    def doLayout(self):
        &#34;&#34;&#34;Divide the page into stripes and the stripes into blocks.

        We detect vertical strokes as block separators and horizontal strokes
        as separators to split off top and bottom material.

        A page may or may not be partially divided into blocks.
        Where there is a vertical stroke, we define a stripe: the
        horizontal band that contains the vertical stroke tightly and extends to
        the full with of the page.

        Between the stripes corresponding to block separators we have stripes that
        are not split into blocks.

        The stripes will be numbered from top to bottom, starting at 1.

        If a stripe is not split, it defines a roi (region of interest) with
        label `(i, &#39;&#39;)`.

        If it is split, it defines blocks with labels `(i, &#39;r&#39;)` and `(i, &#39;l&#39;)`.

        Every horizontal stripe will be examined. We have to determine whether
        it is a top separator or a bottom separator.
        As a rule of thumb: horizontal stripes in the top stripe are top-separators,
        all other horizontal stripes are bottom separators.

        If there are multiple horizontal strokes in a roi, the most aggressive
        one will be taken, i.e. the one that causes the most matarial to be discarded.

        All further operations will take place on these blocks (and not on the
        page as a whole).

        The result of this stage is, besides the blocks, an image of the page
        with the blocks marked and labelled.
        &#34;&#34;&#34;

        batch = self.batch
        boxed = self.boxed
        engine = self.engine
        C = engine.C
        debug = C.debug
        tm = engine.tm
        indent = tm.indent
        info = tm.info

        pageW = self.pageW
        pageH = self.pageH

        stages = self.stages
        if not batch or boxed:
            stages[&#34;layout&#34;] = stages[&#34;normalizedC&#34;].copy()

        indent(level=3)
        stretchesH = getStretches(C, info, stages, pageW, True, batch)
        stretchesV = getStretches(C, info, stages, pageH, False, batch)
        stripes = getStripes(stages, stretchesV)
        blocks = getBlocks(C, info, stages, pageH, stripes, stretchesH, batch)
        if debug:
            showImage(stages[&#34;layout&#34;])
        self.blocks = blocks
        applyHRules(C, stages, stretchesH, stripes, blocks, batch, boxed)
        emptyBlocks = getInkDistribution(C, info, stages, pageH, blocks, batch, boxed)

        if not batch:
            grayInterBlocks(C, stages, blocks)

        for b in emptyBlocks:
            del blocks[b]

    def cleaning(self, mark=None, block=None, line=None, showKept=False):
        &#34;&#34;&#34;Remove marks from the page.

        The blocks of the page are cleaned of marks.

        New stages of the page are added:

        *   *clean* all targeted marks removed
        *   *cleanh* all targeted marks highlighted in light gray
        *   *boxed* all targeted marks boxed in light gray
        *   *markData* information about each detected mark.

        Parameters
        ----------
        mark: iterable of tuples (band, mark, [params]), optional `None`
            If `None`, all marks that are presented in the book
            directory are used.
            Otherwise, a series of marks is specified together with the band
            where this mark is searched in. Optionally you can also
            put parameters in the tuple: the accuracy, connectBorder and connectRatio.
        block: (integer, string), optional `None`
            Block identifier. If specified, only this block will be cleaned.
            If absent, cleans all blocks.
        line: integer, optional `None`
            Line number specifying the line numbers to clean.
            In all specified blocks, only the line with this number will be cleaned.
            If absent, cleans all lines in the specified blocks.
        showKept: boolean, optional `False`
            Whether to show the mark candidates that are kept.
            If False, kept marks do not show up as green boxes,
            and they do not contribute to the markData layer.
        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        tm = engine.tm
        indent = tm.indent
        info = tm.info
        error = tm.error
        warning = tm.warning
        C = engine.C

        marks = engine.marks
        batch = self.batch
        boxed = self.boxed

        markParams = C.markParams
        boxBorder = C.boxBorder

        connectBorder = C.connectBorder
        threshold = C.connectThreshold
        maxHits = C.maxHits
        color = dict(
            clean=C.cleanRGB,
            cleanh=C.cleanhRGB,
        )

        if mark is None:
            searchMarks = {subdir: markItems for (subdir, markItems) in marks.items()}
        else:
            searchMarks = {}
            for item in mark:
                (band, name) = item[0:2]
                if band not in marks or name not in marks[band]:
                    error(f&#34;No such mark: {band}/{mark}&#34;)
                    continue
                params = item[2] if len(item) &gt; 2 else {}
                for (acro, v) in params.items():
                    if acro not in markParams:
                        error(f&#34;Unknown parameter `{acro}` = `{v}`&#34;)
                configuredMark = marks[band][name]
                seq = configuredMark[&#34;seq&#34;]
                searchMarks.setdefault(band, {})[name] = dict(
                    seq=seq, gray=configuredMark[&#34;gray&#34;]
                )
                for (acro, full) in markParams.items():
                    searchMarks[band][name][full] = params.get(
                        acro, configuredMark[full]
                    )

        stages = self.stages
        demargined = stages.get(&#34;demargined&#34;, stages[&#34;gray&#34;])
        if batch:
            resultStages = (&#34;clean&#34;, &#34;boxed&#34;) if boxed else (&#34;clean&#34;,)
            if boxed:
                demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
        else:
            demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
            resultStages = (&#34;clean&#34;, &#34;cleanh&#34;, &#34;boxed&#34;)
        for stage in resultStages:
            stages[stage] = (demarginedC if stage == &#34;boxed&#34; else demargined).copy()

        tasks = [
            (
                stage,
                stages[stage],
                None if stage == &#34;boxed&#34; else color[stage],
                boxBorder if stage == &#34;boxed&#34; else -1,
            )
            for stage in resultStages
        ]

        foundHits = {}
        cleanClr = color[&#34;clean&#34;]
        blocks = self.blocks
        markResults = {}

        for ((stripe, block), data) in blocks.items():
            if block is not None and block != (stripe, block):
                continue
            (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
            thisDemargined = demargined[topB:bottomB, leftB:rightB]
            if not batch or boxed:
                thisBoxed = stages[&#34;boxed&#34;][topB:bottomB, leftB:rightB]
                theUpper = None
                theLower = None
                maxH = bottomB - topB

            for (band, markData) in searchMarks.items():
                if &#34;bands&#34; not in data:
                    # error(f&#34;No bands in {stripe}{block}&#34;)
                    continue
                bandData = data[&#34;bands&#34;][band]
                lines = bandData[&#34;lines&#34;]

                for (markName, markInfo) in markData.items():
                    foundHits.setdefault(band, {})[markName] = 0
                    seq = markInfo[&#34;seq&#34;]
                    mark = markInfo[&#34;gray&#34;]
                    connectBorder = markInfo[&#34;connectBorder&#34;]
                    accuracy = markInfo[&#34;accuracy&#34;]
                    ratio = markInfo[&#34;connectRatio&#34;]
                    (markH, markW) = mark.shape[:2]

                    nPts = 0
                    clusters = []
                    for (i, (up, lo)) in enumerate(lines):
                        if line is not None:
                            if i &lt; line - 1:
                                continue
                            elif i &gt; line - 1:
                                break
                        if line is not None and i == line - 1:
                            if theUpper is None or theUpper &gt; up:
                                theUpper = up
                            if theLower is None or theLower &lt; lo:
                                theLower = lo

                        roi = thisDemargined[up : lo + 1]
                        (roih, roiw) = roi.shape[:2]
                        if roih &lt; markH or roiw &lt; markW:
                            # search template exceeds roi image
                            continue
                        result = cv2.matchTemplate(roi, mark, cv2.TM_CCOEFF_NORMED)
                        loc = np.where(result &gt;= accuracy)
                        pts = list(zip(*loc))

                        # if too many hits: bad template or required accuracy too low

                        if len(pts) &gt; maxHits:
                            error(
                                f&#34;mark &#39;{band}:{markName}&#39;:&#34;
                                f&#34; too many hits: {len(pts)} &gt; {maxHits}&#34;
                            )
                            warning(&#34;Increase accuracy for this template&#34;)
                            continue
                        if not pts:
                            continue

                        # fuzzy matching produces several hits in the neighbourhood
                        # of marks. We have to reduce that to the best hit.
                        # We cluster the hits into clusters of neighbouring hits.

                        nPts += len(pts)
                        clusters = cluster(pts, result)

                        # We pick the representant hit from each cluster and
                        # check the ink connectedness
                        # Explanation in `fusus.clean`

                        for (pt, value) in clusters:
                            connDegree = connected(
                                markH, markW, connectBorder, threshold, roi, pt
                            )
                            pt = (pt[0] + up + topB, pt[1] + leftB)
                            (left, top, right, bottom) = (
                                pt[1],
                                pt[0],
                                pt[1] + markW,
                                pt[0] + markH,
                            )
                            if connDegree &gt; ratio:
                                if showKept and (not batch or boxed):
                                    im = stages[&#34;boxed&#34;]
                                    addBox(
                                        C,
                                        im,
                                        left,
                                        top,
                                        right,
                                        bottom,
                                        True,
                                        band,
                                        seq,
                                        connDegree,
                                    )
                                    markResults.setdefault(band, {}).setdefault(
                                        (seq, markName), []
                                    ).append(
                                        (
                                            True,
                                            value,
                                            connDegree,
                                            connectBorder,
                                            stripe,
                                            block,
                                            left,
                                            top,
                                            right,
                                            bottom,
                                        )
                                    )
                            else:
                                if batch and not boxed:
                                    cv2.rectangle(
                                        stages[&#34;clean&#34;],
                                        (left, top),
                                        (right, bottom),
                                        cleanClr,
                                        -1,
                                    )
                                else:
                                    for (stage, im, clr, brd) in tasks:
                                        isBoxed = stage == &#34;boxed&#34;
                                        if isBoxed:
                                            addBox(
                                                C,
                                                im,
                                                left,
                                                top,
                                                right,
                                                bottom,
                                                False,
                                                band,
                                                seq,
                                                connDegree,
                                            )
                                            markResults.setdefault(band, {}).setdefault(
                                                (seq, markName), []
                                            ).append(
                                                (
                                                    False,
                                                    value,
                                                    connDegree,
                                                    connectBorder,
                                                    stripe,
                                                    block,
                                                    left,
                                                    top,
                                                    right,
                                                    bottom,
                                                )
                                            )
                                        else:
                                            cv2.rectangle(
                                                im,
                                                (left, top),
                                                (right, bottom),
                                                clr,
                                                -1,
                                            )

            if not batch or boxed:
                if line is not None and theUpper is not None and theLower is not None:
                    grace = 20
                    thisTop = max(0, theUpper - grace)
                    thisBottom = min(maxH, theLower + grace)
                    info(
                        f&#34;block {stripe}{block} line {line} BEFORE/AFTER cleaning\n&#34;,
                        tm=False,
                    )
                    roi = thisDemargined[thisTop:thisBottom]
                    showImage(roi)
                    roiBoxed = thisBoxed[thisTop:thisBottom]
                    showImage(roiBoxed)
        stages[&#34;markData&#34;] = markResults
        if line is None:
            for (band, bandMarks) in sorted(markResults.items()):
                for ((seq, mark), entries) in sorted(bandMarks.items()):
                    indent(level=2)
                    kept = sum(1 for e in entries if e[0])
                    wiped = len(entries) - kept
                    warning(
                        f&#34;{seq:&gt;2} - {band:&lt;10}: {mark:&lt;20}&#34;
                        f&#34; wiped {wiped:&gt;4} x, kept {kept:&gt;4} x&#34;,
                        tm=False,
                    )
        else:
            self.show(stage=&#34;markData&#34;)
        indent(level=1)
        clean = stages[&#34;clean&#34;]
        (th, threshed) = cv2.threshold(
            clean, 127, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )
        pts = cv2.findNonZero(threshed)
        if pts is None:
            self.empty = True
            if not batch:
                info(&#34;empty page&#34;)
            return

        info(&#34;cleaning done&#34;)

    def _showCleanInfo(self):
        &#34;&#34;&#34;Pretty-prints the result of the cleaning stage.&#34;&#34;&#34;

        engine = self.engine
        C = engine.C
        grey = C.greyGRS
        tm = engine.tm
        info = tm.info
        indent = tm.indent
        stages = self.stages
        markData = stages.get(&#34;markData&#34;, {})
        total = 0

        total = 0
        for (band, markInfo) in sorted(markData.items()):
            indent(level=0)
            info(band, tm=False)
            for ((seq, mark), entries) in sorted(markInfo.items()):
                indent(level=1)
                wiped = sum(1 for e in entries if not e[0])
                total += wiped
                notWiped = len(entries) - wiped
                markImage = reborder(engine.marks[band][mark][&#34;gray&#34;], 2, grey)
                showImage(markImage)
                info(
                    f&#34;{seq:&gt;2}: {mark:&lt;20} wiped {wiped:&gt;4} x, kept {notWiped:&gt;4} x&#34;,
                    tm=False,
                )
                info(
                    f&#34;{&#39;&#39;:24} kept  {notWiped:&gt;4} x&#34;,
                    tm=False,
                )
                for (
                    k,
                    value,
                    conn,
                    border,
                    stripe,
                    block,
                    top,
                    bottom,
                    left,
                    right,
                ) in sorted(entries):
                    indent(level=2)
                    wRep = &#34;kept&#34; if k else &#34;wiped&#34;
                    block = f&#34;{stripe}{block}&#34;
                    info(
                        f&#34;{wRep:&lt;5} [{block:&gt;3}]&#34;
                        f&#34; tblr={top:&gt;4} {bottom:&gt;4} {left:&gt;4} {right:&gt;4},&#34;
                        f&#34; value={value:5.2f} conn={conn:5.3f} border={border:&gt;2}&#34;,
                        tm=False,
                    )

    def ocring(self):
        &#34;&#34;&#34;Calls the OCR engine for a page.&#34;&#34;&#34;

        engine = self.engine
        OCR = engine.OCR

        OCR.read(self)
        OCR.proofing(self)

    def proofing(self):
        &#34;&#34;&#34;Produces proofing images&#34;&#34;&#34;

        engine = self.engine
        OCR = engine.OCR
        OCR.proofing(self)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fusus.page.Page"><code class="flex name class">
<span>class <span class="ident">Page</span></span>
<span>(</span><span>engine, f, minimal=False, sizeW=1, sizeH=1, batch=False, boxed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>All processing steps for a single page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>engine</code></strong> :&ensp;<code>object</code></dt>
<dd>The <code><a title="fusus.book.Book" href="book.html#fusus.book.Book">Book</a></code> object</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>string</code></dt>
<dd>The file name of the scanned page with extension, without directory</dd>
<dt><strong><code>sizeW</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>If the image is a fraction of a page, this is the fraction of the width</dd>
<dt><strong><code>sizeH</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>If the image is a fraction of a page, this is the fraction of the size</dd>
<dt><strong><code>minimal</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If true, do not read image files, just initialize data structures</dd>
<dt><strong><code>batch</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to run in batch mode.
In batch mode everything is geared to the final output.
Less intermediate results are computed and stored.
Less feedback happens on the console.</dd>
<dt><strong><code>boxed</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If in batch mode, produce also images that display the cleaned marks
in boxes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L82-L1101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Page:
    def __init__(
        self, engine, f, minimal=False, sizeW=1, sizeH=1, batch=False, boxed=True
    ):
        &#34;&#34;&#34;All processing steps for a single page.

        Parameters
        ----------
        engine: object
            The `fusus.book.Book` object
        f: string
            The file name of the scanned page with extension, without directory
        sizeW: float, default 1
            If the image is a fraction of a page, this is the fraction of the width
        sizeH: float, default 1
            If the image is a fraction of a page, this is the fraction of the size
        minimal: boolean, optional `False`
            If true, do not read image files, just initialize data structures
        batch: boolean, optional `False`
            Whether to run in batch mode.
            In batch mode everything is geared to the final output.
            Less intermediate results are computed and stored.
            Less feedback happens on the console.
        boxed: boolean, optional `True`
            If in batch mode, produce also images that display the cleaned marks
            in boxes.
        &#34;&#34;&#34;

        self.engine = engine
        C = engine.C
        tm = engine.tm
        error = tm.error
        self.file = f
        (self.bare, self.ext) = splitext(f, withDot=False)
        self.empty = False
        self.batch = batch
        self.boxed = boxed
        self.stages = {}
        self.blocks = {}
        self.dataHeaders = dict(char=HEADERS[0:-1], word=HEADERS, line=HEADERS[0:-3])
        self.dataTypes = dict(
            char=DATA_TYPES[0:-1], word=DATA_TYPES, line=DATA_TYPES[0:-3]
        )

        if minimal:
            self.stages = {}
        else:
            inDir = C.inDir
            path = f&#34;{inDir}/{f}&#34;
            if not batch and not os.path.exists(path):
                error(f&#34;Page file not found: {path}&#34;)
                return

            orig = cv2.imread(path)
            (maxH, maxW) = orig.shape[0:2]
            self.pageH = maxH if not sizeH or sizeH == 1 else int(round(maxH / sizeH))
            self.pageW = maxW if not sizeW or sizeW == 1 else int(round(maxW / sizeW))

            self.stages = {&#34;orig&#34;: orig}

    def show(self, stage=None, band=None, mark=None, **displayParams):
        &#34;&#34;&#34;Displays processing stages of an page.

        See `fusus.parameters.STAGES`.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.
        band: string | iterable, optional `None`
            If no band is passed, no bands are indicated.
            Otherwise, the indicated bands are shown.
            If a string, it may be a comma-separated list of band names.
            Otherwise it is an iterable of band names.
        mark: string | iterable, optional `None`
            If `None` is passed, no marks are shown.
            If `&#34;&#34;` is passed, all marks on the selected bands are shown.
            Otherwise, the indicated mark boxes are shown, irrespective
            of their bands:
            If given as a string, it may be a comma-separated list of mark names.
            Otherwise it is an iterable of mark names.
            This information will be taken from the result of the `markData` stage.
        display: dict, optional
            A set of display parameters, such as `width`, `height`
            (anything accepted by `IPython.display.Image`).

        Notes
        -----
        The mark option works for the &#34;boxed&#34; stage:
        All marks not specified in the mark parameter will not be shown.

        But this option also works for all other image stages: the marks
        will be displayed on a fresh copy of that stage.

        When used for a grayscale stage, the color of the mark boxes is lost.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C
        cd = engine.cd

        stages = self.stages
        marks = engine.marks
        blocks = self.blocks

        for s in parseStages(stage, set(stages), C.stageOrder, error):
            stageData = stages[s]

            (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]
            white = C.whiteRGB if stageColor else C.whiteGRS
            if stageType == &#34;data&#34;:
                display(HTML(f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: &lt;i&gt;data:&lt;/i&gt;&lt;/div&gt;&#34;))
                self._serial(s, stageData, stageExt)
            elif stageType == &#34;link&#34;:
                path = self.stagePath(s)
                if os.path.exists(path):
                    showPath = unexpanduser(f&#34;{cd}{path}&#34;)
                    nbLink = getNbLink(showPath, stageData)
                    if nbLink is None:
                        display(HTML(f&#34;{stageData} in {showPath}&#34;))
                    else:
                        display(
                            HTML(
                                f&#34;&#34;&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: {nbLink}&#34;&#34;&#34;
                                f&#34;&#34;&#34; (local file: {showPath})&lt;/div&gt;&#34;&#34;&#34;
                            )
                        )
                else:
                    display(
                        HTML(
                            f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: &#34;
                            f&#34;&lt;i&gt;{showPath} does not exist.&lt;/i&gt;&lt;/div&gt;&#34;
                        )
                    )
            else:
                img = stageData

                headingInfo = []

                if band is not None or mark is not None:
                    img = (
                        stages[&#34;demarginedC&#34;]
                        if s == &#34;boxed&#34; and mark is not None
                        else stageData
                    ).copy()
                    for ((stripe, block), data) in blocks.items():

                        bands = data[&#34;bands&#34;]
                        doBands = (
                            () if band is None else parseBands(band, set(bands), error)
                        )
                        doBandSet = set(doBands)
                        bandRep = f&#34; with bands {&#39;, &#39;.join(doBands)}&#34; if doBands else &#34;&#34;
                        doMarks = (
                            set()
                            if mark is None
                            else parseMarks(mark, marks, set(doBands), error)
                        )
                        markRep = (
                            f&#34; with marks {&#39;, &#39;.join(sorted(doMarks))}&#34;
                            if doMarks
                            else &#34;&#34;
                        )
                        headingInfo.append(
                            f&#34;&lt;b&gt;{stripe}{block}&lt;/b&gt; {bandRep}{markRep}&#34;
                        )

                        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                        imBW = rightB - leftB
                        for band in doBands:
                            bandInfo = bands[band]
                            lines = bandInfo[&#34;lines&#34;]
                            bColor = bandInfo[&#34;color&#34;]
                            for (up, lo) in lines:
                                theUpper = topB + up
                                theLower = topB + lo
                                theLeft = leftB + 10
                                theRight = leftB + imBW - 10
                                cv2.rectangle(
                                    img,
                                    (theLeft, theUpper),
                                    (theRight, theLower),
                                    bColor,
                                    2,
                                )
                                overlay(
                                    img,
                                    leftB,
                                    theUpper,
                                    theLeft,
                                    theLower,
                                    white,
                                    bColor,
                                )
                                overlay(
                                    img,
                                    theRight,
                                    theUpper,
                                    leftB + imBW,
                                    theLower,
                                    white,
                                    bColor,
                                )
                    markData = stages.get(&#34;markData&#34;, {})
                    markLegend = {}

                    for (band, bandMarks) in markData.items():
                        if doBands and band not in doBandSet:
                            continue
                        for ((seq, mrk), hits) in bandMarks.items():
                            if mrk not in doMarks:
                                continue
                            markKey = f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;
                            markValue = (band, mrk, len(hits))
                            markLegend[markKey] = markValue
                            for (
                                kept,
                                value,
                                connDegree,
                                connectBorder,
                                stripe,
                                block,
                                left,
                                top,
                                right,
                                bottom,
                            ) in hits:
                                addBox(
                                    C,
                                    img,
                                    left,
                                    top,
                                    right,
                                    bottom,
                                    kept,
                                    band,
                                    seq,
                                    connDegree,
                                )

                    if markLegend:
                        html = []
                        html.append(
                            &#34;&lt;details open&gt;&lt;summary&gt;Mark legend&lt;/summary&gt;&lt;table&gt;&#34;
                        )
                        html.append(
                            &#34;&lt;tr&gt;&lt;th&gt;acro&lt;/th&gt;&lt;th&gt;band&lt;/th&gt;&#34;
                            &#34;&lt;th&gt;mark&lt;/th&gt;&lt;th&gt;hits&lt;/th&gt;&lt;/tr&gt;&#34;
                        )
                        for (k, (b, m, n)) in sorted(markLegend.items()):
                            html.append(
                                f&#34;&lt;tr&gt;&lt;td&gt;{k}&lt;/td&gt;&lt;td&gt;{b}&lt;/td&gt;&#34;
                                f&#34;&lt;td&gt;{m}&lt;/td&gt;&lt;td&gt;{n}&lt;/td&gt;&lt;/tr&gt;&#34;
                            )
                        html.append(&#34;&lt;/table&gt;&lt;/details&gt;&#34;)
                        display(HTML(&#34;&#34;.join(html)))
                display(HTML(f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt; {&#39;;&#39;.join(headingInfo)}&lt;/div&gt;&#34;))
                showImage(img, **displayParams)

    def stagePath(self, stage, inter=None):
        engine = self.engine
        C = engine.C

        bare = self.bare
        ext = self.ext

        (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[stage]
        dest = getattr(C, stageDir or &#34;interDir&#34;)
        inter = &#34;&#34; if inter is None else f&#34;-{inter}&#34;
        trail = stage if stagePart is None else &#34;&#34; if not stagePart else stagePart
        trail = &#34;&#34; if not trail else f&#34;-{trail}&#34;
        ext = DEFAULT_EXTENSION if stageType == &#34;image&#34; else (stageExt or ext)
        base = f&#34;{dest}/{bare}{inter}{trail}&#34;
        return f&#34;{base}.{ext}&#34;

    def read(self, stage=None):
        &#34;&#34;&#34;Reads processing data for selected stages from disk

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages will be read, if corresponding files
            are present.
            Otherwise, the indicated stages are read.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C

        stages = self.stages

        for s in parseStages(stage, set(C.stages), C.stageOrder, error):
            (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]

            if stageType == &#34;link&#34;:
                # stages of type link will be written to disk upon creation
                # and not stored and need not be retrieved
                pass
            else:
                sPath = self.stagePath(s)
                if not os.path.exists(sPath):
                    stages[s] = None
                    if s in {&#34;normalized&#34;, &#34;char&#34;, &#34;word&#34;}:
                        self.empty = True
                    continue
                if stageType == &#34;image&#34;:
                    stages[s] = cv2.imread(sPath)
                elif stageType == &#34;data&#34;:
                    with open(sPath) as f:
                        stages[s] = self._ingest(s, stageType, stageExt, f)

    def write(self, stage=None, perBlock=False):
        &#34;&#34;&#34;Writes processing stages of an page to disk.

        Parameters
        ----------
        stage: string | iterable, optional `None`
            If no stage is passed, all stages are shown as thumbnails.
            Otherwise, the indicated stages are shown.
            If a string, it may be a comma-separated list of stage names.
            Otherwise it is an iterable of stage names.
        perBlock: boolean, optional `False`
            If True, the stage output will be split into blocks and written
            to disk separately. The stripe and block are appended
            to the file name.

        Returns
        -------
        None
            The stages are written into the `inter` or `clean` subdirectory,
            with the name of the stage appended to the file name.
            If `clean`, the name of the stage is omitted.
        &#34;&#34;&#34;

        engine = self.engine
        tm = engine.tm
        error = tm.error
        C = engine.C

        stages = self.stages
        blocks = self.blocks

        for s in parseStages(stage, set(C.stages), C.stageOrder, error):
            if s not in stages:
                continue
            stageData = stages[s]
            (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]

            if stageType == &#34;image&#34;:
                if perBlock:
                    for ((stripe, block), data) in blocks.items():
                        blockSpec = f&#34;{stripe:02d}{block}&#34;
                        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                        roi = stageData[topB:bottomB, leftB:rightB]
                        thisPath = self.stagePath(stage, inter=blockSpec)
                        writeImage(roi, thisPath)
                else:
                    writeImage(stageData, self.stagePath(s))
            elif stageType == &#34;data&#34;:
                with open(self.stagePath(s), &#34;w&#34;) as f:
                    self._serial(s, stageData, stageExt, handle=f)
            elif stageType == &#34;link&#34;:
                # stages of type link will be written to disk upon creation
                # and not stored
                pass

    def _serial(self, stage, data, extension, handle=None):
        &#34;&#34;&#34;serializes data in accordance with file type.

        Parameters
        ----------
        stage: string
            The processing stage to which the data belongs
        data: any
            The data to serialize. The type of data must be compatible with
            the *extension*.
        extension: string
            The file type according to which the data must be serialized.
        handle: string, optional `None`
            If `None`, output is prepared for display in a Jupter notebook,
            else it is a file handle and the data is serialized
            in the canonical way and written to that file.

        Returns
        -------
        string
            The serialized data.
            If the extension does not match a recognized file type,
            the Python `repr` of the data is returned.

        Notes
        -----
        The following data type/extension combinations are supported:

        extension | data type
        --- | ---
        html | html text
        tsv | tuple/list of tuple/list
        json | json
        &#34;&#34;&#34;

        headers = self.dataHeaders.get(stage, None)
        header = &#34;\t&#34;.join(str(head) for head in headers) if headers else None

        if handle:
            if stage == &#34;markData&#34;:
                source = data
                data = []
                data.append(MARK_HEADERS)

                for (band, markInfo) in sorted(source.items()):
                    for ((seq, mark), entries) in sorted(markInfo.items()):
                        for entry in sorted(entries):
                            data.append((band, seq, mark, *entry))

            if header:
                handle.write(f&#34;{header}\n&#34;)
            handle.write(
                &#34;&#34;.join(&#34;\t&#34;.join(str(field) for field in row) + &#34;\n&#34; for row in data)
                if extension == &#34;tsv&#34;
                else json.dumps(data)
                if extension == &#34;json&#34;
                else data
                if extension == &#34;html&#34;
                else repr(data)
            )
        else:
            if header:
                print(header)
            if stage == &#34;markData&#34;:
                self._showCleanInfo()
            elif extension == &#34;tsv&#34;:
                for row in data:
                    print(&#34;\t&#34;.join(str(col) for col in row))
            else:
                pprint.pp(data)

    def _ingest(self, stage, tp, extension, f):
        &#34;&#34;&#34;ingests stage data in accordance with file type.

        Parameters
        ----------
        stage: string
            The processing stage to which the data belongs
        tp: string
            The type of processing stage
        extension: string
            The file type according to which the data must be serialized.
        f: string
            A file handle of the file that contains the data to be ingested.

        Returns
        -------
        data:
            The data read from disk.
            The data will be structured according to the type of stage and file.

        Notes
        -----
        The following data type/extension combinations are supported:

        extension | data type
        --- | ---
        html | html text
        tsv | tuple/list of tuple/list
        json | json
        &#34;&#34;&#34;

        if extension == &#34;tsv&#34;:
            dataTypes = self.dataTypes[stage]
            data = []
            next(f)  # header line
            for line in f:
                fields = line.rstrip(&#34;\n&#34;).split(&#34;\t&#34;)
                fields = tuple(
                    int(x) if dataTypes[i] == &#34;int&#34; else x
                    for (i, x) in enumerate(fields)
                )
                data.append(fields)
        elif extension == &#34;json&#34;:
            data = json.load(f)
        elif extension == &#34;html&#34;:
            pass
        else:
            data = f.read()

        return data

    def doNormalize(self):
        &#34;&#34;&#34;Normalizes a page.

        Previously needed to unskew pages.
        But now we assume pages are already skewed.

        Skewing turned out to be risky: when pages are filled in unusual
        ways, we got unexpected and unwanted rotations.
        So we don&#39;t do that anymore.

        If the input page images have skew artefacts
        (black sharp triangles in the corners)
        as a result of previous skewing these will be removed.

        Normalization produces the stages:

        * *gray*: grayscale version of *orig*
        * *blurred*: inverted, black-white, blurred without skew artefacts,
          needed for histograms later on;
        * *normalized*: *gray* without skew artefacts;
        * *normalizedC*: *orig* without skew artefacts.

        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        tm = engine.tm
        info = tm.info
        C = engine.C

        batch = self.batch
        boxed = self.boxed
        stages = self.stages
        orig = stages[&#34;orig&#34;]
        gray = cv2.cvtColor(orig, cv2.COLOR_BGR2GRAY)
        stages[&#34;gray&#34;] = gray
        blurredGray = cv2.GaussianBlur(gray, (C.blurX, C.blurY), 0, 0)
        (th, blurredGray) = cv2.threshold(
            blurredGray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )
        crop = cropBorders(blurredGray)

        normalized = gray.copy()
        removeBorders(normalized, crop, C.whiteGRS)
        stages[&#34;normalized&#34;] = normalized

        if not batch or boxed:
            normalizedC = orig.copy()
            removeBorders(normalizedC, crop, C.whiteRGB)
            stages[&#34;normalizedC&#34;] = normalizedC

        blurred = cv2.GaussianBlur(normalized, (C.blurX, C.blurY), 0, 0)

        (th, blurred) = cv2.threshold(
            blurred, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )

        stages[&#34;blurred&#34;] = blurred

        # detect if the image is empty

        pts = cv2.findNonZero(blurred)
        if pts is None:
            self.empty = True
            if not batch:
                info(&#34;empty page&#34;)
            return

        self.empty = False

    def doLayout(self):
        &#34;&#34;&#34;Divide the page into stripes and the stripes into blocks.

        We detect vertical strokes as block separators and horizontal strokes
        as separators to split off top and bottom material.

        A page may or may not be partially divided into blocks.
        Where there is a vertical stroke, we define a stripe: the
        horizontal band that contains the vertical stroke tightly and extends to
        the full with of the page.

        Between the stripes corresponding to block separators we have stripes that
        are not split into blocks.

        The stripes will be numbered from top to bottom, starting at 1.

        If a stripe is not split, it defines a roi (region of interest) with
        label `(i, &#39;&#39;)`.

        If it is split, it defines blocks with labels `(i, &#39;r&#39;)` and `(i, &#39;l&#39;)`.

        Every horizontal stripe will be examined. We have to determine whether
        it is a top separator or a bottom separator.
        As a rule of thumb: horizontal stripes in the top stripe are top-separators,
        all other horizontal stripes are bottom separators.

        If there are multiple horizontal strokes in a roi, the most aggressive
        one will be taken, i.e. the one that causes the most matarial to be discarded.

        All further operations will take place on these blocks (and not on the
        page as a whole).

        The result of this stage is, besides the blocks, an image of the page
        with the blocks marked and labelled.
        &#34;&#34;&#34;

        batch = self.batch
        boxed = self.boxed
        engine = self.engine
        C = engine.C
        debug = C.debug
        tm = engine.tm
        indent = tm.indent
        info = tm.info

        pageW = self.pageW
        pageH = self.pageH

        stages = self.stages
        if not batch or boxed:
            stages[&#34;layout&#34;] = stages[&#34;normalizedC&#34;].copy()

        indent(level=3)
        stretchesH = getStretches(C, info, stages, pageW, True, batch)
        stretchesV = getStretches(C, info, stages, pageH, False, batch)
        stripes = getStripes(stages, stretchesV)
        blocks = getBlocks(C, info, stages, pageH, stripes, stretchesH, batch)
        if debug:
            showImage(stages[&#34;layout&#34;])
        self.blocks = blocks
        applyHRules(C, stages, stretchesH, stripes, blocks, batch, boxed)
        emptyBlocks = getInkDistribution(C, info, stages, pageH, blocks, batch, boxed)

        if not batch:
            grayInterBlocks(C, stages, blocks)

        for b in emptyBlocks:
            del blocks[b]

    def cleaning(self, mark=None, block=None, line=None, showKept=False):
        &#34;&#34;&#34;Remove marks from the page.

        The blocks of the page are cleaned of marks.

        New stages of the page are added:

        *   *clean* all targeted marks removed
        *   *cleanh* all targeted marks highlighted in light gray
        *   *boxed* all targeted marks boxed in light gray
        *   *markData* information about each detected mark.

        Parameters
        ----------
        mark: iterable of tuples (band, mark, [params]), optional `None`
            If `None`, all marks that are presented in the book
            directory are used.
            Otherwise, a series of marks is specified together with the band
            where this mark is searched in. Optionally you can also
            put parameters in the tuple: the accuracy, connectBorder and connectRatio.
        block: (integer, string), optional `None`
            Block identifier. If specified, only this block will be cleaned.
            If absent, cleans all blocks.
        line: integer, optional `None`
            Line number specifying the line numbers to clean.
            In all specified blocks, only the line with this number will be cleaned.
            If absent, cleans all lines in the specified blocks.
        showKept: boolean, optional `False`
            Whether to show the mark candidates that are kept.
            If False, kept marks do not show up as green boxes,
            and they do not contribute to the markData layer.
        &#34;&#34;&#34;

        if self.empty:
            return

        engine = self.engine
        tm = engine.tm
        indent = tm.indent
        info = tm.info
        error = tm.error
        warning = tm.warning
        C = engine.C

        marks = engine.marks
        batch = self.batch
        boxed = self.boxed

        markParams = C.markParams
        boxBorder = C.boxBorder

        connectBorder = C.connectBorder
        threshold = C.connectThreshold
        maxHits = C.maxHits
        color = dict(
            clean=C.cleanRGB,
            cleanh=C.cleanhRGB,
        )

        if mark is None:
            searchMarks = {subdir: markItems for (subdir, markItems) in marks.items()}
        else:
            searchMarks = {}
            for item in mark:
                (band, name) = item[0:2]
                if band not in marks or name not in marks[band]:
                    error(f&#34;No such mark: {band}/{mark}&#34;)
                    continue
                params = item[2] if len(item) &gt; 2 else {}
                for (acro, v) in params.items():
                    if acro not in markParams:
                        error(f&#34;Unknown parameter `{acro}` = `{v}`&#34;)
                configuredMark = marks[band][name]
                seq = configuredMark[&#34;seq&#34;]
                searchMarks.setdefault(band, {})[name] = dict(
                    seq=seq, gray=configuredMark[&#34;gray&#34;]
                )
                for (acro, full) in markParams.items():
                    searchMarks[band][name][full] = params.get(
                        acro, configuredMark[full]
                    )

        stages = self.stages
        demargined = stages.get(&#34;demargined&#34;, stages[&#34;gray&#34;])
        if batch:
            resultStages = (&#34;clean&#34;, &#34;boxed&#34;) if boxed else (&#34;clean&#34;,)
            if boxed:
                demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
        else:
            demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
            resultStages = (&#34;clean&#34;, &#34;cleanh&#34;, &#34;boxed&#34;)
        for stage in resultStages:
            stages[stage] = (demarginedC if stage == &#34;boxed&#34; else demargined).copy()

        tasks = [
            (
                stage,
                stages[stage],
                None if stage == &#34;boxed&#34; else color[stage],
                boxBorder if stage == &#34;boxed&#34; else -1,
            )
            for stage in resultStages
        ]

        foundHits = {}
        cleanClr = color[&#34;clean&#34;]
        blocks = self.blocks
        markResults = {}

        for ((stripe, block), data) in blocks.items():
            if block is not None and block != (stripe, block):
                continue
            (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
            thisDemargined = demargined[topB:bottomB, leftB:rightB]
            if not batch or boxed:
                thisBoxed = stages[&#34;boxed&#34;][topB:bottomB, leftB:rightB]
                theUpper = None
                theLower = None
                maxH = bottomB - topB

            for (band, markData) in searchMarks.items():
                if &#34;bands&#34; not in data:
                    # error(f&#34;No bands in {stripe}{block}&#34;)
                    continue
                bandData = data[&#34;bands&#34;][band]
                lines = bandData[&#34;lines&#34;]

                for (markName, markInfo) in markData.items():
                    foundHits.setdefault(band, {})[markName] = 0
                    seq = markInfo[&#34;seq&#34;]
                    mark = markInfo[&#34;gray&#34;]
                    connectBorder = markInfo[&#34;connectBorder&#34;]
                    accuracy = markInfo[&#34;accuracy&#34;]
                    ratio = markInfo[&#34;connectRatio&#34;]
                    (markH, markW) = mark.shape[:2]

                    nPts = 0
                    clusters = []
                    for (i, (up, lo)) in enumerate(lines):
                        if line is not None:
                            if i &lt; line - 1:
                                continue
                            elif i &gt; line - 1:
                                break
                        if line is not None and i == line - 1:
                            if theUpper is None or theUpper &gt; up:
                                theUpper = up
                            if theLower is None or theLower &lt; lo:
                                theLower = lo

                        roi = thisDemargined[up : lo + 1]
                        (roih, roiw) = roi.shape[:2]
                        if roih &lt; markH or roiw &lt; markW:
                            # search template exceeds roi image
                            continue
                        result = cv2.matchTemplate(roi, mark, cv2.TM_CCOEFF_NORMED)
                        loc = np.where(result &gt;= accuracy)
                        pts = list(zip(*loc))

                        # if too many hits: bad template or required accuracy too low

                        if len(pts) &gt; maxHits:
                            error(
                                f&#34;mark &#39;{band}:{markName}&#39;:&#34;
                                f&#34; too many hits: {len(pts)} &gt; {maxHits}&#34;
                            )
                            warning(&#34;Increase accuracy for this template&#34;)
                            continue
                        if not pts:
                            continue

                        # fuzzy matching produces several hits in the neighbourhood
                        # of marks. We have to reduce that to the best hit.
                        # We cluster the hits into clusters of neighbouring hits.

                        nPts += len(pts)
                        clusters = cluster(pts, result)

                        # We pick the representant hit from each cluster and
                        # check the ink connectedness
                        # Explanation in `fusus.clean`

                        for (pt, value) in clusters:
                            connDegree = connected(
                                markH, markW, connectBorder, threshold, roi, pt
                            )
                            pt = (pt[0] + up + topB, pt[1] + leftB)
                            (left, top, right, bottom) = (
                                pt[1],
                                pt[0],
                                pt[1] + markW,
                                pt[0] + markH,
                            )
                            if connDegree &gt; ratio:
                                if showKept and (not batch or boxed):
                                    im = stages[&#34;boxed&#34;]
                                    addBox(
                                        C,
                                        im,
                                        left,
                                        top,
                                        right,
                                        bottom,
                                        True,
                                        band,
                                        seq,
                                        connDegree,
                                    )
                                    markResults.setdefault(band, {}).setdefault(
                                        (seq, markName), []
                                    ).append(
                                        (
                                            True,
                                            value,
                                            connDegree,
                                            connectBorder,
                                            stripe,
                                            block,
                                            left,
                                            top,
                                            right,
                                            bottom,
                                        )
                                    )
                            else:
                                if batch and not boxed:
                                    cv2.rectangle(
                                        stages[&#34;clean&#34;],
                                        (left, top),
                                        (right, bottom),
                                        cleanClr,
                                        -1,
                                    )
                                else:
                                    for (stage, im, clr, brd) in tasks:
                                        isBoxed = stage == &#34;boxed&#34;
                                        if isBoxed:
                                            addBox(
                                                C,
                                                im,
                                                left,
                                                top,
                                                right,
                                                bottom,
                                                False,
                                                band,
                                                seq,
                                                connDegree,
                                            )
                                            markResults.setdefault(band, {}).setdefault(
                                                (seq, markName), []
                                            ).append(
                                                (
                                                    False,
                                                    value,
                                                    connDegree,
                                                    connectBorder,
                                                    stripe,
                                                    block,
                                                    left,
                                                    top,
                                                    right,
                                                    bottom,
                                                )
                                            )
                                        else:
                                            cv2.rectangle(
                                                im,
                                                (left, top),
                                                (right, bottom),
                                                clr,
                                                -1,
                                            )

            if not batch or boxed:
                if line is not None and theUpper is not None and theLower is not None:
                    grace = 20
                    thisTop = max(0, theUpper - grace)
                    thisBottom = min(maxH, theLower + grace)
                    info(
                        f&#34;block {stripe}{block} line {line} BEFORE/AFTER cleaning\n&#34;,
                        tm=False,
                    )
                    roi = thisDemargined[thisTop:thisBottom]
                    showImage(roi)
                    roiBoxed = thisBoxed[thisTop:thisBottom]
                    showImage(roiBoxed)
        stages[&#34;markData&#34;] = markResults
        if line is None:
            for (band, bandMarks) in sorted(markResults.items()):
                for ((seq, mark), entries) in sorted(bandMarks.items()):
                    indent(level=2)
                    kept = sum(1 for e in entries if e[0])
                    wiped = len(entries) - kept
                    warning(
                        f&#34;{seq:&gt;2} - {band:&lt;10}: {mark:&lt;20}&#34;
                        f&#34; wiped {wiped:&gt;4} x, kept {kept:&gt;4} x&#34;,
                        tm=False,
                    )
        else:
            self.show(stage=&#34;markData&#34;)
        indent(level=1)
        clean = stages[&#34;clean&#34;]
        (th, threshed) = cv2.threshold(
            clean, 127, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
        )
        pts = cv2.findNonZero(threshed)
        if pts is None:
            self.empty = True
            if not batch:
                info(&#34;empty page&#34;)
            return

        info(&#34;cleaning done&#34;)

    def _showCleanInfo(self):
        &#34;&#34;&#34;Pretty-prints the result of the cleaning stage.&#34;&#34;&#34;

        engine = self.engine
        C = engine.C
        grey = C.greyGRS
        tm = engine.tm
        info = tm.info
        indent = tm.indent
        stages = self.stages
        markData = stages.get(&#34;markData&#34;, {})
        total = 0

        total = 0
        for (band, markInfo) in sorted(markData.items()):
            indent(level=0)
            info(band, tm=False)
            for ((seq, mark), entries) in sorted(markInfo.items()):
                indent(level=1)
                wiped = sum(1 for e in entries if not e[0])
                total += wiped
                notWiped = len(entries) - wiped
                markImage = reborder(engine.marks[band][mark][&#34;gray&#34;], 2, grey)
                showImage(markImage)
                info(
                    f&#34;{seq:&gt;2}: {mark:&lt;20} wiped {wiped:&gt;4} x, kept {notWiped:&gt;4} x&#34;,
                    tm=False,
                )
                info(
                    f&#34;{&#39;&#39;:24} kept  {notWiped:&gt;4} x&#34;,
                    tm=False,
                )
                for (
                    k,
                    value,
                    conn,
                    border,
                    stripe,
                    block,
                    top,
                    bottom,
                    left,
                    right,
                ) in sorted(entries):
                    indent(level=2)
                    wRep = &#34;kept&#34; if k else &#34;wiped&#34;
                    block = f&#34;{stripe}{block}&#34;
                    info(
                        f&#34;{wRep:&lt;5} [{block:&gt;3}]&#34;
                        f&#34; tblr={top:&gt;4} {bottom:&gt;4} {left:&gt;4} {right:&gt;4},&#34;
                        f&#34; value={value:5.2f} conn={conn:5.3f} border={border:&gt;2}&#34;,
                        tm=False,
                    )

    def ocring(self):
        &#34;&#34;&#34;Calls the OCR engine for a page.&#34;&#34;&#34;

        engine = self.engine
        OCR = engine.OCR

        OCR.read(self)
        OCR.proofing(self)

    def proofing(self):
        &#34;&#34;&#34;Produces proofing images&#34;&#34;&#34;

        engine = self.engine
        OCR = engine.OCR
        OCR.proofing(self)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fusus.page.Page.cleaning"><code class="name flex">
<span>def <span class="ident">cleaning</span></span>(<span>self, mark=None, block=None, line=None, showKept=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove marks from the page.</p>
<p>The blocks of the page are cleaned of marks.</p>
<p>New stages of the page are added:</p>
<ul>
<li><em>clean</em> all targeted marks removed</li>
<li><em>cleanh</em> all targeted marks highlighted in light gray</li>
<li><em>boxed</em> all targeted marks boxed in light gray</li>
<li><em>markData</em> information about each detected mark.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mark</code></strong> :&ensp;<code>iterable</code> of <code>tuples (band, mark, [params])</code>, optional <code>None</code></dt>
<dd>If <code>None</code>, all marks that are presented in the book
directory are used.
Otherwise, a series of marks is specified together with the band
where this mark is searched in. Optionally you can also
put parameters in the tuple: the accuracy, connectBorder and connectRatio.</dd>
<dt><strong><code>block</code></strong> :&ensp;<code>(integer, string)</code>, optional <code>None</code></dt>
<dd>Block identifier. If specified, only this block will be cleaned.
If absent, cleans all blocks.</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>Line number specifying the line numbers to clean.
In all specified blocks, only the line with this number will be cleaned.
If absent, cleans all lines in the specified blocks.</dd>
<dt><strong><code>showKept</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to show the mark candidates that are kept.
If False, kept marks do not show up as green boxes,
and they do not contribute to the markData layer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L718-L1031" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cleaning(self, mark=None, block=None, line=None, showKept=False):
    &#34;&#34;&#34;Remove marks from the page.

    The blocks of the page are cleaned of marks.

    New stages of the page are added:

    *   *clean* all targeted marks removed
    *   *cleanh* all targeted marks highlighted in light gray
    *   *boxed* all targeted marks boxed in light gray
    *   *markData* information about each detected mark.

    Parameters
    ----------
    mark: iterable of tuples (band, mark, [params]), optional `None`
        If `None`, all marks that are presented in the book
        directory are used.
        Otherwise, a series of marks is specified together with the band
        where this mark is searched in. Optionally you can also
        put parameters in the tuple: the accuracy, connectBorder and connectRatio.
    block: (integer, string), optional `None`
        Block identifier. If specified, only this block will be cleaned.
        If absent, cleans all blocks.
    line: integer, optional `None`
        Line number specifying the line numbers to clean.
        In all specified blocks, only the line with this number will be cleaned.
        If absent, cleans all lines in the specified blocks.
    showKept: boolean, optional `False`
        Whether to show the mark candidates that are kept.
        If False, kept marks do not show up as green boxes,
        and they do not contribute to the markData layer.
    &#34;&#34;&#34;

    if self.empty:
        return

    engine = self.engine
    tm = engine.tm
    indent = tm.indent
    info = tm.info
    error = tm.error
    warning = tm.warning
    C = engine.C

    marks = engine.marks
    batch = self.batch
    boxed = self.boxed

    markParams = C.markParams
    boxBorder = C.boxBorder

    connectBorder = C.connectBorder
    threshold = C.connectThreshold
    maxHits = C.maxHits
    color = dict(
        clean=C.cleanRGB,
        cleanh=C.cleanhRGB,
    )

    if mark is None:
        searchMarks = {subdir: markItems for (subdir, markItems) in marks.items()}
    else:
        searchMarks = {}
        for item in mark:
            (band, name) = item[0:2]
            if band not in marks or name not in marks[band]:
                error(f&#34;No such mark: {band}/{mark}&#34;)
                continue
            params = item[2] if len(item) &gt; 2 else {}
            for (acro, v) in params.items():
                if acro not in markParams:
                    error(f&#34;Unknown parameter `{acro}` = `{v}`&#34;)
            configuredMark = marks[band][name]
            seq = configuredMark[&#34;seq&#34;]
            searchMarks.setdefault(band, {})[name] = dict(
                seq=seq, gray=configuredMark[&#34;gray&#34;]
            )
            for (acro, full) in markParams.items():
                searchMarks[band][name][full] = params.get(
                    acro, configuredMark[full]
                )

    stages = self.stages
    demargined = stages.get(&#34;demargined&#34;, stages[&#34;gray&#34;])
    if batch:
        resultStages = (&#34;clean&#34;, &#34;boxed&#34;) if boxed else (&#34;clean&#34;,)
        if boxed:
            demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
    else:
        demarginedC = stages.get(&#34;demarginedC&#34;, stages[&#34;orig&#34;])
        resultStages = (&#34;clean&#34;, &#34;cleanh&#34;, &#34;boxed&#34;)
    for stage in resultStages:
        stages[stage] = (demarginedC if stage == &#34;boxed&#34; else demargined).copy()

    tasks = [
        (
            stage,
            stages[stage],
            None if stage == &#34;boxed&#34; else color[stage],
            boxBorder if stage == &#34;boxed&#34; else -1,
        )
        for stage in resultStages
    ]

    foundHits = {}
    cleanClr = color[&#34;clean&#34;]
    blocks = self.blocks
    markResults = {}

    for ((stripe, block), data) in blocks.items():
        if block is not None and block != (stripe, block):
            continue
        (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
        thisDemargined = demargined[topB:bottomB, leftB:rightB]
        if not batch or boxed:
            thisBoxed = stages[&#34;boxed&#34;][topB:bottomB, leftB:rightB]
            theUpper = None
            theLower = None
            maxH = bottomB - topB

        for (band, markData) in searchMarks.items():
            if &#34;bands&#34; not in data:
                # error(f&#34;No bands in {stripe}{block}&#34;)
                continue
            bandData = data[&#34;bands&#34;][band]
            lines = bandData[&#34;lines&#34;]

            for (markName, markInfo) in markData.items():
                foundHits.setdefault(band, {})[markName] = 0
                seq = markInfo[&#34;seq&#34;]
                mark = markInfo[&#34;gray&#34;]
                connectBorder = markInfo[&#34;connectBorder&#34;]
                accuracy = markInfo[&#34;accuracy&#34;]
                ratio = markInfo[&#34;connectRatio&#34;]
                (markH, markW) = mark.shape[:2]

                nPts = 0
                clusters = []
                for (i, (up, lo)) in enumerate(lines):
                    if line is not None:
                        if i &lt; line - 1:
                            continue
                        elif i &gt; line - 1:
                            break
                    if line is not None and i == line - 1:
                        if theUpper is None or theUpper &gt; up:
                            theUpper = up
                        if theLower is None or theLower &lt; lo:
                            theLower = lo

                    roi = thisDemargined[up : lo + 1]
                    (roih, roiw) = roi.shape[:2]
                    if roih &lt; markH or roiw &lt; markW:
                        # search template exceeds roi image
                        continue
                    result = cv2.matchTemplate(roi, mark, cv2.TM_CCOEFF_NORMED)
                    loc = np.where(result &gt;= accuracy)
                    pts = list(zip(*loc))

                    # if too many hits: bad template or required accuracy too low

                    if len(pts) &gt; maxHits:
                        error(
                            f&#34;mark &#39;{band}:{markName}&#39;:&#34;
                            f&#34; too many hits: {len(pts)} &gt; {maxHits}&#34;
                        )
                        warning(&#34;Increase accuracy for this template&#34;)
                        continue
                    if not pts:
                        continue

                    # fuzzy matching produces several hits in the neighbourhood
                    # of marks. We have to reduce that to the best hit.
                    # We cluster the hits into clusters of neighbouring hits.

                    nPts += len(pts)
                    clusters = cluster(pts, result)

                    # We pick the representant hit from each cluster and
                    # check the ink connectedness
                    # Explanation in `fusus.clean`

                    for (pt, value) in clusters:
                        connDegree = connected(
                            markH, markW, connectBorder, threshold, roi, pt
                        )
                        pt = (pt[0] + up + topB, pt[1] + leftB)
                        (left, top, right, bottom) = (
                            pt[1],
                            pt[0],
                            pt[1] + markW,
                            pt[0] + markH,
                        )
                        if connDegree &gt; ratio:
                            if showKept and (not batch or boxed):
                                im = stages[&#34;boxed&#34;]
                                addBox(
                                    C,
                                    im,
                                    left,
                                    top,
                                    right,
                                    bottom,
                                    True,
                                    band,
                                    seq,
                                    connDegree,
                                )
                                markResults.setdefault(band, {}).setdefault(
                                    (seq, markName), []
                                ).append(
                                    (
                                        True,
                                        value,
                                        connDegree,
                                        connectBorder,
                                        stripe,
                                        block,
                                        left,
                                        top,
                                        right,
                                        bottom,
                                    )
                                )
                        else:
                            if batch and not boxed:
                                cv2.rectangle(
                                    stages[&#34;clean&#34;],
                                    (left, top),
                                    (right, bottom),
                                    cleanClr,
                                    -1,
                                )
                            else:
                                for (stage, im, clr, brd) in tasks:
                                    isBoxed = stage == &#34;boxed&#34;
                                    if isBoxed:
                                        addBox(
                                            C,
                                            im,
                                            left,
                                            top,
                                            right,
                                            bottom,
                                            False,
                                            band,
                                            seq,
                                            connDegree,
                                        )
                                        markResults.setdefault(band, {}).setdefault(
                                            (seq, markName), []
                                        ).append(
                                            (
                                                False,
                                                value,
                                                connDegree,
                                                connectBorder,
                                                stripe,
                                                block,
                                                left,
                                                top,
                                                right,
                                                bottom,
                                            )
                                        )
                                    else:
                                        cv2.rectangle(
                                            im,
                                            (left, top),
                                            (right, bottom),
                                            clr,
                                            -1,
                                        )

        if not batch or boxed:
            if line is not None and theUpper is not None and theLower is not None:
                grace = 20
                thisTop = max(0, theUpper - grace)
                thisBottom = min(maxH, theLower + grace)
                info(
                    f&#34;block {stripe}{block} line {line} BEFORE/AFTER cleaning\n&#34;,
                    tm=False,
                )
                roi = thisDemargined[thisTop:thisBottom]
                showImage(roi)
                roiBoxed = thisBoxed[thisTop:thisBottom]
                showImage(roiBoxed)
    stages[&#34;markData&#34;] = markResults
    if line is None:
        for (band, bandMarks) in sorted(markResults.items()):
            for ((seq, mark), entries) in sorted(bandMarks.items()):
                indent(level=2)
                kept = sum(1 for e in entries if e[0])
                wiped = len(entries) - kept
                warning(
                    f&#34;{seq:&gt;2} - {band:&lt;10}: {mark:&lt;20}&#34;
                    f&#34; wiped {wiped:&gt;4} x, kept {kept:&gt;4} x&#34;,
                    tm=False,
                )
    else:
        self.show(stage=&#34;markData&#34;)
    indent(level=1)
    clean = stages[&#34;clean&#34;]
    (th, threshed) = cv2.threshold(
        clean, 127, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
    )
    pts = cv2.findNonZero(threshed)
    if pts is None:
        self.empty = True
        if not batch:
            info(&#34;empty page&#34;)
        return

    info(&#34;cleaning done&#34;)</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.doLayout"><code class="name flex">
<span>def <span class="ident">doLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide the page into stripes and the stripes into blocks.</p>
<p>We detect vertical strokes as block separators and horizontal strokes
as separators to split off top and bottom material.</p>
<p>A page may or may not be partially divided into blocks.
Where there is a vertical stroke, we define a stripe: the
horizontal band that contains the vertical stroke tightly and extends to
the full with of the page.</p>
<p>Between the stripes corresponding to block separators we have stripes that
are not split into blocks.</p>
<p>The stripes will be numbered from top to bottom, starting at 1.</p>
<p>If a stripe is not split, it defines a roi (region of interest) with
label <code>(i, '')</code>.</p>
<p>If it is split, it defines blocks with labels <code>(i, 'r')</code> and <code>(i, 'l')</code>.</p>
<p>Every horizontal stripe will be examined. We have to determine whether
it is a top separator or a bottom separator.
As a rule of thumb: horizontal stripes in the top stripe are top-separators,
all other horizontal stripes are bottom separators.</p>
<p>If there are multiple horizontal strokes in a roi, the most aggressive
one will be taken, i.e. the one that causes the most matarial to be discarded.</p>
<p>All further operations will take place on these blocks (and not on the
page as a whole).</p>
<p>The result of this stage is, besides the blocks, an image of the page
with the blocks marked and labelled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L649-L716" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doLayout(self):
    &#34;&#34;&#34;Divide the page into stripes and the stripes into blocks.

    We detect vertical strokes as block separators and horizontal strokes
    as separators to split off top and bottom material.

    A page may or may not be partially divided into blocks.
    Where there is a vertical stroke, we define a stripe: the
    horizontal band that contains the vertical stroke tightly and extends to
    the full with of the page.

    Between the stripes corresponding to block separators we have stripes that
    are not split into blocks.

    The stripes will be numbered from top to bottom, starting at 1.

    If a stripe is not split, it defines a roi (region of interest) with
    label `(i, &#39;&#39;)`.

    If it is split, it defines blocks with labels `(i, &#39;r&#39;)` and `(i, &#39;l&#39;)`.

    Every horizontal stripe will be examined. We have to determine whether
    it is a top separator or a bottom separator.
    As a rule of thumb: horizontal stripes in the top stripe are top-separators,
    all other horizontal stripes are bottom separators.

    If there are multiple horizontal strokes in a roi, the most aggressive
    one will be taken, i.e. the one that causes the most matarial to be discarded.

    All further operations will take place on these blocks (and not on the
    page as a whole).

    The result of this stage is, besides the blocks, an image of the page
    with the blocks marked and labelled.
    &#34;&#34;&#34;

    batch = self.batch
    boxed = self.boxed
    engine = self.engine
    C = engine.C
    debug = C.debug
    tm = engine.tm
    indent = tm.indent
    info = tm.info

    pageW = self.pageW
    pageH = self.pageH

    stages = self.stages
    if not batch or boxed:
        stages[&#34;layout&#34;] = stages[&#34;normalizedC&#34;].copy()

    indent(level=3)
    stretchesH = getStretches(C, info, stages, pageW, True, batch)
    stretchesV = getStretches(C, info, stages, pageH, False, batch)
    stripes = getStripes(stages, stretchesV)
    blocks = getBlocks(C, info, stages, pageH, stripes, stretchesH, batch)
    if debug:
        showImage(stages[&#34;layout&#34;])
    self.blocks = blocks
    applyHRules(C, stages, stretchesH, stripes, blocks, batch, boxed)
    emptyBlocks = getInkDistribution(C, info, stages, pageH, blocks, batch, boxed)

    if not batch:
        grayInterBlocks(C, stages, blocks)

    for b in emptyBlocks:
        del blocks[b]</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.doNormalize"><code class="name flex">
<span>def <span class="ident">doNormalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalizes a page.</p>
<p>Previously needed to unskew pages.
But now we assume pages are already skewed.</p>
<p>Skewing turned out to be risky: when pages are filled in unusual
ways, we got unexpected and unwanted rotations.
So we don't do that anymore.</p>
<p>If the input page images have skew artefacts
(black sharp triangles in the corners)
as a result of previous skewing these will be removed.</p>
<p>Normalization produces the stages:</p>
<ul>
<li><em>gray</em>: grayscale version of <em>orig</em></li>
<li><em>blurred</em>: inverted, black-white, blurred without skew artefacts,
needed for histograms later on;</li>
<li><em>normalized</em>: <em>gray</em> without skew artefacts;</li>
<li><em>normalizedC</em>: <em>orig</em> without skew artefacts.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L577-L647" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doNormalize(self):
    &#34;&#34;&#34;Normalizes a page.

    Previously needed to unskew pages.
    But now we assume pages are already skewed.

    Skewing turned out to be risky: when pages are filled in unusual
    ways, we got unexpected and unwanted rotations.
    So we don&#39;t do that anymore.

    If the input page images have skew artefacts
    (black sharp triangles in the corners)
    as a result of previous skewing these will be removed.

    Normalization produces the stages:

    * *gray*: grayscale version of *orig*
    * *blurred*: inverted, black-white, blurred without skew artefacts,
      needed for histograms later on;
    * *normalized*: *gray* without skew artefacts;
    * *normalizedC*: *orig* without skew artefacts.

    &#34;&#34;&#34;

    if self.empty:
        return

    engine = self.engine
    tm = engine.tm
    info = tm.info
    C = engine.C

    batch = self.batch
    boxed = self.boxed
    stages = self.stages
    orig = stages[&#34;orig&#34;]
    gray = cv2.cvtColor(orig, cv2.COLOR_BGR2GRAY)
    stages[&#34;gray&#34;] = gray
    blurredGray = cv2.GaussianBlur(gray, (C.blurX, C.blurY), 0, 0)
    (th, blurredGray) = cv2.threshold(
        blurredGray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
    )
    crop = cropBorders(blurredGray)

    normalized = gray.copy()
    removeBorders(normalized, crop, C.whiteGRS)
    stages[&#34;normalized&#34;] = normalized

    if not batch or boxed:
        normalizedC = orig.copy()
        removeBorders(normalizedC, crop, C.whiteRGB)
        stages[&#34;normalizedC&#34;] = normalizedC

    blurred = cv2.GaussianBlur(normalized, (C.blurX, C.blurY), 0, 0)

    (th, blurred) = cv2.threshold(
        blurred, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU
    )

    stages[&#34;blurred&#34;] = blurred

    # detect if the image is empty

    pts = cv2.findNonZero(blurred)
    if pts is None:
        self.empty = True
        if not batch:
            info(&#34;empty page&#34;)
        return

    self.empty = False</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.ocring"><code class="name flex">
<span>def <span class="ident">ocring</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls the OCR engine for a page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L1087-L1094" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ocring(self):
    &#34;&#34;&#34;Calls the OCR engine for a page.&#34;&#34;&#34;

    engine = self.engine
    OCR = engine.OCR

    OCR.read(self)
    OCR.proofing(self)</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.proofing"><code class="name flex">
<span>def <span class="ident">proofing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Produces proofing images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L1096-L1101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def proofing(self):
    &#34;&#34;&#34;Produces proofing images&#34;&#34;&#34;

    engine = self.engine
    OCR = engine.OCR
    OCR.proofing(self)</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, stage=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads processing data for selected stages from disk</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no stage is passed, all stages will be read, if corresponding files
are present.
Otherwise, the indicated stages are read.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L362-L398" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def read(self, stage=None):
    &#34;&#34;&#34;Reads processing data for selected stages from disk

    Parameters
    ----------
    stage: string | iterable, optional `None`
        If no stage is passed, all stages will be read, if corresponding files
        are present.
        Otherwise, the indicated stages are read.
    &#34;&#34;&#34;

    engine = self.engine
    tm = engine.tm
    error = tm.error
    C = engine.C

    stages = self.stages

    for s in parseStages(stage, set(C.stages), C.stageOrder, error):
        (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]

        if stageType == &#34;link&#34;:
            # stages of type link will be written to disk upon creation
            # and not stored and need not be retrieved
            pass
        else:
            sPath = self.stagePath(s)
            if not os.path.exists(sPath):
                stages[s] = None
                if s in {&#34;normalized&#34;, &#34;char&#34;, &#34;word&#34;}:
                    self.empty = True
                continue
            if stageType == &#34;image&#34;:
                stages[s] = cv2.imread(sPath)
            elif stageType == &#34;data&#34;:
                with open(sPath) as f:
                    stages[s] = self._ingest(s, stageType, stageExt, f)</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, stage=None, band=None, mark=None, **displayParams)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays processing stages of an page.</p>
<p>See <code><a title="fusus.parameters.STAGES" href="parameters.html#fusus.parameters.STAGES">STAGES</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no stage is passed, all stages are shown as thumbnails.
Otherwise, the indicated stages are shown.
If a string, it may be a comma-separated list of stage names.
Otherwise it is an iterable of stage names.</dd>
<dt><strong><code>band</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no band is passed, no bands are indicated.
Otherwise, the indicated bands are shown.
If a string, it may be a comma-separated list of band names.
Otherwise it is an iterable of band names.</dd>
<dt><strong><code>mark</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If <code>None</code> is passed, no marks are shown.
If <code>""</code> is passed, all marks on the selected bands are shown.
Otherwise, the indicated mark boxes are shown, irrespective
of their bands:
If given as a string, it may be a comma-separated list of mark names.
Otherwise it is an iterable of mark names.
This information will be taken from the result of the <code>markData</code> stage.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>A set of display parameters, such as <code>width</code>, <code>height</code>
(anything accepted by <code>IPython.display.Image</code>).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The mark option works for the "boxed" stage:
All marks not specified in the mark parameter will not be shown.</p>
<p>But this option also works for all other image stages: the marks
will be displayed on a fresh copy of that stage.</p>
<p>When used for a grayscale stage, the color of the mark boxes is lost.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L142-L344" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(self, stage=None, band=None, mark=None, **displayParams):
    &#34;&#34;&#34;Displays processing stages of an page.

    See `fusus.parameters.STAGES`.

    Parameters
    ----------
    stage: string | iterable, optional `None`
        If no stage is passed, all stages are shown as thumbnails.
        Otherwise, the indicated stages are shown.
        If a string, it may be a comma-separated list of stage names.
        Otherwise it is an iterable of stage names.
    band: string | iterable, optional `None`
        If no band is passed, no bands are indicated.
        Otherwise, the indicated bands are shown.
        If a string, it may be a comma-separated list of band names.
        Otherwise it is an iterable of band names.
    mark: string | iterable, optional `None`
        If `None` is passed, no marks are shown.
        If `&#34;&#34;` is passed, all marks on the selected bands are shown.
        Otherwise, the indicated mark boxes are shown, irrespective
        of their bands:
        If given as a string, it may be a comma-separated list of mark names.
        Otherwise it is an iterable of mark names.
        This information will be taken from the result of the `markData` stage.
    display: dict, optional
        A set of display parameters, such as `width`, `height`
        (anything accepted by `IPython.display.Image`).

    Notes
    -----
    The mark option works for the &#34;boxed&#34; stage:
    All marks not specified in the mark parameter will not be shown.

    But this option also works for all other image stages: the marks
    will be displayed on a fresh copy of that stage.

    When used for a grayscale stage, the color of the mark boxes is lost.
    &#34;&#34;&#34;

    engine = self.engine
    tm = engine.tm
    error = tm.error
    C = engine.C
    cd = engine.cd

    stages = self.stages
    marks = engine.marks
    blocks = self.blocks

    for s in parseStages(stage, set(stages), C.stageOrder, error):
        stageData = stages[s]

        (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]
        white = C.whiteRGB if stageColor else C.whiteGRS
        if stageType == &#34;data&#34;:
            display(HTML(f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: &lt;i&gt;data:&lt;/i&gt;&lt;/div&gt;&#34;))
            self._serial(s, stageData, stageExt)
        elif stageType == &#34;link&#34;:
            path = self.stagePath(s)
            if os.path.exists(path):
                showPath = unexpanduser(f&#34;{cd}{path}&#34;)
                nbLink = getNbLink(showPath, stageData)
                if nbLink is None:
                    display(HTML(f&#34;{stageData} in {showPath}&#34;))
                else:
                    display(
                        HTML(
                            f&#34;&#34;&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: {nbLink}&#34;&#34;&#34;
                            f&#34;&#34;&#34; (local file: {showPath})&lt;/div&gt;&#34;&#34;&#34;
                        )
                    )
            else:
                display(
                    HTML(
                        f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt;: &#34;
                        f&#34;&lt;i&gt;{showPath} does not exist.&lt;/i&gt;&lt;/div&gt;&#34;
                    )
                )
        else:
            img = stageData

            headingInfo = []

            if band is not None or mark is not None:
                img = (
                    stages[&#34;demarginedC&#34;]
                    if s == &#34;boxed&#34; and mark is not None
                    else stageData
                ).copy()
                for ((stripe, block), data) in blocks.items():

                    bands = data[&#34;bands&#34;]
                    doBands = (
                        () if band is None else parseBands(band, set(bands), error)
                    )
                    doBandSet = set(doBands)
                    bandRep = f&#34; with bands {&#39;, &#39;.join(doBands)}&#34; if doBands else &#34;&#34;
                    doMarks = (
                        set()
                        if mark is None
                        else parseMarks(mark, marks, set(doBands), error)
                    )
                    markRep = (
                        f&#34; with marks {&#39;, &#39;.join(sorted(doMarks))}&#34;
                        if doMarks
                        else &#34;&#34;
                    )
                    headingInfo.append(
                        f&#34;&lt;b&gt;{stripe}{block}&lt;/b&gt; {bandRep}{markRep}&#34;
                    )

                    (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                    imBW = rightB - leftB
                    for band in doBands:
                        bandInfo = bands[band]
                        lines = bandInfo[&#34;lines&#34;]
                        bColor = bandInfo[&#34;color&#34;]
                        for (up, lo) in lines:
                            theUpper = topB + up
                            theLower = topB + lo
                            theLeft = leftB + 10
                            theRight = leftB + imBW - 10
                            cv2.rectangle(
                                img,
                                (theLeft, theUpper),
                                (theRight, theLower),
                                bColor,
                                2,
                            )
                            overlay(
                                img,
                                leftB,
                                theUpper,
                                theLeft,
                                theLower,
                                white,
                                bColor,
                            )
                            overlay(
                                img,
                                theRight,
                                theUpper,
                                leftB + imBW,
                                theLower,
                                white,
                                bColor,
                            )
                markData = stages.get(&#34;markData&#34;, {})
                markLegend = {}

                for (band, bandMarks) in markData.items():
                    if doBands and band not in doBandSet:
                        continue
                    for ((seq, mrk), hits) in bandMarks.items():
                        if mrk not in doMarks:
                            continue
                        markKey = f&#34;{&#39;&#39; if band == &#39;main&#39; else band[0]}{seq}&#34;
                        markValue = (band, mrk, len(hits))
                        markLegend[markKey] = markValue
                        for (
                            kept,
                            value,
                            connDegree,
                            connectBorder,
                            stripe,
                            block,
                            left,
                            top,
                            right,
                            bottom,
                        ) in hits:
                            addBox(
                                C,
                                img,
                                left,
                                top,
                                right,
                                bottom,
                                kept,
                                band,
                                seq,
                                connDegree,
                            )

                if markLegend:
                    html = []
                    html.append(
                        &#34;&lt;details open&gt;&lt;summary&gt;Mark legend&lt;/summary&gt;&lt;table&gt;&#34;
                    )
                    html.append(
                        &#34;&lt;tr&gt;&lt;th&gt;acro&lt;/th&gt;&lt;th&gt;band&lt;/th&gt;&#34;
                        &#34;&lt;th&gt;mark&lt;/th&gt;&lt;th&gt;hits&lt;/th&gt;&lt;/tr&gt;&#34;
                    )
                    for (k, (b, m, n)) in sorted(markLegend.items()):
                        html.append(
                            f&#34;&lt;tr&gt;&lt;td&gt;{k}&lt;/td&gt;&lt;td&gt;{b}&lt;/td&gt;&#34;
                            f&#34;&lt;td&gt;{m}&lt;/td&gt;&lt;td&gt;{n}&lt;/td&gt;&lt;/tr&gt;&#34;
                        )
                    html.append(&#34;&lt;/table&gt;&lt;/details&gt;&#34;)
                    display(HTML(&#34;&#34;.join(html)))
            display(HTML(f&#34;&lt;hr&gt;\n&lt;div&gt;&lt;b&gt;{s}&lt;/b&gt; {&#39;;&#39;.join(headingInfo)}&lt;/div&gt;&#34;))
            showImage(img, **displayParams)</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.stagePath"><code class="name flex">
<span>def <span class="ident">stagePath</span></span>(<span>self, stage, inter=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L346-L360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stagePath(self, stage, inter=None):
    engine = self.engine
    C = engine.C

    bare = self.bare
    ext = self.ext

    (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[stage]
    dest = getattr(C, stageDir or &#34;interDir&#34;)
    inter = &#34;&#34; if inter is None else f&#34;-{inter}&#34;
    trail = stage if stagePart is None else &#34;&#34; if not stagePart else stagePart
    trail = &#34;&#34; if not trail else f&#34;-{trail}&#34;
    ext = DEFAULT_EXTENSION if stageType == &#34;image&#34; else (stageExt or ext)
    base = f&#34;{dest}/{bare}{inter}{trail}&#34;
    return f&#34;{base}.{ext}&#34;</code></pre>
</details>
</dd>
<dt id="fusus.page.Page.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, stage=None, perBlock=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes processing stages of an page to disk.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>stage</code></strong> :&ensp;<code>string | iterable</code>, optional <code>None</code></dt>
<dd>If no stage is passed, all stages are shown as thumbnails.
Otherwise, the indicated stages are shown.
If a string, it may be a comma-separated list of stage names.
Otherwise it is an iterable of stage names.</dd>
<dt><strong><code>perBlock</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the stage output will be split into blocks and written
to disk separately. The stripe and block are appended
to the file name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The stages are written into the <code>inter</code> or <code>clean</code> subdirectory,
with the name of the stage appended to the file name.
If <code>clean</code>, the name of the stage is omitted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/4ef24b31a3e4560c6941aa47542b4feb29775d99/fusus/page.py#L400-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def write(self, stage=None, perBlock=False):
    &#34;&#34;&#34;Writes processing stages of an page to disk.

    Parameters
    ----------
    stage: string | iterable, optional `None`
        If no stage is passed, all stages are shown as thumbnails.
        Otherwise, the indicated stages are shown.
        If a string, it may be a comma-separated list of stage names.
        Otherwise it is an iterable of stage names.
    perBlock: boolean, optional `False`
        If True, the stage output will be split into blocks and written
        to disk separately. The stripe and block are appended
        to the file name.

    Returns
    -------
    None
        The stages are written into the `inter` or `clean` subdirectory,
        with the name of the stage appended to the file name.
        If `clean`, the name of the stage is omitted.
    &#34;&#34;&#34;

    engine = self.engine
    tm = engine.tm
    error = tm.error
    C = engine.C

    stages = self.stages
    blocks = self.blocks

    for s in parseStages(stage, set(C.stages), C.stageOrder, error):
        if s not in stages:
            continue
        stageData = stages[s]
        (stageType, stageColor, stageExt, stageDir, stagePart) = C.stages[s]

        if stageType == &#34;image&#34;:
            if perBlock:
                for ((stripe, block), data) in blocks.items():
                    blockSpec = f&#34;{stripe:02d}{block}&#34;
                    (leftB, topB, rightB, bottomB) = data[&#34;inner&#34;]
                    roi = stageData[topB:bottomB, leftB:rightB]
                    thisPath = self.stagePath(stage, inter=blockSpec)
                    writeImage(roi, thisPath)
            else:
                writeImage(stageData, self.stagePath(s))
        elif stageType == &#34;data&#34;:
            with open(self.stagePath(s), &#34;w&#34;) as f:
                self._serial(s, stageData, stageExt, handle=f)
        elif stageType == &#34;link&#34;:
            # stages of type link will be written to disk upon creation
            # and not stored
            pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/among" title="among Digital Manuscripts on GitHub"><img src="../fusus/images/fusus-small.png"></a></p>
<p><a href="../fusus/index.html">fusus home</a> -
<a href="../fusus/about/howto.html">HowTo</a>
<a href="https://github.com/among/fusus" title="GitHub repo"><img src="../fusus/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fusus" href="index.html">fusus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fusus.page.Page" href="#fusus.page.Page">Page</a></code></h4>
<ul class="two-column">
<li><code><a title="fusus.page.Page.cleaning" href="#fusus.page.Page.cleaning">cleaning</a></code></li>
<li><code><a title="fusus.page.Page.doLayout" href="#fusus.page.Page.doLayout">doLayout</a></code></li>
<li><code><a title="fusus.page.Page.doNormalize" href="#fusus.page.Page.doNormalize">doNormalize</a></code></li>
<li><code><a title="fusus.page.Page.ocring" href="#fusus.page.Page.ocring">ocring</a></code></li>
<li><code><a title="fusus.page.Page.proofing" href="#fusus.page.Page.proofing">proofing</a></code></li>
<li><code><a title="fusus.page.Page.read" href="#fusus.page.Page.read">read</a></code></li>
<li><code><a title="fusus.page.Page.show" href="#fusus.page.Page.show">show</a></code></li>
<li><code><a title="fusus.page.Page.stagePath" href="#fusus.page.Page.stagePath">stagePath</a></code></li>
<li><code><a title="fusus.page.Page.write" href="#fusus.page.Page.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://digitalorientalist.com/about-cornelis-van-lit/">Cornelis van Lit</a>
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../fusus/images/dans.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>