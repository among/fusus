<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>fusus.lakhnawi API documentation</title>
<meta name="description" content="Lakhnawi pdf reverse engineering â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fusus.lakhnawi</code></h1>
</header>
<section id="section-intro">
<p>Lakhnawi pdf reverse engineering.</p>
<p>This is an effort to make the Lakhnawi PDF readable.
It is a text-based PDF, no images are used to represent text.</p>
<p>Yet the text is not easily extracted, due to:</p>
<ul>
<li>the use of private-use unicode characters that refer to heavily customised fonts;</li>
<li>some fonts have some glyphs with dual unicode points;</li>
<li>the drawing order of characters does not reflect the reading order;</li>
<li>horizontal whitespace is hard to detect due to oversized bounding boxes of many
private-use characters.</li>
</ul>
<p>We used the top-notch Python PDF library
<a href="https://pymupdf.readthedocs.io/en/latest/index.html">PyMUPDF</a>, also know as <em>fitz</em>.</p>
<pre><code>pip3 install PyMuPDF
</code></pre>
<p>But even this library could not solve the above issues.
Here is how we solved the issues</p>
<h1 id="private-use-characters">Private use characters</h1>
<p>We used font analysis software from PdfLib:
<a href="https://www.pdflib.com/download/free-software/fontreporter/">FontReporter</a>
to generate a
<a href="https://github.com/among/fusus/blob/master/ur/Lakhnawi/FontReport-Lakhnawi.pdf">report of character and font usage in the Lakhnawi PDF</a>.</p>
<p>Based on visual inspection of this font report and the occurrences
of the private use tables we compiled a translation table mapping dirty strings
(with private use characters) to clean strings (without private use characters).</p>
<h1 id="dual-code-points">Dual code points</h1>
<p>In case of dual code points, we ignore the highest code points.
Often the two code points refer to a normal Arabic code point and to a ligature or
special form of the character.
The unicode algorithm is very good nowadays to generate the special forms
from the ordinary forms based on immediate context.</p>
<h1 id="reading-order">Reading order</h1>
<p>We ordered the characters ourselves, based on the coordinates.
This required considerable subtlety, because we had to deal
with diacritics above and below the lines.
See <code>clusterVert</code>.</p>
<h1 id="horizontal-whitespace">Horizontal whitespace</h1>
<p>This is the most tricky point, because the information we retain from the PDF is,
strictly speaking, insufficient to determine word boundaries.
Word boundaries are partly in the eyes of the beholder, if the beholder knows Arabic.
The objective part is in the amount of whitespace between characters
and the form of the characters (initial, final, isolated).
But the rules of Arabic orthography allow initial characters inside words,
and there are the enclitic words.</p>
<p>So we only reached an approximate solution for this problem.</p>
<div class="admonition caution">
<p class="admonition-title">Footnotes</p>
<p>We have strippped footnotes and footnote references from the text.</p>
</div>
<h1 id="output-format">Output format</h1>
<p>The most important output are tab separated files with text and positions of
individual words.
See <code><a title="fusus.lakhnawi.Lakhnawi.tsvPages" href="#fusus.lakhnawi.Lakhnawi.tsvPages">Lakhnawi.tsvPages()</a></code>.</p>
<p>This data is used to feed the conversion to Text-Fabric.
See also:</p>
<ul>
<li><code><a title="fusus.tfFromTsv" href="tfFromTsv.html">fusus.tfFromTsv</a></code>.</li>
<li><a href="https://annotation.github.io/text-fabric/tf/index.html">Text-Fabric</a></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L0-L3170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Lakhnawi pdf reverse engineering.

This is an effort to make the Lakhnawi PDF readable.
It is a text-based PDF, no images are used to represent text.

Yet the text is not easily extracted, due to:

* the use of private-use unicode characters that refer to heavily customised fonts;
* some fonts have some glyphs with dual unicode points;
* the drawing order of characters does not reflect the reading order;
* horizontal whitespace is hard to detect due to oversized bounding boxes of many
  private-use characters.

We used the top-notch Python PDF library
[PyMUPDF](https://pymupdf.readthedocs.io/en/latest/index.html), also know as *fitz*.

```
pip3 install PyMuPDF
```

But even this library could not solve the above issues.
Here is how we solved the issues

# Private use characters

We used font analysis software from PdfLib:
[FontReporter](https://www.pdflib.com/download/free-software/fontreporter/)
to generate a
[report of character and font usage in the Lakhnawi PDF](https://github.com/among/fusus/blob/master/ur/Lakhnawi/FontReport-Lakhnawi.pdf).

Based on visual inspection of this font report and the occurrences
of the private use tables we compiled a translation table mapping dirty strings
(with private use characters) to clean strings (without private use characters).

# Dual code points

In case of dual code points, we ignore the highest code points.
Often the two code points refer to a normal Arabic code point and to a ligature or
special form of the character.
The unicode algorithm is very good nowadays to generate the special forms
from the ordinary forms based on immediate context.

# Reading order

We ordered the characters ourselves, based on the coordinates.
This required considerable subtlety, because we had to deal
with diacritics above and below the lines.
See `clusterVert`.

# Horizontal whitespace

This is the most tricky point, because the information we retain from the PDF is,
strictly speaking, insufficient to determine word boundaries.
Word boundaries are partly in the eyes of the beholder, if the beholder knows Arabic.
The objective part is in the amount of whitespace between characters
and the form of the characters (initial, final, isolated).
But the rules of Arabic orthography allow initial characters inside words,
and there are the enclitic words.

So we only reached an approximate solution for this problem.

!!! caution &#34;Footnotes&#34;
    We have strippped footnotes and footnote references from the text.

# Output format

The most important output are tab separated files with text and positions of
individual words.
See `Lakhnawi.tsvPages`.

This data is used to feed the conversion to Text-Fabric.
See also:

* `fusus.tfFromTsv`.
* [Text-Fabric](https://annotation.github.io/text-fabric/tf/index.html)
&#34;&#34;&#34;

import sys
import os
import collections
import re

from itertools import chain

from IPython.display import display, HTML, Image

import fitz

from tf.core.helpers import setFromSpec, unexpanduser

from .parameters import SOURCE_DIR, UR_DIR, ALL_PAGES, LINE_CLUSTER_FACTOR
from .lib import DEFAULT_EXTENSION, pprint, parseNums
from .char import (
    UChar,
    EMSPACE,
    getSetFromDef,
    isAlefFinal,
    isArDigit,
    isEuDigit,
    isMeemOrYeh,
    isWaw,
    normalizeC,
    normalizeD,
    uName,
)


NAME = &#34;Lakhnawi&#34;
SOURCE = f&#34;{SOURCE_DIR}/{NAME}/{NAME.lower()}.pdf&#34;
FONT = f&#34;{UR_DIR}/{NAME}/FontReport-{NAME}.pdf&#34;
DEST = f&#34;{SOURCE_DIR}/{NAME}/{NAME.lower()}.txt&#34;

CSS = &#34;&#34;&#34;
&lt;style&gt;
*,
*:before,
*:after {
    box-sizing: border-box;
}

@page {
  size: A4;
  margin: 2cm;
}

div.window {
    display: flex;
    flex-flow: row nowrap;
    justify-content: flex-start;
    align-items: flex-start;
    min-width: 1000pt;
    height: 99vh;
}
div.sidebar {
    flex: 1 1 300pt;
    display: flex;
    flex-flow: row nowrap;
    border-right: 1pt solid var(--fog-rim);
    padding-left: 8px;
    padding-right: 12px;
    height: 99vh;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
}
div.toc {
    flex: 1 1 50pt;
}
div.pages {
    flex: 0 0 700pt;
}
div.pages.bypage {
    height: 99vh;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
}
div.page {
    margin-right: 1cm;
    padding-left: 0.5cm;
    max-width: 600pt;
    min-width: 600pt;
    width: 600pt;
}
div.pagec {
    margin-right: 1cm;
    padding-right: 10%;
    width: 90%;
    text-align: center;
}
div.phead {
    color: #777777;
    font-size: small;
    text-align: right;
    width: 1cm;
    margin-right: -1cm;
    float: right;
}


.box {
    border: 1pt solid #888888;
    border-radius: 2pt;
}

.r {
    font-family: normal, sans-serif;
    font-size: 22pt;
    direction: rtl;
    unicode-bidi: isolate-override;
}
.rc, .lc {
    font-family: normal, sans-serif;
    font-size: 22pt;
    background-color: white;
    border: 2pt solid #ffcccc;
}
.rc {
    direction: rtl;
    unicode-bidi: isolate-override;
}
.lc {
    direction: ltr;
    unicode-bidi: isolate-override;
}
p {
    text-align: left;
    direction: ltr;
    unicode-bidi: isolate-override;
}
p.r {
    text-align: right;
    direction: rtl;
    unicode-bidi: isolate-override;
}
.l {
    font-family: normal, sans-serif;
    font-size: x-large;
    direction: ltr;
    unicode-bidi: isolate-override;
}
.c {
    font-family: monospace;
    font-size: x-small;
    direction: ltr;
    unicode-bidi: isolate-override;
}
.p {
    font-family: monospace;
    font-size: medium;
    font-weight: bold;
    background-color: yellow;
    direction: ltr;
    unicode-bidi: isolate-override;
}
.lrg {
    font-size: 22pt;
    font-weight: bold;
}
span.sp {
    background-color: rgba(0, 255, 0, 0.5);
}
td.al {
    text-align: left ! important;
}
div.cn {
    text-align: center
}
div.ch.p {
    background-color: #ffeedd;
    text-align: center
}
span.cni {
    background-color: #eeeeee;
    padding-top: 4pt;
    padding-bottom: 4pt;
    padding-left: 8pt;
    padding-right: 8pt;
    border: 2pt solid #66aaaa;
    display: inline-block;
}
div.ch,div.cht,div.chs {
    border: 2pt solid #cccccc;
    display: inline-flex;
    flex-flow: column nowrap;
    max-width: 10em;
}
div.ch {
    background-color: #ddffff;
}
div.chs {
    background-color: #ccffcc;
}
div.chm {
    background-color: #44ff44;
}
div.sr {
    display: flex;
    flex-flow: row wrap;
    direction: rtl;
    unicode-bidi: isolate-override;
}
table.linecols {
    max-width: 100%;
    min-width: 100%;
    width: 100%;
    direction: rtl;
    unicode-bidi: isolate-override;
}
td.cols {
    padding-left: 0.5em;
    padding-right: 0.5em;
    text-align: right;
}
td.cols2 {
    max-width: 50%;
    min-width: 50%;
    width: 500%;
}
td.cols3 {
    max-width: 33%;
    min-width: 33%;
    width: 33%;
}
td.cols4 {
    max-width: 25%;
    min-width: 25%;
    width: 25%;
}
td.cols4 {
    max-width: 20%;
    min-width: 20%;
    width: 20%;
}
:root {
    --fog-rim:          hsla(  0,   0%,  60%, 0.5  );
}
&lt;/style&gt;
&#34;&#34;&#34;
&#34;&#34;&#34;Styles to render extracted text.

The styles are chosen such that the extracted text looks as similar as possible to
the PDF display.
&#34;&#34;&#34;

POST_HTML = &#34;&#34;&#34;
&lt;/body&gt;
&lt;/html&gt;
&#34;&#34;&#34;
&#34;&#34;&#34;HTML code postfixed to the HTML representation of a page.
&#34;&#34;&#34;


def preHtml(pageNum):
    &#34;&#34;&#34;Generate HTML code to be prefixed to the HTML representation of a page.

    Parameters
    ----------
    pageNum: string
        The page number of the page for which HTML is generated.
    &#34;&#34;&#34;

    return f&#34;&#34;&#34;\
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;/&gt;
        &lt;meta charset=&#34;utf-8&#34;/&gt;
        &lt;title&gt;Lakhnawi {pageNum}&lt;/title&gt;
{CSS}
    &lt;/head&gt;
    &lt;body&gt;
&#34;&#34;&#34;


def getToc(pageNums):
    &#34;&#34;&#34;Generate a Table Of Contents for multiple HTML pages.

    Parameter
    ---------
    pageNums: iterable if int
        The page numbers of the pages in the HTML file.
    &#34;&#34;&#34;

    limit = 60

    html = []
    html.append(&#34;&#34;&#34;&lt;div class=&#34;toc&#34;&gt;&#34;&#34;&#34;)
    j = 0

    for (i, pageNum) in enumerate(pageNums):
        if j == limit:
            j = 0
            html.append(&#34;&#34;&#34;&lt;/div&gt;\n&lt;div class=&#34;toc&#34;&gt;&#34;&#34;&#34;)
        html.append(f&#34;&#34;&#34;&lt;a href=&#34;#p{pageNum:&gt;03}&#34;&gt;p {pageNum}&lt;/a&gt;&lt;br&gt;&#34;&#34;&#34;)
        j += 1

    html.append(&#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;)

    return &#34;\n&#34;.join(html)


PRIVATE_SPACE = &#34;\uea75&#34;

PRIVATE_LETTERS_DEF = &#34;&#34;&#34;
e800
e806
e807
e808
e809
e80a
e80e
e898
e8d4
e915
e917
ea79
&#34;&#34;&#34;

PRIVATE_DIAS_DEF = &#34;&#34;&#34;
e812
e814
e815
e816
e817
e818
e81d
e823
e824
e825
e826
e827
e828
e829
e82b
e82e
e82f
e830
e831
e832
e833
e834
e835
e837
e838
e839
e83a
e83f
e840
e845
e846
e849
e84d
e85b
e85c
e863
e864
e86d
e87f
e880
e887
e888
e8de
e8df
e8e6
e8e7
e8e8
e8e9
e8ea
e8eb
e8ee
e8f4
e8f5
e8f6
e8f8
e8fb
e8fe
&#34;&#34;&#34;

PRIVATE_TATWEEL = &#34;\ue821&#34;

PRIVATE_FINAL_SPACE_CODES = &#34;&#34;&#34;
    e898
    e915
    e917
&#34;&#34;&#34;.strip().split()


REPLACE_DEF = &#34;&#34;&#34;
# see https://www.unicode.org/versions/Unicode13.0.0/ch09.pdf
# see https://www.compart.com/en/unicode/U+FE8E
# see https://r12a.github.io/scripts/arabic/block

e821                =&gt;                : (ignore short tatweel)

e825                =&gt; 064e           : FATHA
e849                =&gt; 064e           : FATHA
e86d                =&gt; 064e           : FATHA
e87f                =&gt; 064e           : FATHA
e8e8                =&gt; 064e           : FATHA
e823                =&gt; 064b           : FATHATAN
e8e6                =&gt; 064b           : FATHATAN
e826                =&gt; 064f           : DAMMA
e8e9                =&gt; 064f           : DAMMA
e824                =&gt; 064c           : DAMMATAN
e8e7                =&gt; 064c           : DAMMATAN
e840                =&gt; 0650           : KASRA
e864                =&gt; 0650           : KASRA
e888                =&gt; 0650           : KASRA
e8df                =&gt; 0650           : KASRA
e83f                =&gt; 064d           : KASRATAN
e863                =&gt; 064d           : KASRATAN
e887                =&gt; 064d           : KASRATAN
e8de                =&gt; 064d           : KASRATAN
e827                =&gt; 0651           : SHADDA
e8ea                =&gt; 0651           : SHADDA
e828                =&gt; 0652           : SUKUN
e8eb                =&gt; 0652           : SUKUN
e829                =&gt; 0653           : MADDA
e84d                =&gt; 0653           : MADDA
e82b                =&gt; 0670           : ALEF(super)
e8ee                =&gt; 0670           : ALEF(super)

e830                =&gt; 064e+0651      : SHADDA+FATHA
e8f4                =&gt; 064e+0651      : SHADDA+FATHA
e8f6                =&gt; 064e+0651      : SHADDA+FATHA
e831                =&gt; 064f+0651      : SHADDA+DAMMA
e8f5                =&gt; 064f+0651      : SHADDA+DAMMA
e82e                =&gt; 064c+0651      : SHADDA+DAMMATAN
e832                =&gt; 0650+0651      : SHADDA+KASRA
e82f                =&gt; 064d+0651      : SHADDA+KASRATAN [2]
e834                =&gt; 064d+0651      : SHADDA+KASRATAN [2]
e812                =&gt; 064d+0651      : SHADDA+KASRATAN [2]
e8f8                =&gt; 064d+0651      : SHADDA+KASRATAN [2]

e818                =&gt; 0653+0670      : MADDA+ALEF(super) [4]
e83a                =&gt; 0653+0670      : MADDA+ALEF(super) [4]
e8fe                =&gt; 0653+0670      : MADDA+ALEF(super) [4]
e81d                =&gt; 0640+0650+0651 : TATWEEL+KASRA+SHADDA

# e898                =&gt; 0647           : HEH
e898                =&gt; feea           : HEH final

e806                =&gt; 0627           : ALEF
e807                =&gt; 0627           : ALEF

e808                =&gt; 0671           : ALEF(wasla)
e809                =&gt; 0671           : ALEF(wasla)
e800                =&gt; 0622           : ALEF/MADDA

0627+e815           =&gt; 0623+064e      : ALEF/HAMZA+FATHA
# 0627+e85b           =&gt; 0623+064e      : ALEF/HAMZA+FATHA
fe8e+e815           =&gt; 0623+064e      : ALEF/HAMZA+FATHA
fe8e+e821+e815      =&gt; 0623+064e      : ALEF/HAMZA+FATHA
e806+e85b           =&gt; 0623+064e      : ALEF/HAMZA+FATHA
# 0627+e85c           =&gt; 0623+064f      : ALEF/HAMZA+DAMMA
0627+e816           =&gt; 0623+064f      : ALEF/HAMZA+DAMMA
e806+e85c           =&gt; 0623+064f      : ALEF/HAMZA+DAMMA
fe8e+e816           =&gt; 0623+064f      : ALEF/HAMZA+DAMMA
fe8e+e821+e816      =&gt; 0623+064f      : ALEF/HAMZA+DAMMA
# 0627+e814           =&gt; 0623+064c      : ALEF/HAMZA+DAMMATAN
0627+e846           =&gt; 0625+064d      : ALEF/HAMZA(low)+KASHRATAN
fe8e+e821+e846      =&gt; 0625+064d      : ALEF/HAMZA(low)+KASRATAN
fe8e+e817           =&gt; 0623+0652      : ALEF/HAMZA+SUKUN [7]

e835                =&gt; 0654+064b      : HAMZA+FATHATAN [3]
e837                =&gt; 0654+064e      : HAMZA+FATHA [3]
e8fb                =&gt; 0654+064e      : HAMZA+FATHA [3]
e838                =&gt; 0654+064f      : HAMZA+DAMMA [3]
e880                =&gt; 0654+064f      : HAMZA+DAMMA [3]
e839                =&gt; 0654+0652      : HAMZA+SUKUN [3]
e845                =&gt; 0655+0650      : HAMZA(low)+KASRA

0648+e838           =&gt; 0624+064f      : WAW/HAMZA+DAMMA

e80a                =&gt; 0644           : LAM
e80e                =&gt; 0644           : LAM

# e821+e8d4+e821+e830 =&gt; 0644           : LAM [10]
# e821+e8d4+e82b+e821 =&gt; 0644           : LAM [10]
# e8d4+e830           =&gt; 0644           : LAM [10]
e8d4+e833           =&gt; 0644           : LAM [10]
# e8d4+e821           =&gt; 0644           : LAM [10]
e8d4+e821+e827      =&gt; 0644           : LAM [10]
e8d4+e821+e833      =&gt; 0644           : LAM [10]
e8d4+e821+e821+e833 =&gt; 0644           : LAM [10]
e8d4+fc63           =&gt; 0644           : LAM [10]
e8d4+e827           =&gt; 0644           : LAM [10]
# e8d4                =&gt; 0644           : LAM [10]
# e8d4+064e+e82b      =&gt; 0644           : LAM [11]

fefb+e85b           =&gt; 0644+623+064e  : LAM+ALEF/HAMZA+FATHA
fefb+e85c           =&gt; 0644+0623+064f : LAM/ALEF/HAMZA+DAMMA
fefc+e87f           =&gt; 0644+0623+064e : LAM/ALEF/HAMZA+FATHA

# fef4+e917           =&gt; 064a+0649+0670 : YEH+ALEF(super)
fef4+e917           =&gt; 064a+fef0+0670 : YEH+ALEF(super)

ea75+e828+ea79      =&gt; 062d+0652+0645 : HAH+SUKUN+MEEM

# fe92+0650+e915      =&gt; 0628+0650+064a : BEH+KASRA+YEH
fe92+0650+e915      =&gt; 0628+0650+fef2 : BEH+KASRA+YEH

fec3+0652+e821+e80e+064e+e807 =&gt; 0637+0652+e821+e80e+064e+e807 : [9]

fffd                =&gt;                : replacement character

# [1] it should be a LAM/ALEF ligature with wasla, but there is no such unicode char
#     See https://savannah.gnu.org/bugs/?52454
# [2] it looks like shadda+fathatan, but there is no shadda+fathatan.
#     Instead, it is shadda+kashratan, where the kashratan is placed high.
# [3] not a perfect solution. After fbe9 (alef maksura) the high hamza is not
#     a recommended combination.
# [4] the result combination of madda and alef superscript does not render nicely
# [5] the hamza ends up on the left part of the ligature and combines
#     there with the fatha/damma, the d should be positioned on the rightmost part
#     of the ligature, but this does not happen
# [6] The shadda/kasra should render low, but it does render high.
#     On page 185 line 4 is a yeh that has both this one and the shadda/fatha,
#     where in the original the one is rendered below, and the other above the letter.
#     In Unicode they end up both in a high position.
# [7] In the original, the sukun tops the alef and the hamza tops the sukun.
#     In Unicode, it&#39;s the otherway round: the hamza tops the alif and the sukun is
#     at the top.
# [9] Singular case on page 45 line 9 char 90 : a final tah inside a word
# [10] as in Allah. The shadda and alef superscript are filled in by the unicode
#      algorithm.
# [11] as in Allah, but with fatha instead of shadda. Probaly a typo in a note,
#      page 12 second last line.
&#34;&#34;&#34;
&#34;&#34;&#34;Character replace rules

There are two parts: (1) character replace rules (2) notes.

Each rule consists of a left hand side, then `=&gt;`, then a right hand side,
then `:` and then a short description.
The short description may contain references to notes in the notes section,
which is a list of commented lines at the end of the whole string.

The left and right hand sides consist of one or more hexadecimal character codes,
joined by the `+` sign.

The meaning is that when the left hand side matches a portion of the input text,
the output text, which is otherwise a copy of the input text, will have that portion
replaced by the right hand side.

The exact application of rules has some subtleties which will be dealt with
in `Laknawi.trimLine`.
&#34;&#34;&#34;


def ptRepD(p):
    &#34;&#34;&#34;Represent a float as an integer with enhanced precision.

    Parameters
    ----------
    p: float
        We multiply it by 10, then round it to the nearest integer.
        A none value is converted to `?`.
    &#34;&#34;&#34;

    return &#34;?&#34; if p is None else int(round(p * 10))


def ptRep(p):
    &#34;&#34;&#34;Represent a float as an integer.

    Parameters
    ----------
    p: float
        We round it to the nearest integer.
        A none value is converted to `?`.
    &#34;&#34;&#34;

    return &#34;?&#34; if p is None else int(round(p))


REPLACE_RE = re.compile(r&#34;&#34;&#34;^([0-9a-z+]+)\s*=&gt;\s*([0-9a-z+]*)\s*:\s*(.*)$&#34;&#34;&#34;, re.I)


LETTER_CODE_DEF = dict(
    d=(1, &#34;diacritic&#34;),
)
&#34;&#34;&#34;Defines place holder `d` in rule definitions.
&#34;&#34;&#34;


LETTER_CODE = {cd: info[0] for (cd, info) in LETTER_CODE_DEF.items()}
CODE_LETTER = {info[0]: cd for (cd, info) in LETTER_CODE_DEF.items()}
LETTER_KIND = {info[0]: info[1] for info in LETTER_CODE_DEF.values()}


def getDictFromDef(defs):
    &#34;&#34;&#34;Interpret a string as a dictionary.

    Parameters
    ----------
    defs: string
        A string containing definitions of character replace rules.

    !!! note &#34;Only for rules&#34;
        We only use this functions for the rules in `REPLACE_DEF`.
    &#34;&#34;&#34;

    rules = []
    rn = 0
    good = True

    for (i, line) in enumerate(defs.strip().split(&#34;\n&#34;)):
        parts = line.split(&#34;#&#34;, maxsplit=1)
        if len(parts) &gt; 1:
            line = parts[0]
        line = line.strip()
        if not line:
            continue
        match = REPLACE_RE.match(line)
        if not match:
            print(f&#34;MALFORMED REPLACE DEF @{i}: {line}&#34;)
            good = False
            continue

        rn += 1
        (valStr, replStr, comment) = match.group(1, 2, 3)

        vals = []
        d = None
        for (i, val) in enumerate(valStr.split(&#34;+&#34;)):
            if val in {&#34;d&#34;}:
                if d is not None:
                    print(f&#34;MULTIPLE d in RULE @{i}: rule {rn}: {line}&#34;)
                    good = False
                d = i
                vals.append(LETTER_CODE[val])
            else:
                vals.append(chr(int(val, base=16)))

        repls = []
        e = None
        if replStr:
            for (i, repl) in enumerate(replStr.split(&#34;+&#34;)):
                if repl in {&#34;d&#34;}:
                    if e is not None:
                        print(f&#34;MULTIPLE d in RULE @{i}: rule {rn}: {line}&#34;)
                        good = False
                    e = i
                    repls.append(LETTER_CODE[repl])
                else:
                    repls.append(chr(int(repl, base=16)))

        if d is None and e is not None:
            print(f&#34;d in REPLACEMENT but not in MATCH @[i]: rule {rn}: {line}&#34;)
            good = False

        rules.append((rn, tuple(vals), d, tuple(repls), e))

    if not good:
        return None

    result = {}
    ruleIndex = {}

    for (rn, vals, d, repls, e) in sorted(rules, key=lambda x: (-len(x[1]), str(x[1]))):
        result.setdefault(vals[0], []).append((rn, vals, d, repls, e))
        ruleIndex[rn] = (vals, d, repls, e)

    return (result, ruleIndex)


U_LINE_RE = re.compile(r&#34;&#34;&#34;^U\+([0-9a-f]{4})([0-9a-f ]*)$&#34;&#34;&#34;, re.I)
HEX_RE = re.compile(r&#34;&#34;&#34;^[0-9a-f]{4}$&#34;&#34;&#34;, re.I)
PUA_RE = re.compile(r&#34;&#34;&#34;âŒŠ([^âŒ‹]*)âŒ‹&#34;&#34;&#34;)

RECT = &#34;rect&#34;
COLOR = &#34;color&#34;

FNRULE_WIDTH = 60
&#34;&#34;&#34;Width of the rule that separates body text from footnote text.
&#34;&#34;&#34;

# SPACE_THRESHOLD = 25
SPACE_THRESHOLD = 10
&#34;&#34;&#34;Amount of separation between words.

Character boxes this far apart imply that there is a white space between them.
The unit is 0.1 pixel.
&#34;&#34;&#34;


class Lakhnawi(UChar):
    def __init__(self):
        &#34;&#34;&#34;Text extraction from the Lakhnawi PDF.

        This class makes use of the `fusus.char.UChar` class which
        defines several categories of characters.
        By extending that class, the Lakhnawi class makes use of those categories.
        It also adds specific characters to some of those categories, especially
        the private use characters that occur in the Lakhnawi PDF.

        We use *fitz* (`pip3 install PyMuPDF`) for PDF reading.
        &#34;&#34;&#34;

        super().__init__()

        self.heights = {}
        &#34;&#34;&#34;Heights of characters, indexed by page number.&#34;&#34;&#34;

        self.clusteredHeights = {}
        &#34;&#34;&#34;Clustered heights of characters, indexed by page number.

        The clustered heights correspond to the lines on a page.
        &#34;&#34;&#34;

        self.lines = {}
        &#34;&#34;&#34;Lines as tuples of original character objects, indexed by page number&#34;&#34;&#34;

        self.text = {}
        &#34;&#34;&#34;Lines as tuples of converted character objects, indexed by page number&#34;&#34;&#34;

        self.fnRules = {}
        &#34;&#34;&#34;Vertical positions of footnote lines, indexed by page number&#34;&#34;&#34;

        self.spaces = {}
        &#34;&#34;&#34;Spacing information for each character, indexed by page and line number.

        For character that has space behind it, it gives the index position of that
        character in the line, the amount of space detected,
        and whether this counts as a full white space.
        &#34;&#34;&#34;

        self.columns = {}
        &#34;&#34;&#34;Column information, indexed by page and line number.

        Spaces that are significantly larger than a normal white space
        are interpreted as an emspace, and these are considered as column separators.
        We remember the character positions where this happens plus the amount
        of space in question.

        Columns in the Lakhnawi PDF correspond to *hemistic* poems,
        where lines are divided into two halves, each occupying a column.

        See ![hemistic](images/hemistic.png)

        !!! caution &#34;hemistic poems versus blocks&#34;
            This is very different from blocks (see `fusus.layout`) in OCRed texts,
            where blocks have been detected because of vertical strokes
            that separate columns.

            The reading progress in a hemistic poem is not changed by the
            column division, where as in the case of blocks, reading proceeds
            by reading the complete blocks in order.
        &#34;&#34;&#34;

        self.doubles = {}
        &#34;&#34;&#34;Glyphs with double unicode points.

        Some private use characters have two unicode points assigned to them
        by fonts in the PDF.
        This is the cause that straightforward text extractions deliver
        double occurrences of those letters. Even *fitz* does that.

        We have collected these cases, and choose to use the lower unicode point,
        which is usually an ordinary character, whereas the other is usually a
        related presentational character.

        This dictionary maps the lower character to the higher character.
        &#34;&#34;&#34;

        self.privateLetters = None
        &#34;&#34;&#34;Private-use unicodes that correspond to full letters.&#34;&#34;&#34;

        self.privateDias = None
        &#34;&#34;&#34;Private-use unicodes that correspond to diacritics.&#34;&#34;&#34;

        self.privateSpace = None
        &#34;&#34;&#34;Private-use-unicode used to represent a space.&#34;&#34;&#34;

        self.good = True
        &#34;&#34;&#34;Whether processing is still ok, i.e. no errors encountered.&#34;&#34;&#34;

        self.getCharConfig()

        self.doc = fitz.open(SOURCE)
        &#34;&#34;&#34;A handle to the PDF document, after it has been read by *fitz*.&#34;&#34;&#34;

    def close(self):
        &#34;&#34;&#34;Close the PDF handle, offered by *fitz*.&#34;&#34;&#34;

        self.doc.close()

    def setStyle(self):
        &#34;&#34;&#34;Import the CSS styles into the notebook.

        See `CSS`.
        &#34;&#34;&#34;

        display(HTML(CSS))

    def getCharConfig(self):
        &#34;&#34;&#34;Configure all character information.

        Private-use characters, transformation rules, character categories.
        &#34;&#34;&#34;

        self.privateInfo()
        self.setupRules()
        self.getCharInfo()

    def privateInfo(self):
        &#34;&#34;&#34;Set up additional character categories wrt. private-use characters.

        Several categories will receive additional members from the
        private use characters.
        &#34;&#34;&#34;

        self.privateLetters = getSetFromDef(PRIVATE_LETTERS_DEF)
        self.privateDias = getSetFromDef(PRIVATE_DIAS_DEF)
        self.privateSpace = PRIVATE_SPACE
        self.nospacings |= self.privateDias
        # self.nospacings.add(PRIVATE_TATWEEL)
        self.diacritics |= self.privateDias
        self.diacriticLike |= self.privateDias
        self.arabicLetters = self.arabic - self.privateDias
        self.rls |= self.puas

    def setupRules(self):
        &#34;&#34;&#34;Set up character transformation rules.

        Prepare for counting how much rules will be applied
        when extracting text from pages of the Lakhnawi PDF.
        &#34;&#34;&#34;

        (self.replace, self.ruleIndex) = getDictFromDef(REPLACE_DEF)
        if self.replace is None:
            self.replace = {}
            self.good = False
        self.rulesApplied = collections.defaultdict(collections.Counter)
        for rn in self.ruleIndex:
            self.rulesApplied[rn] = collections.Counter()

    def getCharInfo(self):
        &#34;&#34;&#34;Obtain detailed character information by reading the font report file.

        From this file we read:

        * which are the private use characters?
        * which of them have a double unicode?

        The font file is
        [here](https://github.com/among/fusus/blob/master/ur/Lakhnawi/FontReport-Lakhnawi.pdf).
        &#34;&#34;&#34;

        self.doubles = {}
        self.privates = set()
        doubles = self.doubles
        privates = self.privates
        finalSpace = self.finalSpace
        puas = self.puas

        doc = fitz.open(FONT)

        for page in doc:
            textPage = page.getTextPage()
            data = textPage.extractText()

            for (ln, line) in enumerate(data.split(&#34;\n&#34;)):
                if line.startswith(&#34;U+&#34;):
                    match = U_LINE_RE.match(line)
                    if not match:
                        continue
                    (main, rest) = match.group(1, 2)
                    main = main.lower()
                    nMain = int(main, base=16)
                    cMain = chr(nMain)
                    if cMain in puas:
                        privates.add(cMain)
                        continue
                    if cMain == chr(0):
                        continue
                    second = None
                    rest = rest.replace(&#34; &#34;, &#34;&#34;)
                    if rest:
                        if HEX_RE.match(rest):
                            second = rest.lower()
                    if second:
                        nSecond = int(second, base=16)
                        cSecond = chr(nSecond)
                        if nSecond &gt; nMain:
                            doubles[cMain] = cSecond
                        else:
                            doubles[cSecond] = cMain

        doublesApplied = collections.defaultdict(collections.Counter)
        for d in doubles:
            doublesApplied[d] = collections.Counter()
        self.doublesApplied = doublesApplied

        finalsApplied = collections.defaultdict(collections.Counter)
        for f in finalSpace:
            finalsApplied[f] = collections.Counter()
        self.finalsApplied = finalsApplied

    def plainChar(self, c):
        &#34;&#34;&#34;Show the character code of a character.

        Parameters
        ----------
        c: string
            The character in question, may also be the empty string or
            the integer 1 (diacritic place holder).

        Returns
        -------
        string
            The hexadecimal unicode point of `c`, between `âŒŠ âŒ‹` - brackets.
        &#34;&#34;&#34;

        if c == &#34;&#34;:
            return &#34;âŒŠâŒ‹&#34;
        if c in {1}:
            return CODE_LETTER[c]
        return f&#34;âŒŠ{ord(c):&gt;04x}âŒ‹&#34;

    def plainString(self, s):
        &#34;&#34;&#34;Show the character codes of the characters in a string.

        Parameters
        ----------
        s: string
            The string to show, may be empty, may contain place holders.

        Returns
        -------
        string
            The concatenation of the unicode points of the characters in the string,
            each code point between brackets.

        See also `Lakhnawi.plainChar()`.
        &#34;&#34;&#34;

        return &#34; &#34;.join(self.plainChar(c) for c in s)

    def showChar(self, c):
        &#34;&#34;&#34;Pretty display of a single unicode character.

        We show the character itself and its name (if not a private-use one),
        its hexadecimal code, and we indicate by coloring the kind of
        white space that the character represents (ordinary space or emspace).

        Parameters
        ----------
        c: string
            The character in question, may also be the empty string or
            the integer 1 (diacritic place holder).
        &#34;&#34;&#34;

        if c in {1, 2}:
            return f&#34;&#34;&#34;
&lt;div class=&#34;ch p&#34;&gt;
    &lt;div class=&#34;cn&#34;&gt;{LETTER_KIND[c]}&lt;/div&gt;
&lt;/div&gt;
&#34;&#34;&#34;

        if c == &#34;&#34;:
            extra = &#34;&#34;
            ccode = &#34;&#34;
            crep = &#34;\u00a0&#34;
            cname = &#34;EMPTY&#34;
        else:
            puas = self.puas
            rls = self.rls

            ccode = (
                f&#34;&#34;&#34;&lt;span class=&#34;{&#34;p&#34; if c in puas else &#34;c&#34;}&#34;&gt;{ord(c):&gt;04x}&lt;/span&gt;&#34;&#34;&#34;
            )
            crep = (
                &#34;??&#34;
                if c in puas
                else f&#34;&#34;&#34;&lt;span class=&#34;{&#34;rc&#34; if c in rls else &#34;lc&#34;}&#34;&gt;{c}&#34;&#34;&#34;
            )
            cname = &#34;&#34; if c in puas else f&#34;&#34;&#34;&lt;span class=&#34;c&#34;&gt;{uName(c)}&lt;/span&gt;&#34;&#34;&#34;
            extra = (
                &#34;m&#34; if c == EMSPACE else &#34;s&#34; if c == &#34; &#34; else &#34;&#34;
            )

        return f&#34;&#34;&#34;
&lt;div class=&#34;ch{extra}&#34;&gt;
    &lt;div class=&#34;cn&#34;&gt;{ccode}&lt;/div&gt;
    &lt;div class=&#34;cn&#34;&gt;&lt;span class=&#34;cni&#34;&gt;{crep}&lt;/span&gt;&lt;/div&gt;
    &lt;div class=&#34;cn&#34;&gt;{cname}&lt;/div&gt;
&lt;/div&gt;
&#34;&#34;&#34;

    def showString(self, s, asString=False):
        &#34;&#34;&#34;Pretty display of a string as a series of unicode characters.

        Parameters
        ----------
        s: string
            The string to display, may be empty, may contain place holders.
        asString: boolean, optional `False`
            If True, return the result as an HTML string.

        Returns
        -------
        None | string
            If `asString`, returns an HTML string, otherwise returns None,
            but displays the HTML string.

        See also `Lakhnawi.showChar()`.
        &#34;&#34;&#34;

        shtml = f&#34;&#34;&#34;&lt;span class=&#34;r&#34;&gt;{s}&lt;/span&gt;&#34;&#34;&#34;
        html = &#34;&#34;&#34;&lt;div class=&#34;sr&#34;&gt;&#34;&#34;&#34; + (
            &#34;&#34;.join(self.showChar(c) for c in s) + &#34;&lt;/div&gt;&#34;
        )
        if asString:
            return f&#34;&#34;&#34;&lt;span&gt;{shtml}&lt;/span&gt;{html}&#34;&#34;&#34;

        display(HTML(f&#34;&#34;&#34;&lt;p&gt;{shtml}&lt;/p&gt;{html}&#34;&#34;&#34;))

    def showReplacements(self, rule=None, isApplied=False):
        &#34;&#34;&#34;Show a character conversion rule and how it has been applied.

        Parameters
        ----------
        rule: string|int, optional `None`
            A specification of zero or more rule numbers (see `fusus.lib.parseNums`).
            If None, all rules will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of rules with usage statistics.
        &#34;&#34;&#34;

        ruleIndex = self.ruleIndex
        rulesApplied = self.rulesApplied
        ruleNums = parseNums(rule)
        ruleNums = (
            set(ruleIndex)
            if ruleNums is None
            else sorted(r for r in ruleNums if r in ruleIndex)
        )

        html = []
        totalRules = len(ruleIndex)
        totalApplications = sum(sum(x.values()) for x in rulesApplied.values())
        totalPages = len(set(chain.from_iterable(rulesApplied.values())))
        ruleRep = &#34;rule&#34; + (&#34;&#34; if totalRules == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalRules} {ruleRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (rn, applied) in sorted(
            rulesApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if rn not in ruleNums:
                continue
            (vals, d, repls, e) = ruleIndex[rn]

            valRep = &#34;&#34;.join(self.showChar(c) for c in vals)
            replRep = &#34;&#34;.join(self.showChar(c) for c in repls)
            total = sum(applied.values())
            if isApplied and not applied:
                continue
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;rule {rn}&lt;/th&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{valRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;span class=&#34;lrg&#34;&gt;â‡’&lt;/span&gt;&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{replRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showDoubles(self, double=None):
        &#34;&#34;&#34;Show a character with double entry and how often it occurs.

        See `Lakhnawi.doubles`.

        Parameters
        ----------
        double: char, optional `None`
            A character from the doubles list (`Lakhnawi.doubles`).
            If None, all such characters will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of double-entry characters with occurrence statistics.
        &#34;&#34;&#34;

        doubles = self.doubles
        doublesApplied = self.doublesApplied

        theseDoubles = (
            set(doubles) if double is None else {double} if double in doubles else set()
        )

        html = []
        totalDoubles = len(doubles)
        totalApplications = sum(sum(x.values()) for x in doublesApplied.values())
        totalPages = len(set(chain.from_iterable(doublesApplied.values())))
        doubleRep = &#34;double&#34; + (&#34;&#34; if totalDoubles == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalDoubles} {doubleRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (d, applied) in sorted(
            doublesApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if d not in theseDoubles:
                continue
            e = doubles[d]
            doubleRep = f&#34;{self.showChar(e)} â‡’ {self.showChar(d)}&#34;

            total = sum(applied.values())
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{doubleRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showFinals(self, final=None):
        &#34;&#34;&#34;Show a character with final form and how often it has been replaced.

        Final forms will be normalized to ground forms
        and sometimes a space will be added.

        Parameters
        ----------
        final: char, optional `None`
            A character from the final space list (`fusus.char.UChar.finalSpace`).
            If None, all such characters will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of final space characters with occurrence statistics.
        &#34;&#34;&#34;

        finalSpace = self.finalSpace
        finalsApplied = self.finalsApplied

        theseFinals = (
            finalSpace if final is None else {final} if final in finalSpace else set()
        )

        html = []
        totalFinals = len(finalSpace)
        totalApplications = sum(sum(x.values()) for x in finalsApplied.values())
        totalPages = len(set(chain.from_iterable(finalsApplied.values())))
        finalRep = &#34;final&#34; + (&#34;&#34; if totalFinals == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalFinals} {finalRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (f, applied) in sorted(
            finalsApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if f not in theseFinals:
                continue
            finalRep = self.showChar(f)

            total = sum(applied.values())
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{finalRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showLineHeights(self, pageNumSpec):
        &#34;&#34;&#34;Shows how line heights have been determined.

        The pages can be selected by page numbers.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        &#34;&#34;&#34;

        heights = self.heights
        clusteredHeights = self.clusteredHeights

        for pageNum in self.parsePageNums(pageNumSpec):
            theseHeights = heights[pageNum]
            theseClusteredHeights = clusteredHeights[pageNum]

            print(f&#34;Line heights page {pageNum:&gt;3}&#34;)
            print(&#34;\nraw heights&#34;)
            for k in sorted(theseHeights):
                print(f&#34;{theseHeights[k]:&gt;4} characters @ height {int(round(k)):&gt;4}&#34;)

            print(&#34;line heights&#34;)
            for (ln, kc) in enumerate(sorted(theseClusteredHeights)):
                peak = &#34;, &#34;.join(
                    f&#34;{int(round(k)):&gt;4}&#34; for k in sorted(theseClusteredHeights[kc])
                )
                print(
                    f&#34;line {ln + 1:&gt;2}: &#34;
                    f&#34;{sum(theseHeights[k] for k in theseClusteredHeights[kc]):&gt;4}&#34;
                    f&#34; characters @height {peak}&#34;
                )

    def parsePageNums(self, pageNumSpec):
        &#34;&#34;&#34;Parses a value as one or more page numbers.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            If `None` results in all page numbers.
            If an `int`, it stands for that int.
            If a `string`, it is allowed to be a comma separated list of
            numbers or ranges, where a range is a lower bound and an upper bound
            separated by a `-`.
            If none of these, it should be an iterable of `int` values.

        Returns
        -------
        None | iterable of int
            Depending on the value.
        &#34;&#34;&#34;

        doc = self.doc
        pageNums = (
            list(range(1, len(doc) + 1))
            if not pageNumSpec
            else [pageNumSpec]
            if type(pageNumSpec) is int
            else setFromSpec(pageNumSpec)
            if type(pageNumSpec) is str
            else list(pageNumSpec)
        )
        return [i for i in sorted(pageNums) if 0 &lt; i &lt;= len(doc)]

    def drawPages(self, pageNumSpec, clip=None):
        &#34;&#34;&#34;Draws a (part) of page from the PDF as a raster image.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        clip: (int, int), optional `None`
            If None: produces the whole page.
            Otherwise it is `(top, bottom)`, and a stripe
            from top to bottom will be displayed.
        &#34;&#34;&#34;

        doc = self.doc

        for pageNum in self.parsePageNums(pageNumSpec):
            page = doc[pageNum - 1]
            if clip is not None:
                clip = (0, clip[0], page.rect.width, clip[1])

            pix = page.getPixmap(matrix=fitz.Matrix(4, 4), clip=clip, alpha=False)
            display(HTML(f&#34;&#34;&#34;&lt;p&gt;&lt;b&gt;page {pageNum}&lt;/b&gt;&lt;/p&gt;&#34;&#34;&#34;))
            display(Image(data=pix.getPNGData(), format=DEFAULT_EXTENSION))

    def getPages(
        self,
        pageNumSpec,
        refreshConfig=False,
        doRules=True,
        doFilter=True,
        onlyFnRules=False,
    ):
        &#34;&#34;&#34;Reads pages of the PDF and extracts text.

        This does all of the hard work of the text extraction.
        It saves the textual data in attributes of the Lakhnawi object,
        augmented with all kinds of diagnostic information.

        From all this data, various output representations can be generated
        rather easily by other methods.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        refreshConfig: boolean, optional `False`
            If `True`, rereads all character configuration.
            Ideal when you are iteratively developing the character configuration.
        doRules: boolean, optional `True`
            If `False`, suppresses the application of character transformation
            rules. Mainly used when debugging other aspects of the text extraction.
        doFilter: boolean, optional `True`
            If `False`, suppresses the application of unicode normalization,
            by which presentational characters are transformed into sequences
            of ordinary, basic characters.
            Used for debugging.
        onlyFnRules: boolean, optional `False`
            If `True`, skips most of the conversion.
            Only determine where the footnote rules are.
            Used for debugging.

        Returns
        -------
        None
           The effect is that attributes of the Lakhnawi object
           are filled:

           * `Lakhnawi.heights`
           * `Lakhnawi.clusteredHeights`
           * `Lakhnawi.fnRules`

           For the other attributes, see `Lakhnawi.collectPage()`.

        !!! hint &#34;multiple runs&#34;
            If you do multiple runs of this function for different pages,
            the results will not overwrite each other in general,
            because the attributes hold the results in dictionaries
            keyed by page number.
        &#34;&#34;&#34;

        if not self.good:
            print(&#34;SKIPPING because of config errors&#34;)
            return

        fnRules = self.fnRules
        spaces = self.spaces
        columns = self.columns

        self.doRules = doRules
        self.doFilter = doFilter

        ruleIndex = self.ruleIndex
        rulesApplied = self.rulesApplied

        if refreshConfig:
            self.getCharConfig()

        for rn in ruleIndex:
            rulesApplied[rn] = collections.Counter()

        for (i, pageNum) in enumerate(self.parsePageNums(pageNumSpec)):
            self.pageNum = pageNum
            rep = (
                f&#34;{i + 1:&gt;4} (page {pageNum:&gt;4})&#34;
                if pageNum != i + 1
                else (f&#34;{i + 1:&gt;4}&#34; + &#34; &#34; * 12)
            )
            sys.stdout.write(f&#34;\r\t{rep}&#34;)
            sys.stdout.flush()
            doc = self.doc
            page = doc[pageNum - 1]

            theseFnRules = set()

            for fnRule in page.getDrawings():
                if RECT in fnRule and fnRule.get(COLOR, None):
                    rect = fnRule[RECT]
                    width = rect.x1 - rect.x0
                    if width &gt; FNRULE_WIDTH:
                        theseFnRules.add(int(round(rect.y1)))

            fnRules[pageNum] = tuple(sorted(theseFnRules))
            spaces[pageNum] = {}
            columns[pageNum] = {}

            if onlyFnRules:
                continue

            textPage = page.getTextPage()
            data = textPage.extractRAWDICT()
            self.collectPage(data)

    def getPageRaw(self, pageNum):
        &#34;&#34;&#34;Do a rough/raw text extract of a specific page.

        The *fitz* method
        [extractRAWDICT()](https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT)
        is used to obtain very detailed information about each character on that page.
        Used for debugging.

        Parameters
        ----------
        pageNum: int
            A valid page number.
            It is the sequence number of the page within the PDF, counting from 1.

        Returns
        -------
        None
            It pretty prints the output of the fitz method, which is a big
            and deep dictionary.
        &#34;&#34;&#34;

        self.pageNum = pageNum
        rep = f&#34;page {pageNum:&gt;4}&#34;
        sys.stdout.write(f&#34;{rep}&#34;)
        sys.stdout.flush()
        doc = self.doc
        page = doc[pageNum - 1]

        textPage = page.getTextPage()
        data = textPage.extractRAWDICT()
        pprint(data)

    def getPageObj(self, pageNum):
        &#34;&#34;&#34;Get the *fitz* object for a specific page.

        Used for debugging.

        Parameters
        ----------
        pageNum: int
            A valid page number.
            It is the sequence number of the page within the PDF, counting from 1.

        Returns
        -------
        object
            A *fitz*
            [page object](https://pymupdf.readthedocs.io/en/latest/page.html)
        &#34;&#34;&#34;

        self.pageNum = pageNum
        doc = self.doc
        return doc[pageNum - 1]

    def plainPages(self, pageNumSpec):
        &#34;&#34;&#34;Outputs processed pages as plain text.

        Uses `Lakhnawi.plainLine()`.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.

        Returns
        -------
        None
            The plain text is printed to the output.
        &#34;&#34;&#34;

        text = self.text

        for pageNum in self.parsePageNums(pageNumSpec):
            lines = text.get(pageNum, [])

            for (i, line) in enumerate(lines):
                print(self.plainLine(line))

    def tsvPages(self, pageNumSpec):
        &#34;&#34;&#34;Outputs processed pages as tab-separated data.

        See `fusus.convert` for the details of the output format.

        Uses
        `Lakhnawi.tsvLine()`.
        and `Lakhnawi.tsvHeadLine()`.


        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.

        Returns
        -------
        None
            The tab-separated data is written to a single tsv file.
            There is a heading row.

            The file is in `fusus.parameters.UR_DIR`, under `Lakhnawi`.
            The name of the file includes a page specification.
        &#34;&#34;&#34;

        text = self.text

        destDir = f&#34;{UR_DIR}/{NAME}&#34;
        pageNums = self.parsePageNums(pageNumSpec)

        if not os.path.exists(destDir):
            os.makedirs(destDir, exist_ok=True)

        pageNumRep = ALL_PAGES if pageNumSpec is None else str(pageNumSpec)
        filePath = f&#34;{destDir}/{pageNumRep}.tsv&#34;
        fh = open(filePath, &#34;w&#34;)
        fh.write(self.tsvHeadLine())

        for pageNum in pageNums:
            lines = text.get(pageNum, [])

            for (ln, line) in enumerate(lines):
                fh.write(self.tsvLine(line, pageNum, ln + 1))

        fh.close()
        print(f&#34;TSV data written to {unexpanduser(filePath)}&#34;)

    def htmlPages(
        self,
        pageNumSpec,
        line=None,
        showSpaces=False,
        export=False,
        singleFile=False,
        toc=False,
    ):
        &#34;&#34;&#34;Outputs processed pages as formatted HTML pages.

        Uses
        `Lakhnawi.htmlLine()`.

        The HTML output is suitable to read the extracted text.
        Its layout matches the original closely, which makes it easier
        to see where the output deviates from the source page.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).
        showSpaces: boolean, optional `False`
            If `True`, shows the spaces with a conspicuous coloured background.
        export: boolean, optional `False`
            If `True`, writes the HTML results to disk.
            In this case, the HTML will not be displayed in the notebook.
        singleFile: boolean, optional `False`
            Only meaningful is `export=True`.
            If `True`, writes the output to a single HTML file,
            otherwise to one file per page, in a directory called `html`.
        toc: boolean, optional `False`
            Only meaningful is `export=True` and `singleFile=True`.
            If `True`, writes a table of contents to the file.
            The TOC points to every page that is included in the output file.

        Returns
        -------
        None
            Depending on `export`, the page is displayed in the notebook
            where this function is called, or exported to a file on disk.

            The file is in `fusus.parameters.UR_DIR`, under `Lakhnawi`.
            The name of the file includes a page specification.
        &#34;&#34;&#34;

        self.showSpaces = showSpaces
        text = self.text

        destDir = f&#34;{UR_DIR}/{NAME}&#34; if singleFile else f&#34;{UR_DIR}/{NAME}/html&#34;
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)
        lineNums = None if lineNums is None else set(lineNums)
        filesWritten = 0

        if export:
            if not os.path.exists(destDir):
                os.makedirs(destDir, exist_ok=True)
            if singleFile:
                pageNumRep = ALL_PAGES if pageNumSpec is None else str(pageNumSpec)
                tocRep = &#34;-with-toc&#34; if toc else &#34;&#34;
                filePath = f&#34;{destDir}/{pageNumRep}{tocRep}.html&#34;
                fh = open(filePath, &#34;w&#34;)
                fh.write(preHtml(f&#34;{pageNumRep}{tocRep}&#34;))
                if toc:
                    toc = getToc(pageNums)
                    fh.write(
                        f&#34;&#34;&#34;
&lt;div class=&#34;window&#34;&gt;
&lt;div class=&#34;sidebar&#34;&gt;
{toc}
&lt;/div&gt;
&lt;div class=&#34;pages bypage&#34;&gt;
&#34;&#34;&#34;
                    )
                else:
                    fh.write(
                        &#34;&#34;&#34;
&lt;div class=&#34;pages&#34;&gt;
&#34;&#34;&#34;
                    )

        pageClass = &#34;page&#34; + (&#34;&#34; if export else &#34;c&#34;)
        for pageNum in pageNums:
            lines = text.get(pageNum, [])
            nLines = len(lines)

            html = []
            html.append(
                f&#34;&#34;&#34;
&lt;div class=&#34;{pageClass}&#34;&gt;
&lt;div class=&#34;phead&#34;&gt;&lt;a name=&#34;p{pageNum:&gt;03}&#34;&gt;{pageNum}&lt;/a&gt;&lt;/div&gt;
&#34;&#34;&#34;
            )

            prevMulti = False

            for (i, line) in enumerate(lines):
                if lineNums is not None and i + 1 not in lineNums:
                    continue

                html.append(self.htmlLine(line, prevMulti, i == nLines - 1))
                prevMulti = len(line) &gt; 1

            html.append(&#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;)

            if export:
                htmlRep = &#34;&#34;.join(html)

                if singleFile:
                    fh.write(htmlRep)
                else:
                    html = preHtml(pageNum) + htmlRep + POST_HTML
                    filePath = f&#34;{destDir}/p{pageNum:&gt;03}.html&#34;
                    with open(filePath, &#34;w&#34;) as fh:
                        fh.write(html)
                        filesWritten += 1
            else:
                display(HTML(&#34;\n&#34;.join(html)))

        if export and singleFile:
            fh.write(
                &#34;&#34;&#34;
&lt;/div&gt;
&#34;&#34;&#34;
            )
            if toc:
                fh.write(
                    &#34;&#34;&#34;
    &lt;/div&gt;
    &#34;&#34;&#34;
                )
            fh.write(POST_HTML)
            fh.close()
            print(f&#34;HTML written to {unexpanduser(filePath)}&#34;)

        if export and not singleFile:
            print(f&#34;{filesWritten} HTML files written to {unexpanduser(destDir)}/&#34;)

    def showLines(
        self,
        pageNumSpec,
        line=None,
        start=None,
        end=None,
        search=None,
        orig=False,
        every=False,
    ):
        &#34;&#34;&#34;Outputs processed lines as a formatted HTML table.

        The lines can be selected by page numbers and line numbers.

        Within the selected lines, the characters can be selected by
        start/end postions, or by characters of interest.

        All of these indices start at 1.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).
        start: integer, optional `None`
            Starting word position in each line to be output.
            If `None`, starts at the beginning of each line.
        end: integer, optional `None`
            End word position in each line to be output.
            If `None`, ends at the end of each line.
        search: string or iterable of char, optional `None`
            If not none, all characters in `search` are deemed interesting.
            All occurrences of these characters within the selected lines are
            displayed, included a small context.
        orig: boolean, optional `False`
            Only meaningful if `search` is given.
            If `True`: the check for interesting
            characters is done in the original, untranslated characters.
            Otherwise, interesting characters are looked up in the translated
            characters.
        every: boolean, optional `False`
            Only meaningful if `search` is given.
            If `True`, when looking for interesting characters, all occurrences will
            be retrieved, otherwise only the first one.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        lines = self.lines
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)

        myLines = {pageNum: lines[pageNum] for pageNum in pageNums if pageNum in lines}

        html = []
        html.append(&#34;&lt;table&gt;&#34;)
        html.append(
            &#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;seq&lt;/th&gt;
    &lt;th&gt;top&lt;/th&gt;
    &lt;th&gt;bottom&lt;/th&gt;
    &lt;th&gt;left&lt;/th&gt;
    &lt;th&gt;right&lt;/th&gt;
    &lt;th&gt;spacing&lt;/th&gt;
    &lt;th&gt;font&lt;/th&gt;
    &lt;th&gt;size&lt;/th&gt;
    &lt;th&gt;orig char&lt;/th&gt;
    &lt;th&gt;char&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
        )

        shift = 5

        for (pageNum, pageLines) in myLines.items():
            myLineNums = (
                range(1, len(pageLines) + 1)
                if lineNums is None
                else [ln for ln in lineNums if 0 &lt; ln &lt;= len(pageLines)]
            )
            for ln in myLineNums:
                chars = pageLines[ln - 1]
                nChars = len(chars)
                html.append(
                    f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;th colspan=3&gt;page {pageNum}&lt;/th&gt;
    &lt;th colspan=2&gt;line {ln}&lt;/th&gt;
    &lt;th colspan=3&gt;{nChars} characters&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                )
                if search is None:
                    ranges = [(max((start or 0) - 1, 0), min(end or nChars, nChars))]
                else:
                    ranges = []

                    for (i, char) in enumerate(chars):
                        if search in char[-2 if orig else -1]:
                            occStart = max((i - shift, 0))
                            occEnd = min((i + shift + 1, nChars))
                            if ranges and occStart &lt;= ranges[-1][1]:
                                ranges[-1][1] = occEnd
                            else:
                                ranges.append([occStart, occEnd])
                            if not every:
                                break

                for (occStart, occEnd) in ranges:
                    for i in range(occStart, occEnd):
                        char = chars[i]
                        (le, to, ri, bo, font, size, spacing, oc, c) = char
                        html.append(
                            f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;{i + 1}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;{ptRepD(to)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(bo)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(le)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(ri)}&lt;/td&gt;
    &lt;td&gt;{spacing}&lt;/td&gt;
    &lt;td&gt;{font}&lt;/td&gt;
    &lt;td&gt;{size}pt&lt;/td&gt;
    &lt;td&gt;{&#34;&#34;.join(self.showChar(x) for x in reversed(oc))}&lt;/td&gt;
    &lt;td&gt;{&#34;&#34;.join(self.showChar(x) for x in reversed(c))}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                        )
                if search and ranges and not every:
                    break

        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showWords(self, pageNumSpec, line=None):
        &#34;&#34;&#34;Outputs processed words as a formatted HTML table.

        The lines can be selected by page numbers and line numbers.

        All words within the selected lines are put into a table with
        the same properties as in the TSV data,
        see `Lakhnawi.tsvPages`.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        text = self.text
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)

        myLines = {pageNum: text[pageNum] for pageNum in pageNums if pageNum in text}

        html = []
        html.append(&#34;&lt;table&gt;&#34;)
        html.append(
            &#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;page&lt;/th&gt;
    &lt;th&gt;line&lt;/th&gt;
    &lt;th&gt;col&lt;/th&gt;
    &lt;th&gt;span&lt;/th&gt;
    &lt;th&gt;dir&lt;/th&gt;
    &lt;th&gt;left&lt;/th&gt;
    &lt;th&gt;top&lt;/th&gt;
    &lt;th&gt;right&lt;/th&gt;
    &lt;th&gt;bottom&lt;/th&gt;
    &lt;th&gt;letters&lt;/th&gt;
    &lt;th&gt;punc&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
        )

        for (pageNum, pageLines) in myLines.items():
            myLineNums = (
                range(1, len(pageLines) + 1)
                if lineNums is None
                else [ln for ln in lineNums if 0 &lt; ln &lt;= len(pageLines)]
            )
            for ln in myLineNums:
                cols = pageLines[ln - 1]
                for (cn, spans) in enumerate(cols):
                    for (sn, (dr, words)) in enumerate(spans):
                        for (letters, punc, (le, to, ri, bo)) in words:
                            html.append(
                                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;{pageNum}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;{ln}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{cn + 1}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{sn + 1}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{dr}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;{ptRep(le)}&lt;/td&gt;
    &lt;td&gt;{ptRep(to)}&lt;/td&gt;
    &lt;td&gt;{ptRep(ri)}&lt;/td&gt;
    &lt;td&gt;{ptRep(bo)}&lt;/td&gt;
    &lt;td&gt;{self.showString(letters, asString=True)}&lt;/td&gt;
    &lt;td&gt;{self.showString(punc, asString=True)}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                            )

        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showUsedChars(
        self,
        pageNumSpec,
        orig=False,
        onlyPuas=False,
        onlyPresentational=False,
        long=False,
        byOcc=False,
    ):
        &#34;&#34;&#34;Show used characters.

        Gives an overview of character usage, either in the input PDF, or in
        the text output.


        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        orig: boolean, optional `False`
            If `True`: shows characters of the original PDF.
            Otherwise, shows characters of the translated output/
        onlyPuas: boolean, optional `False`
            If `True`, the result is restricted to private use characters.
        onlyPresentational: boolean, optional `False`
            If `True`, the result is restricted to presentational characters.
            See `fusus.char.UChar.presentational`.
        long: boolean, optional `False`
            If `True`, for each character output the complete list of pages
            where the character occurs. Otherwise, show only the most
            prominent pages.
        byOcc: boolean, optional `False`
            If `True`, sort the results by first occurrence of the characters.
            Otherwise, sort the results by unicode code point of the character.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        presentational = self.presentational
        pageNums = self.parsePageNums(pageNumSpec)
        text = self.text
        lines = self.lines
        puas = self.puas

        charsOut = collections.defaultdict(collections.Counter)

        def keyByOcc(c):
            pageNums = charsOut[c]
            return -sum(pageNums.values())

        sortKey = keyByOcc if byOcc else lambda x: x

        if orig:
            lns = {pageNum: lines[pageNum] for pageNum in pageNums if pageNum in lines}

            for (pageNum, pageLines) in lns.items():
                for line in pageLines:
                    for char in line:
                        c = char[-2]
                        if c in puas or (
                            not onlyPuas
                            and (c in presentational or not onlyPresentational)
                        ):
                            charsOut[c][pageNum] += 1

        else:
            texts = {pageNum: text[pageNum] for pageNum in pageNums if pageNum in text}

            for (pageNum, pageText) in texts.items():
                for line in pageText:
                    for col in line:
                        for span in col:
                            for word in span[1]:
                                letters = word[0]
                                punc = word[1]
                                thesePuas = PUA_RE.findall(letters)
                                for pua in thesePuas:
                                    charsOut[chr(int(pua, base=16))][pageNum] += 1
                                if not onlyPuas:
                                    rest = PUA_RE.sub(&#34;&#34;, f&#34;{letters}{punc}&#34;)
                                    for c in rest:
                                        if not (
                                            onlyPresentational
                                            and c not in presentational
                                        ):
                                            charsOut[c][pageNum] += 1

        totalChars = len(charsOut)
        totalPages = len(set(chain.from_iterable(charsOut.values())))
        totalOccs = sum(sum(pns.values()) for pns in charsOut.values())

        charRep = &#34;character&#34; + (&#34;&#34; if totalChars == 1 else &#34;s&#34;)
        occRep = &#34;occurence&#34; + (&#34;&#34; if totalOccs == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)

        label = &#34;private use &#34; if onlyPuas else &#34;&#34;

        html = []
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalChars} {label}{charRep} in {totalOccs} {occRep}
on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for c in sorted(charsOut, key=sortKey):
            pageNums = charsOut[c]
            nPageNums = len(pageNums)
            pageRep = &#34;page&#34; + (&#34;&#34; if nPageNums == 1 else &#34;s&#34;)
            thistotal = sum(pageNums.values())
            examplePageNum = sorted(pageNums, key=lambda p: -pageNums[p])[0]
            nExamples = pageNums[examplePageNum]
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{self.showChar(c)}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;b&gt;{thistotal}&lt;/b&gt; on &lt;i&gt;{nPageNums}&lt;/i&gt; {pageRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;e.g. page {examplePageNum} with &lt;b&gt;{nExamples}&lt;/b&gt; occurrences&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )
            if long:
                for pn in sorted(pageNums):
                    occs = pageNums[pn]
                    html.append(
                        f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;i&gt;page {pn:&gt;3}&lt;/i&gt;: &lt;b&gt;{occs:&gt;3}&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                    )
        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showColumns(self, pageNumSpec):
        &#34;&#34;&#34;Show used characters.

        Gives an overview of the columns in each line.
        The result is a readable, ascii overview of the columns
        that exists in the lines of the selected pages.

        It is useful to visually check column detection for many pages.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        pageNums = self.parsePageNums(pageNumSpec)

        columns = self.columns
        for pageNum in pageNums:
            if pageNum not in columns:
                continue
            lineInfo = columns[pageNum]
            multiple = []
            for lNum in sorted(lineInfo):
                (threshold, emspaces) = lineInfo[lNum]
                nEmspaces = len(emspaces)
                if threshold is not None and nEmspaces &gt; 0:
                    multiple.append((lNum, threshold, emspaces))
            if not len(multiple):
                print(f&#34;page {pageNum:&gt;3} -&#34;)
            else:
                print(f&#34;page {pageNum:&gt;3}:&#34;)
                for (lNum, threshold, emspaces) in multiple:
                    nEmspaces = len(emspaces)
                    print(f&#34;\t{lNum:&gt;2}: {&#39;- &#39; * (nEmspaces + 1)}&#34;)

    def showSpacing(self, pageNumSpec, line=None):
        &#34;&#34;&#34;Show where the spaces are.

        Gives an overview of the white space positions in each line.

        It is useful to debug the horizontal white space algorithm.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)
        lineNums = None if lineNums is None else set(lineNums)

        spaces = self.spaces

        for pageNum in pageNums:
            if pageNum not in spaces:
                continue

            print(f&#34;page {pageNum:&gt;3}&#34;)
            lineInfo = spaces[pageNum]

            for (ln, spaces) in lineInfo.items():
                if lineNums is not None and ln not in lineNums:
                    continue

                print(f&#34;\tline {ln:&gt;2}&#34;)

                for (i, after, isSpace) in spaces:
                    print(f&#34;\t\t{i + 1:&gt;3} {&#39;]  [&#39; if isSpace else &#39;]==[&#39;} {after}&#34;)

    def collectPage(self, data):
        &#34;&#34;&#34;Transforms raw text into proper textual data.

        Called by `Lakhnawi.getPages()` and delivers its results
        to attributes of the Lakhnawi object.

        Here are they

        * `Lakhnawi.lines`
        * `Lakhnawi.doubles`
        * `Lakhnawi.text`

        They are all dictionaries, keyed by page number first and then by line.

        Parameters
        ----------
        data: dict
            as obtained by the
            [extractRAWDICT()](https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT)
            method of *fitz*.

        Returns
        -------
        None
        &#34;&#34;&#34;

        doubles = self.doubles
        doublesApplied = self.doublesApplied
        pageNum = self.pageNum
        nospacings = self.nospacings
        fnRules = self.fnRules
        bracketMap = self.bracketMap
        text = self.text

        fnRule = fnRules.get(pageNum, None)
        fnRule = fnRule[0] if fnRule else None

        chars = []
        prevChar = None
        prevFont = None
        prevSize = None

        def addChar():
            box = prevChar[&#34;bbox&#34;]
            yBot = box[3]

            # skip chars below the footnote rule, if any
            if fnRule is not None and yBot &gt; fnRule:
                return

            c = prevChar[&#34;c&#34;]

            cr = &#34;&#34; if isEuDigit(c) else c
            cr = bracketMap.get(cr, cr)

            chars.append(
                (
                    *box,
                    prevFont,
                    prevSize,
                    &#34;&#34; if c in nospacings else True,
                    c,
                    cr,
                )
            )

        def collectChars(data, font, size):
            nonlocal prevChar
            nonlocal prevFont
            nonlocal prevSize

            if type(data) is list:
                for elem in data:
                    collectChars(elem, font, size)

            elif type(data) is dict:
                if &#34;font&#34; in data:
                    font = data[&#34;font&#34;]
                if &#34;size&#34; in data:
                    size = data[&#34;size&#34;]
                if &#34;c&#34; in data:
                    c = data[&#34;c&#34;]
                    skip = False
                    if c == &#34; &#34;:
                        skip = True

                    if prevChar is not None:
                        pc = prevChar[&#34;c&#34;]
                        if pc in doubles and doubles[pc] == c:
                            skip = True
                            doublesApplied[pc][pageNum] += 1
                        if c in doubles and doubles[c] == pc:
                            prevChar = data
                            skip = True
                            doublesApplied[c][pageNum] += 1

                    if not skip:
                        if prevChar is not None:
                            addChar()
                        prevChar = data
                        prevFont = font
                        prevSize = size

                for (k, v) in data.items():
                    if type(v) in {list, dict}:
                        collectChars(v, font, size)

        collectChars(data, None, None)
        if prevChar is not None:
            addChar()

        clusterKeyCharV = self.clusterVert(chars)
        lines = {}
        for char in sorted(chars, key=lambda c: (clusterKeyCharV(c), keyCharH(c))):
            k = clusterKeyCharV(char)
            lines.setdefault(k, []).append(list(char))

        theseLines = list(lines.values())
        if theseLines and self.isPageNum(theseLines[0]):
            theseLines = theseLines[1:]

        # remove arabic numerals between brackets

        for chars in theseLines:
            nChars = len(chars)
            if not nChars:
                continue

            i = 0

            while i &lt; nChars:
                char = chars[i]
                nextI = i + 1
                if char[-1] == &#34;(&#34;:
                    found = None
                    for j in range(i + 1, nChars):
                        theChar = chars[j][-1]
                        if theChar == &#34;)&#34;:
                            found = j + 1
                            nextI = found
                            break
                        if isArDigit(theChar):
                            continue
                        nextI = j
                        break
                    if found is not None:
                        for j in range(i, found):
                            chars[j][-1] = &#34;&#34;
                        i = found
                i = nextI

        self.lines[pageNum] = tuple(
            chars for chars in theseLines if not all(c[-1] == &#34;&#34; for c in chars)
        )

        text[pageNum] = []
        for (ln, line) in enumerate(self.lines[pageNum]):
            self.trimLine(pageNum, ln + 1, line)

    def isPageNum(self, chars):
        &#34;&#34;&#34;Checks whether a series of characters represents an arabic number.

        Parameters
        ----------
        chars: iterable of char reocrds
        &#34;&#34;&#34;

        return 1 &lt;= len(chars) &lt;= 3 and all(isArDigit(c[-1]) for c in chars)

    def trimLine(self, pageNum, ln, chars):
        &#34;&#34;&#34;Map character sequences to other sequences.

        Two tasks:

        1. Map private use characters to well-known unicode characters
        2. Insert space characters where the next character is separated from the
           previous one.

        Complications:

        Diacritical characters are mostly contained in a very wide box that overlaps
        with the boxes of the other characters. So the diacritical boxes must not be
        taken into account.

        Private use characters often come in sequences, so a sequence of characters
        must be transformed to another sequence.

        We do the tramsformation before the space insertion, because otherwise we
        might insert the space at the wrong point.

        When we transform characters we need to retain the box information,
        because we still have to insert the space.

        That&#39;s why we have as input a list of character records, where each record
        is itself a list with box information, orginal character, modified characters
        and space information.

        When we transform characters, we modify character records in place.
        We do not add or remove character records.

        The last member of a character record is the modified sequence.
        This can be zero, one, or multiple characters.
        The second last member is the original character.
        Initially, the the last and second last member of each record are equal.
        We call these members the original character and the result string.

        Space will be appended at the last member of the appropriate character records.

        The transformations are given as a set of rules.

        See `REPLACE_DEFS`.

        A rule consists of a sequence of characters to match and a sequence of
        characters to replace the match with. We call them the match sequence and the
        replacement sequence of the rule.

        For each character in the input list we check which rules have a match sequence
        that start with this character.
        Of these rules, we start with the one with the longest match sequence.
        We then check, by looking ahead, whether the whole match sequence matches the
        input.
        For the purposes of matching, we look into the result strings of the character,
        not to the original characters. This will prevent some rules to be applied
        after an earlier rule has been applied. This is intentional, and results
        in a more simple rule set.

        If there is a match, we walk through all the characters in the input for the
        length of the match sequence of the rule.
        For each input character record, we set its replacement string to the
        corresponding member of the replacement sequence of the rule.
        If the replacement sequence has run out, we replace with the empty string.
        If after this process the replacement sequence has not been exhausted,
        we join the remaining characters in the replacement string and append it
        after the replacement string of the last input character that we have visited.

        After succesful application of a rule, we do not apply other rules that would
        have been applicable at this point. Instead, we move our starting point to the
        next character record in the sequence and repeat the matching process.

        It might be that a character is replaced multiple times, for example when
        it is reached by a rule while looking ahead 3 places, and then later by a
        different rule looking ahead two places.

        However, once a character matches the first member of the match sequence of
        a rule, and the rule matches and is applied, that character will not be
        changed anymore by any other rule.

        !!! caution &#34;place holders for diacritics&#34;
            The following functionality exists in the code, but is not needed anymore
            to process the Lakhnawi PDF.

            The match sequence may contain the character `d`, which is a placeholder
            for a diacritic sign. It will match any diacritic.
            The replacement sequence of such a rule may or may not contain a `d`.
            It is an error if the replacement seqience of a rule contains a `d` while
            its match sequence does not.
            It is also an error of there are multiple `d`s in a match sequence
            of a replacement sequence.
            If so, the working of this rule is effectively two rules:

            Suppose the rule is

            x d y =&gt; r d s

            where x, y, r, s are sequences of arbitrary length.
            If the rule matches the input, then first the rule

            x =&gt; r

            will be applied at the current position.

            Then we shift temporarily to the position right after where the d has matched,
            and apply the rule

            y =&gt; s

            Then we shift back to the orginal position plus one, and continue applying
            rules.
        &#34;&#34;&#34;

        replace = self.replace
        puas = self.puas
        neutrals = self.neutrals
        rls = self.rls
        rulesApplied = self.rulesApplied
        spaces = self.spaces
        columns = self.columns
        diacritics = self.diacritics
        punct = self.punct
        diacriticLike = self.diacriticLike
        arabicLetters = self.arabicLetters
        presentationalC = self.presentationalC
        presentationalD = self.presentationalD
        finalSpace = self.finalSpace
        finalsApplied = self.finalsApplied
        nonLetter = self.nonLetter
        doRules = self.doRules
        doFilter = self.doFilter

        nChars = len(chars)

        # rule application stage

        if doRules:
            for (i, char) in enumerate(chars):
                c = char[-1]

                if c in replace:
                    rules = replace[c]
                    for (rn, vals, d, repls, e) in rules:

                        nVals = len(vals)

                        if i + nVals &gt; nChars:
                            # not enough characters left to match this rule
                            continue

                        if not all(
                            (
                                d is not None
                                and j == d
                                and chars[i + j][-1]
                                in (diacritics if vals[d] == 1 else arabicLetters)
                            )
                            or chars[i + j][-1] == vals[j]
                            for j in range(nVals)
                        ):
                            # the rule does not match after all
                            continue

                        # the rule matches: we are going to fill in the replacements
                        # if there is a diacritic in the match sequence or the
                        # replacement sequence, we restrict ourselves to the parts
                        # before the diacritics.

                        rulesApplied[rn][pageNum] += 1

                        nRepls = len(repls)
                        dEnd = nVals if d is None else d
                        eEnd = nRepls if e is None else e

                        # so, we are going to replace from here to dEnd (not including)

                        for j in range(dEnd):
                            # put the appropriate replacement character in the
                            # replacement part of the character record
                            # After running out of replacement characters, put in &#34;&#34;
                            chars[i + j][-1] = repls[j] if j &lt; eEnd else &#34;&#34;

                        if eEnd &gt; dEnd:
                            # if there are replacement characters left, put them
                            # in after the last character that we have visited.

                            if dEnd == 0:
                                # In case we have not visited any yet,
                                # we put them in before the current character
                                cd = chars[i + dEnd][-1]
                                r = &#34;&#34;.join(repls[dEnd + 1 :])
                                chars[i + dEnd][-1] = f&#34;{r}{cd}&#34;
                            else:
                                # this is the normal case
                                chars[i + dEnd - 1][-1] += &#34;&#34;.join(repls[dEnd:eEnd])

                        # if there is a diacritic in the match sequence
                        # we are going to perform the rule for the part
                        # after the diacritic

                        # Note that the case where d is None and e is not None
                        # does not occur

                        if d is not None:
                            # we set the starting points: just after the diacritics
                            dStart = d + 1
                            # if the replacement part does not have a diacritic,
                            # we have already consumed it, and we start right after it
                            eStart = nRepls if e is None else e + 1

                            # we compute the number of characters that still need to be
                            # matched and to be replaced
                            dn = nVals - dStart
                            en = nRepls - eStart

                            # we perform the replacement analogously to what we did
                            # for the first part

                            for j in range(dn):
                                # put the appropriate replacement character in the
                                # replacement part of the character record
                                # After running out of replacement characters, put in &#34;&#34;
                                chars[i + dStart + j][-1] = (
                                    repls[eStart + j] if eStart + j &lt; nRepls else &#34;&#34;
                                )
                            if en &gt; dn:
                                # if there are replacement characters left, put them
                                # in after the last character that we have visited.
                                chars[i + nVals - 1][-1] += &#34;&#34;.join(
                                    repls[eStart + dn :]
                                )
                        break

        # sift out all presentational characters

        if doFilter:
            trailSpace = False

            for (i, char) in enumerate(chars):
                c = char[-1]
                string = &#34;&#34;
                for x in c:
                    if trailSpace:
                        if x not in diacriticLike:
                            if x not in nonLetter:
                                if string == &#34;&#34; and i &gt; 0:
                                    chars[i - 1][-1] += &#34; &#34;
                                else:
                                    string += &#34; &#34;
                            trailSpace = False

                    hasFinalSpace = x in finalSpace
                    y = (
                        normalizeC(x)
                        if x in presentationalC
                        else normalizeD(x)
                        if x in presentationalD
                        else x
                    ).strip()
                    space = &#34; &#34; if hasFinalSpace or x in punct else &#34;&#34;
                    if hasFinalSpace:
                        finalsApplied[x][pageNum] += 1
                    string += y
                    if space:
                        trailSpace = True
                char[-1] = string

            if trailSpace:
                if chars:
                    chars[-1][-1] += &#34; &#34;

        # add horizontal spacing

        theseSpaces = []
        spaces[pageNum][ln] = theseSpaces

        threshold = None
        theseColumns = [threshold, []]
        columns[pageNum][ln] = theseColumns

        prevLeft = None
        prevLeftI = None

        for (i, char) in enumerate(chars):
            spacing = char[-3]

            if spacing:
                left = char[0]
                right = char[2]

                if prevLeft is not None:
                    prevChar = chars[prevLeftI]
                    after = prevLeft - right
                    theAfter = ptRepD(after)

                    isSpace = theAfter &gt;= SPACE_THRESHOLD
                    if isSpace:
                        lastChar = chars[i - 1]
                        if not lastChar[-1].endswith(&#34; &#34;):
                            lastChar[-1] += &#34; &#34;

                    prevChar[-3] = f&#34;âŒŠ{theAfter}âŒ‹&#34; if isSpace else f&#34;Â«{theAfter}Â»&#34;
                    theseSpaces.append((i - 1, theAfter, isSpace))

                prevLeft = left
                prevLeftI = i

        if chars:
            chars[-1][-3] = &#34;end&#34;

        # change big spaces to emspaces

        nSpaces = sum(1 for x in theseSpaces if x[2])

        if nSpaces == 1:
            threshold = 90
        elif nSpaces &gt; 1:
            spacesGrowing = sorted(x[1] for x in theseSpaces if x[2])
            maxSpace = spacesGrowing[-1]
            medialSpace = spacesGrowing[nSpaces // 2]
            if maxSpace &gt; 4 * medialSpace:
                threshold = maxSpace - medialSpace

        if threshold is not None:
            theseColumns[0] = threshold
            for (i, after, isSpace) in theseSpaces:
                if isSpace and after &gt; threshold:
                    theseColumns[1].append((i, after))
                    char = chars[i]
                    char[-1] = char[-1].rstrip(&#34; &#34;) + EMSPACE

        # remove space between alef and initial follower,
        # provided the alef is the single letter in its word.

        # also for the words yeh+alef(final) and mem+alef(final) do:
        # insert a space behind the alef(final)

        curLen = 0
        prevCons = None
        pprevCons = None

        for (i, char) in enumerate(chars):
            c = char[-1]
            co = char[-2]
            r = &#34;&#34;

            isAFinal = isAlefFinal(co)

            for x in c:
                skip = False
                if x == &#34; &#34;:
                    if curLen == 1:  # and prevC in PROCLITICS:
                        skip = True
                    curLen = 0
                    prevCons = None
                    pprevCons = None
                elif x in arabicLetters:
                    curLen += 1
                    if 2 &lt;= curLen &lt;= 3 and isAFinal:
                        if isMeemOrYeh(prevCons) and (curLen == 2 or isWaw(pprevCons)):
                            x += &#34; &#34;
                            curLen = 0
                            prevCons = None
                            pprevCons = None
                    pprevCons = prevCons
                    prevCons = x
                if not skip:
                    r += x
            char[-1] = r

        # divide lines into columns

        emspaces = theseColumns[1]
        emspacePositions = {t[0] for t in emspaces}

        columnedChars = [[]]
        dest = columnedChars[-1]

        for (i, char) in enumerate(chars):
            if i in emspacePositions:
                if char[-1]:
                    dest.append(char)
                columnedChars.append([])
                dest = columnedChars[-1]
            else:
                dest.append(char)

        # divide columns into ranges
        # and chunk the ranges into words
        # and save the word boundary boxes

        text = self.text

        # text is a dict keyed by pageNum and the values are tuples of line data
        # a line datum is a list of columns
        # a column is a list of spans
        # a span is a pair of a direction char (&#34;l&#34; or &#34;r&#34;) plus a list of word data
        # a word datum is a string plus a word box
        # a word box is a (left, top, right, bottom) tuple

        result = []
        text.setdefault(pageNum, []).append(result)
        prevDir = &#34;r&#34;

        # we transform letters into chunks, where each chunk is a pair of
        # word material
        # punctuation material

        outChars = [[], []]
        inWord = True
        box = [None, None, None, None]

        def addWord():
            if outChars[0] or outChars[1]:
                wordCharsRep = &#34;&#34;.join(
                    outChars[0] if prevDir == &#34;r&#34; else reversed(outChars[0])
                )
                puncCharsRep = &#34;&#34;.join(
                    outChars[1] if prevDir == &#34;r&#34; else reversed(outChars[1])
                )
                lastSpan = None if len(result[-1]) == 0 else result[-1][-1]
                element = (wordCharsRep, puncCharsRep, tuple(box))
                if lastSpan is None or lastSpan[0] != prevDir:
                    result[-1].append((prevDir, [element]))
                else:
                    result[-1][-1][-1].append(element)

        def setBox(char):
            for (i, coor) in enumerate(char[0:4]):
                if (
                    (b := box[i]) is None
                    or (i &lt; 2 and coor &lt; b)
                    or (i &gt;= 2 and coor &gt; b)
                ):
                    box[i] = coor

        for chars in columnedChars:
            result.append([])
            outChars = [[], []]
            box = [None, None, None, None]

            for char in chars:
                c = char[-1]

                if c == &#34;&#34;:
                    continue

                for d in c:
                    spaceSeen = d in {&#34; &#34;, EMSPACE}
                    changeWord = not inWord and d not in nonLetter

                    if spaceSeen:
                        outChars[1].append(d)
                    if spaceSeen or changeWord:
                        addWord()
                        box = [None, None, None, None]
                        outChars = [[d] if changeWord else [], []]
                        inWord = True
                        continue

                    thisDir = prevDir if d in neutrals else &#34;r&#34; if d in rls else &#34;l&#34;

                    if prevDir != thisDir:
                        addWord()
                        box = [None, None, None, None]
                        outChars = [[], []]
                        inWord = True
                        prevDir = thisDir

                    if inWord:
                        if d in nonLetter:
                            inWord = False
                    dest = 0 if inWord else 1
                    rep = d
                    if d in puas:
                        rep = f&#34;âŒŠ{ord(d):&gt;04x}âŒ‹&#34;
                    outChars[dest].append(rep)

                setBox(char)

            addWord()

    def plainLine(self, columns):
        &#34;&#34;&#34;Outputs a processed line as plain text.

        Used by `Lakhnawi.plainPages()`.

        Parameters
        ----------
        columns: iterable
            An iterable of columns that make up a line.
            Each column is an iterable of spans.
            Spans contain words plus an indication of the writing direction
            for that span.

        Returns
        -------
        string
            The concatenation of all words in all spans separated by white space.
        &#34;&#34;&#34;

        return &#34;\t&#34;.join(
            &#34; &#34;.join(
                &#34; &#34;.join(f&#34;{word[0]}{word[1]}&#34; for word in span[1]) for span in spans
            )
            for spans in columns
        )

    def tsvHeadLine(self):
        &#34;&#34;&#34;Outputs the field names of a word in TSV data.

        See `Lakhnawi.tsvPages()` for the structure of TSV data
        as output format for the extracted text of the Lakhnawi PDF.

        Returns
        -------
        string
            A tab-separated line of field names.
        &#34;&#34;&#34;

        return &#34;page\tline\tcolumn\tspan\tdirection\tleft\ttop\tright\tbottom\tletters\tpunc\n&#34;

    def tsvLine(self, columns, pageNum, ln):
        &#34;&#34;&#34;Outputs a processed line as lines of tab-separated fields for each word.

        Used by `Lakhnawi.tsvPages()`.

        Parameters
        ----------
        columns: iterable
            An iterable of columns that make up a line.
            Each column is an iterable of spans.
            Spans contain words plus an indication of the writing direction
            for that span.
        pageNum: int
            The page number of the page where this line occurs.

        Returns
        -------
        string
            The concatenation of the TSV lines for all words in all spans
            in all columns.
        &#34;&#34;&#34;

        material = []
        for (cn, spans) in enumerate(columns):
            for (sn, (dr, words)) in enumerate(spans):
                for (letters, punc, (le, to, ri, bo)) in words:
                    material.append(
                        (
                            &#34;\t&#34;.join(
                                str(x)
                                for x in (
                                    pageNum,
                                    ln,
                                    cn + 1,
                                    sn + 1,
                                    dr,
                                    ptRep(le),
                                    ptRep(to),
                                    ptRep(ri),
                                    ptRep(bo),
                                    letters,
                                    punc,
                                )
                            )
                        )
                        + &#34;\n&#34;
                    )
        return &#34;&#34;.join(material)

    def htmlLine(self, columns, prevMulti, isLast):
        &#34;&#34;&#34;Outputs a processed line as HTML.

        Used by `Lakhnawi.htmlPages()`.

        Parameters
        ----------
        columns: iterable
            An iterable of columns that make up a line.
            Each column is an iterable of spans.
            Spans contain words plus an indication of the writing direction
            for that span.
        prevMulti: boolean
            Whether the preceding line has multiple columns.
        isLast: boolean
            Whether this line is the last line on the page.

        Returns
        -------
        string
            The concatenation of the TSV lines for all words in all spans
            in all columns.
        &#34;&#34;&#34;

        showSpaces = self.showSpaces
        result = []

        nCols = len(columns)
        multi = nCols &gt; 1

        if prevMulti and not multi:
            result.append(&#34;&lt;/table&gt;\n&#34;)
        elif not prevMulti and multi:
            result.append(&#34;&#34;&#34;&lt;table class=&#34;linecols&#34;&gt;\n&#34;&#34;&#34;)

        if multi:
            result.append(&#34;&lt;tr&gt;\n&#34;)

        for spans in columns:
            result.append(
                f&#34;&#34;&#34;\t&lt;td class=&#34;cols col{nCols}&#34;&gt;&#34;&#34;&#34; if multi else &#34;&#34;&#34;&lt;p class=&#34;r&#34;&gt;&#34;&#34;&#34;
            )

            for (textDir, words) in spans:
                result.append(f&#34;&#34;&#34;&lt;span class=&#34;{textDir}&#34;&gt;&#34;&#34;&#34;)
                for word in words:
                    letters = normalizeD(word[0])
                    letters = letters.replace(&#34;âŒŠ&#34;, &#34;&#34;&#34;&lt;span class=&#34;p&#34;&gt;&#34;&#34;&#34;).replace(
                        &#34;âŒ‹&#34;, &#34;&lt;/span&gt;&#34;
                    )
                    if showSpaces:
                        letters = f&#34;&#34;&#34;&lt;span class=&#34;box&#34;&gt;{letters}&lt;/span&gt;&#34;&#34;&#34;
                    punc = word[1]
                    if showSpaces:
                        punc = punc.replace(&#34; &#34;, &#34;&#34;&#34;&lt;span class=&#34;sp&#34;&gt; &lt;/span&gt;&#34;&#34;&#34;)
                    result.append(f&#34;{letters}{punc}&#34;)
                result.append(&#34;&#34;&#34;&lt;/span&gt;&#34;&#34;&#34;)

            result.append(&#34;&lt;/td&gt;\n&#34; if multi else &#34;&lt;/p&gt;\n&#34;)

        if multi:
            result.append(&#34;&lt;/tr&gt;\n&#34;)
            if isLast:
                result.append(&#34;&lt;/table&gt;\n&#34;)

        return &#34;&#34;.join(result)

    def clusterVert(self, data):
        &#34;&#34;&#34;Cluster characters into lines based on their bounding boxes.

        Most characters on a line have their middle line in approximately the same height.
        But diacritics of characters in that line may occupy different heights.

        Without intervention, these would be clustered on separate lines.
        We take care to cluster them into the same lines as their main characters.

        It involves getting an idea of the regular line height, and clustering boxes
        that fall between the lines with the line above or below, whichever is closest.

        The result of the clustering is delivered as a key function, which will
        be used to sort characters.

        Parameters
        ----------
        data: iterable of record
            The character records

        Returns
        -------
        function
            A key function that assigns to each character record a value
            that corresponds to the vertical position of a real line,
            which is a clustered set of characters.

            The information on the vertical clustering of lines
            is delivered in the attributes `Lakhnawi.heights` and
            `Lakhnawi.clusteredHeights`, on a page by page basis.
        &#34;&#34;&#34;

        pageNum = self.pageNum

        heights = collections.Counter()
        for char in data:
            k = keyCharV(char)
            heights[k] += 1

        peaks = sorted(heights)

        if len(peaks) &gt; 1:
            nDistances = len(peaks) - 1
            distances = sorted(peaks[i + 1] - peaks[i] for i in range(nDistances))

            # remove the biggest distances if &gt; 50,
            # to prevent outliers pulling the average too high
            for _ in range(2):
                if len(distances) &gt; 1:
                    if distances[-1] &gt; 50:
                        distances = distances[0:-1]
            # remove distances &lt; 15, which are much smaller than a line
            distances = [d for d in distances if d &gt; 15]

            nDistances = len(distances)
            avPeakDist = sum(distances) / nDistances

            peakThreshold = avPeakDist * LINE_CLUSTER_FACTOR
            clusteredHeights = {}
            for (k, n) in sorted(heights.items(), key=lambda x: (-x[1], x[0])):
                added = False
                for kc in clusteredHeights:
                    if abs(k - kc) &lt;= peakThreshold:
                        clusteredHeights[kc].add(k)
                        added = True
                        break
                if not added:
                    clusteredHeights[k] = {k}

        toCluster = {}
        for (kc, ks) in clusteredHeights.items():
            for k in ks:
                toCluster[k] = kc

        self.heights[pageNum] = heights
        self.clusteredHeights[pageNum] = clusteredHeights

        def clusterKeyCharV(char):
            k = keyCharV(char)
            return toCluster[k]

        return clusterKeyCharV


def keyCharV(char):
    &#34;&#34;&#34;The vertical position of the middle of a character.

    Used to sort the characters of a page in the vertical direction.

    Parameters
    ----------
    char: record

    Returns
    -------
    float
        The height of the middle of the character.
    &#34;&#34;&#34;

    return (char[3] + char[1]) / 2


def keyCharH(char):
    &#34;&#34;&#34;Sort key to sort the characters of a line horizontally.

    Basically, characters whose right edge are closer to the right edge of the page
    come before characters whose right edges are further left.

    So we could sort on minus the x coordinate of the right edge.

    However, there are complications. Sometimes characters have the same right edge.

    Diacritics usually start right
    after the letter they are on together with the next letter.

    So they should come before that next letter.
    In those cases we take the width into account.

    Private use diacritics usually have a big width, they are wider than letters.
    So if we sort wider characters before narrower characters, we get that right.

    However, normal unicode diacritics have a typical width of zero, and also
    these should come before the next letter.

    We can solve that by sorting by a key defined as 1 divided by the width
    if the width is nonzero, and 0 if the the width is zero.

    Then zero width characters come first, then wide characters, then narrow characters.

    One extra complication: the widths are not integers but fractions.

    Sometimes a the diacritic and the next letter have an almost equal right edge,
    but not quite equal, and the wrong one comes first.

    We can solve that by rounding.

    Parameters
    ----------
    char: record

    Returns
    -------
    (int, float)
    &#34;&#34;&#34;

    width = abs(int(round(char[2] - char[0])))
    widthKey = (1 / width) if width else 0
    rightKey = int(round(char[2]))
    return (-rightKey, widthKey)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="fusus.lakhnawi.CSS"><code class="name">var <span class="ident">CSS</span></code></dt>
<dd>
<div class="desc"><p>Styles to render extracted text.</p>
<p>The styles are chosen such that the extracted text looks as similar as possible to
the PDF display.</p></div>
</dd>
<dt id="fusus.lakhnawi.FNRULE_WIDTH"><code class="name">var <span class="ident">FNRULE_WIDTH</span></code></dt>
<dd>
<div class="desc"><p>Width of the rule that separates body text from footnote text.</p></div>
</dd>
<dt id="fusus.lakhnawi.LETTER_CODE_DEF"><code class="name">var <span class="ident">LETTER_CODE_DEF</span></code></dt>
<dd>
<div class="desc"><p>Defines place holder <code>d</code> in rule definitions.</p></div>
</dd>
<dt id="fusus.lakhnawi.POST_HTML"><code class="name">var <span class="ident">POST_HTML</span></code></dt>
<dd>
<div class="desc"><p>HTML code postfixed to the HTML representation of a page.</p></div>
</dd>
<dt id="fusus.lakhnawi.REPLACE_DEF"><code class="name">var <span class="ident">REPLACE_DEF</span></code></dt>
<dd>
<div class="desc"><p>Character replace rules</p>
<p>There are two parts: (1) character replace rules (2) notes.</p>
<p>Each rule consists of a left hand side, then <code>=&gt;</code>, then a right hand side,
then <code>:</code> and then a short description.
The short description may contain references to notes in the notes section,
which is a list of commented lines at the end of the whole string.</p>
<p>The left and right hand sides consist of one or more hexadecimal character codes,
joined by the <code>+</code> sign.</p>
<p>The meaning is that when the left hand side matches a portion of the input text,
the output text, which is otherwise a copy of the input text, will have that portion
replaced by the right hand side.</p>
<p>The exact application of rules has some subtleties which will be dealt with
in <code>Laknawi.trimLine</code>.</p></div>
</dd>
<dt id="fusus.lakhnawi.SPACE_THRESHOLD"><code class="name">var <span class="ident">SPACE_THRESHOLD</span></code></dt>
<dd>
<div class="desc"><p>Amount of separation between words.</p>
<p>Character boxes this far apart imply that there is a white space between them.
The unit is 0.1 pixel.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fusus.lakhnawi.getDictFromDef"><code class="name flex">
<span>def <span class="ident">getDictFromDef</span></span>(<span>defs)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpret a string as a dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>defs</code></strong> :&ensp;<code>string</code></dt>
<dd>A string containing definitions of character replace rules.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Only for rules</p>
<p>We only use this functions for the rules in <code><a title="fusus.lakhnawi.REPLACE_DEF" href="#fusus.lakhnawi.REPLACE_DEF">REPLACE_DEF</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L670-L743" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDictFromDef(defs):
    &#34;&#34;&#34;Interpret a string as a dictionary.

    Parameters
    ----------
    defs: string
        A string containing definitions of character replace rules.

    !!! note &#34;Only for rules&#34;
        We only use this functions for the rules in `REPLACE_DEF`.
    &#34;&#34;&#34;

    rules = []
    rn = 0
    good = True

    for (i, line) in enumerate(defs.strip().split(&#34;\n&#34;)):
        parts = line.split(&#34;#&#34;, maxsplit=1)
        if len(parts) &gt; 1:
            line = parts[0]
        line = line.strip()
        if not line:
            continue
        match = REPLACE_RE.match(line)
        if not match:
            print(f&#34;MALFORMED REPLACE DEF @{i}: {line}&#34;)
            good = False
            continue

        rn += 1
        (valStr, replStr, comment) = match.group(1, 2, 3)

        vals = []
        d = None
        for (i, val) in enumerate(valStr.split(&#34;+&#34;)):
            if val in {&#34;d&#34;}:
                if d is not None:
                    print(f&#34;MULTIPLE d in RULE @{i}: rule {rn}: {line}&#34;)
                    good = False
                d = i
                vals.append(LETTER_CODE[val])
            else:
                vals.append(chr(int(val, base=16)))

        repls = []
        e = None
        if replStr:
            for (i, repl) in enumerate(replStr.split(&#34;+&#34;)):
                if repl in {&#34;d&#34;}:
                    if e is not None:
                        print(f&#34;MULTIPLE d in RULE @{i}: rule {rn}: {line}&#34;)
                        good = False
                    e = i
                    repls.append(LETTER_CODE[repl])
                else:
                    repls.append(chr(int(repl, base=16)))

        if d is None and e is not None:
            print(f&#34;d in REPLACEMENT but not in MATCH @[i]: rule {rn}: {line}&#34;)
            good = False

        rules.append((rn, tuple(vals), d, tuple(repls), e))

    if not good:
        return None

    result = {}
    ruleIndex = {}

    for (rn, vals, d, repls, e) in sorted(rules, key=lambda x: (-len(x[1]), str(x[1]))):
        result.setdefault(vals[0], []).append((rn, vals, d, repls, e))
        ruleIndex[rn] = (vals, d, repls, e)

    return (result, ruleIndex)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.getToc"><code class="name flex">
<span>def <span class="ident">getToc</span></span>(<span>pageNums)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Table Of Contents for multiple HTML pages.</p>
<h2 id="parameter">Parameter</h2>
<p>pageNums: iterable if int
The page numbers of the pages in the HTML file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L353-L377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getToc(pageNums):
    &#34;&#34;&#34;Generate a Table Of Contents for multiple HTML pages.

    Parameter
    ---------
    pageNums: iterable if int
        The page numbers of the pages in the HTML file.
    &#34;&#34;&#34;

    limit = 60

    html = []
    html.append(&#34;&#34;&#34;&lt;div class=&#34;toc&#34;&gt;&#34;&#34;&#34;)
    j = 0

    for (i, pageNum) in enumerate(pageNums):
        if j == limit:
            j = 0
            html.append(&#34;&#34;&#34;&lt;/div&gt;\n&lt;div class=&#34;toc&#34;&gt;&#34;&#34;&#34;)
        html.append(f&#34;&#34;&#34;&lt;a href=&#34;#p{pageNum:&gt;03}&#34;&gt;p {pageNum}&lt;/a&gt;&lt;br&gt;&#34;&#34;&#34;)
        j += 1

    html.append(&#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;)

    return &#34;\n&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.keyCharH"><code class="name flex">
<span>def <span class="ident">keyCharH</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort key to sort the characters of a line horizontally.</p>
<p>Basically, characters whose right edge are closer to the right edge of the page
come before characters whose right edges are further left.</p>
<p>So we could sort on minus the x coordinate of the right edge.</p>
<p>However, there are complications. Sometimes characters have the same right edge.</p>
<p>Diacritics usually start right
after the letter they are on together with the next letter.</p>
<p>So they should come before that next letter.
In those cases we take the width into account.</p>
<p>Private use diacritics usually have a big width, they are wider than letters.
So if we sort wider characters before narrower characters, we get that right.</p>
<p>However, normal unicode diacritics have a typical width of zero, and also
these should come before the next letter.</p>
<p>We can solve that by sorting by a key defined as 1 divided by the width
if the width is nonzero, and 0 if the the width is zero.</p>
<p>Then zero width characters come first, then wide characters, then narrow characters.</p>
<p>One extra complication: the widths are not integers but fractions.</p>
<p>Sometimes a the diacritic and the next letter have an almost equal right edge,
but not quite equal, and the wrong one comes first.</p>
<p>We can solve that by rounding.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>char</code></strong> :&ensp;<code>record</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(int, float)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L3125-L3171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keyCharH(char):
    &#34;&#34;&#34;Sort key to sort the characters of a line horizontally.

    Basically, characters whose right edge are closer to the right edge of the page
    come before characters whose right edges are further left.

    So we could sort on minus the x coordinate of the right edge.

    However, there are complications. Sometimes characters have the same right edge.

    Diacritics usually start right
    after the letter they are on together with the next letter.

    So they should come before that next letter.
    In those cases we take the width into account.

    Private use diacritics usually have a big width, they are wider than letters.
    So if we sort wider characters before narrower characters, we get that right.

    However, normal unicode diacritics have a typical width of zero, and also
    these should come before the next letter.

    We can solve that by sorting by a key defined as 1 divided by the width
    if the width is nonzero, and 0 if the the width is zero.

    Then zero width characters come first, then wide characters, then narrow characters.

    One extra complication: the widths are not integers but fractions.

    Sometimes a the diacritic and the next letter have an almost equal right edge,
    but not quite equal, and the wrong one comes first.

    We can solve that by rounding.

    Parameters
    ----------
    char: record

    Returns
    -------
    (int, float)
    &#34;&#34;&#34;

    width = abs(int(round(char[2] - char[0])))
    widthKey = (1 / width) if width else 0
    rightKey = int(round(char[2]))
    return (-rightKey, widthKey)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.keyCharV"><code class="name flex">
<span>def <span class="ident">keyCharV</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>The vertical position of the middle of a character.</p>
<p>Used to sort the characters of a page in the vertical direction.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>char</code></strong> :&ensp;<code>record</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The height of the middle of the character.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L3107-L3122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keyCharV(char):
    &#34;&#34;&#34;The vertical position of the middle of a character.

    Used to sort the characters of a page in the vertical direction.

    Parameters
    ----------
    char: record

    Returns
    -------
    float
        The height of the middle of the character.
    &#34;&#34;&#34;

    return (char[3] + char[1]) / 2</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.preHtml"><code class="name flex">
<span>def <span class="ident">preHtml</span></span>(<span>pageNum)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate HTML code to be prefixed to the HTML representation of a page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNum</code></strong> :&ensp;<code>string</code></dt>
<dd>The page number of the page for which HTML is generated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L332-L350" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def preHtml(pageNum):
    &#34;&#34;&#34;Generate HTML code to be prefixed to the HTML representation of a page.

    Parameters
    ----------
    pageNum: string
        The page number of the page for which HTML is generated.
    &#34;&#34;&#34;

    return f&#34;&#34;&#34;\
&lt;html&gt;
    &lt;head&gt;
        &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;/&gt;
        &lt;meta charset=&#34;utf-8&#34;/&gt;
        &lt;title&gt;Lakhnawi {pageNum}&lt;/title&gt;
{CSS}
    &lt;/head&gt;
    &lt;body&gt;
&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.ptRep"><code class="name flex">
<span>def <span class="ident">ptRep</span></span>(<span>p)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a float as an integer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>We round it to the nearest integer.
A none value is converted to <code>?</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L642-L652" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ptRep(p):
    &#34;&#34;&#34;Represent a float as an integer.

    Parameters
    ----------
    p: float
        We round it to the nearest integer.
        A none value is converted to `?`.
    &#34;&#34;&#34;

    return &#34;?&#34; if p is None else int(round(p))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.ptRepD"><code class="name flex">
<span>def <span class="ident">ptRepD</span></span>(<span>p)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a float as an integer with enhanced precision.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>We multiply it by 10, then round it to the nearest integer.
A none value is converted to <code>?</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L629-L639" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ptRepD(p):
    &#34;&#34;&#34;Represent a float as an integer with enhanced precision.

    Parameters
    ----------
    p: float
        We multiply it by 10, then round it to the nearest integer.
        A none value is converted to `?`.
    &#34;&#34;&#34;

    return &#34;?&#34; if p is None else int(round(p * 10))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fusus.lakhnawi.Lakhnawi"><code class="flex name class">
<span>class <span class="ident">Lakhnawi</span></span>
</code></dt>
<dd>
<div class="desc"><p>Text extraction from the Lakhnawi PDF.</p>
<p>This class makes use of the <code><a title="fusus.char.UChar" href="char.html#fusus.char.UChar">UChar</a></code> class which
defines several categories of characters.
By extending that class, the Lakhnawi class makes use of those categories.
It also adds specific characters to some of those categories, especially
the private use characters that occur in the Lakhnawi PDF.</p>
<p>We use <em>fitz</em> (<code>pip3 install PyMuPDF</code>) for PDF reading.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L766-L3104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Lakhnawi(UChar):
    def __init__(self):
        &#34;&#34;&#34;Text extraction from the Lakhnawi PDF.

        This class makes use of the `fusus.char.UChar` class which
        defines several categories of characters.
        By extending that class, the Lakhnawi class makes use of those categories.
        It also adds specific characters to some of those categories, especially
        the private use characters that occur in the Lakhnawi PDF.

        We use *fitz* (`pip3 install PyMuPDF`) for PDF reading.
        &#34;&#34;&#34;

        super().__init__()

        self.heights = {}
        &#34;&#34;&#34;Heights of characters, indexed by page number.&#34;&#34;&#34;

        self.clusteredHeights = {}
        &#34;&#34;&#34;Clustered heights of characters, indexed by page number.

        The clustered heights correspond to the lines on a page.
        &#34;&#34;&#34;

        self.lines = {}
        &#34;&#34;&#34;Lines as tuples of original character objects, indexed by page number&#34;&#34;&#34;

        self.text = {}
        &#34;&#34;&#34;Lines as tuples of converted character objects, indexed by page number&#34;&#34;&#34;

        self.fnRules = {}
        &#34;&#34;&#34;Vertical positions of footnote lines, indexed by page number&#34;&#34;&#34;

        self.spaces = {}
        &#34;&#34;&#34;Spacing information for each character, indexed by page and line number.

        For character that has space behind it, it gives the index position of that
        character in the line, the amount of space detected,
        and whether this counts as a full white space.
        &#34;&#34;&#34;

        self.columns = {}
        &#34;&#34;&#34;Column information, indexed by page and line number.

        Spaces that are significantly larger than a normal white space
        are interpreted as an emspace, and these are considered as column separators.
        We remember the character positions where this happens plus the amount
        of space in question.

        Columns in the Lakhnawi PDF correspond to *hemistic* poems,
        where lines are divided into two halves, each occupying a column.

        See ![hemistic](images/hemistic.png)

        !!! caution &#34;hemistic poems versus blocks&#34;
            This is very different from blocks (see `fusus.layout`) in OCRed texts,
            where blocks have been detected because of vertical strokes
            that separate columns.

            The reading progress in a hemistic poem is not changed by the
            column division, where as in the case of blocks, reading proceeds
            by reading the complete blocks in order.
        &#34;&#34;&#34;

        self.doubles = {}
        &#34;&#34;&#34;Glyphs with double unicode points.

        Some private use characters have two unicode points assigned to them
        by fonts in the PDF.
        This is the cause that straightforward text extractions deliver
        double occurrences of those letters. Even *fitz* does that.

        We have collected these cases, and choose to use the lower unicode point,
        which is usually an ordinary character, whereas the other is usually a
        related presentational character.

        This dictionary maps the lower character to the higher character.
        &#34;&#34;&#34;

        self.privateLetters = None
        &#34;&#34;&#34;Private-use unicodes that correspond to full letters.&#34;&#34;&#34;

        self.privateDias = None
        &#34;&#34;&#34;Private-use unicodes that correspond to diacritics.&#34;&#34;&#34;

        self.privateSpace = None
        &#34;&#34;&#34;Private-use-unicode used to represent a space.&#34;&#34;&#34;

        self.good = True
        &#34;&#34;&#34;Whether processing is still ok, i.e. no errors encountered.&#34;&#34;&#34;

        self.getCharConfig()

        self.doc = fitz.open(SOURCE)
        &#34;&#34;&#34;A handle to the PDF document, after it has been read by *fitz*.&#34;&#34;&#34;

    def close(self):
        &#34;&#34;&#34;Close the PDF handle, offered by *fitz*.&#34;&#34;&#34;

        self.doc.close()

    def setStyle(self):
        &#34;&#34;&#34;Import the CSS styles into the notebook.

        See `CSS`.
        &#34;&#34;&#34;

        display(HTML(CSS))

    def getCharConfig(self):
        &#34;&#34;&#34;Configure all character information.

        Private-use characters, transformation rules, character categories.
        &#34;&#34;&#34;

        self.privateInfo()
        self.setupRules()
        self.getCharInfo()

    def privateInfo(self):
        &#34;&#34;&#34;Set up additional character categories wrt. private-use characters.

        Several categories will receive additional members from the
        private use characters.
        &#34;&#34;&#34;

        self.privateLetters = getSetFromDef(PRIVATE_LETTERS_DEF)
        self.privateDias = getSetFromDef(PRIVATE_DIAS_DEF)
        self.privateSpace = PRIVATE_SPACE
        self.nospacings |= self.privateDias
        # self.nospacings.add(PRIVATE_TATWEEL)
        self.diacritics |= self.privateDias
        self.diacriticLike |= self.privateDias
        self.arabicLetters = self.arabic - self.privateDias
        self.rls |= self.puas

    def setupRules(self):
        &#34;&#34;&#34;Set up character transformation rules.

        Prepare for counting how much rules will be applied
        when extracting text from pages of the Lakhnawi PDF.
        &#34;&#34;&#34;

        (self.replace, self.ruleIndex) = getDictFromDef(REPLACE_DEF)
        if self.replace is None:
            self.replace = {}
            self.good = False
        self.rulesApplied = collections.defaultdict(collections.Counter)
        for rn in self.ruleIndex:
            self.rulesApplied[rn] = collections.Counter()

    def getCharInfo(self):
        &#34;&#34;&#34;Obtain detailed character information by reading the font report file.

        From this file we read:

        * which are the private use characters?
        * which of them have a double unicode?

        The font file is
        [here](https://github.com/among/fusus/blob/master/ur/Lakhnawi/FontReport-Lakhnawi.pdf).
        &#34;&#34;&#34;

        self.doubles = {}
        self.privates = set()
        doubles = self.doubles
        privates = self.privates
        finalSpace = self.finalSpace
        puas = self.puas

        doc = fitz.open(FONT)

        for page in doc:
            textPage = page.getTextPage()
            data = textPage.extractText()

            for (ln, line) in enumerate(data.split(&#34;\n&#34;)):
                if line.startswith(&#34;U+&#34;):
                    match = U_LINE_RE.match(line)
                    if not match:
                        continue
                    (main, rest) = match.group(1, 2)
                    main = main.lower()
                    nMain = int(main, base=16)
                    cMain = chr(nMain)
                    if cMain in puas:
                        privates.add(cMain)
                        continue
                    if cMain == chr(0):
                        continue
                    second = None
                    rest = rest.replace(&#34; &#34;, &#34;&#34;)
                    if rest:
                        if HEX_RE.match(rest):
                            second = rest.lower()
                    if second:
                        nSecond = int(second, base=16)
                        cSecond = chr(nSecond)
                        if nSecond &gt; nMain:
                            doubles[cMain] = cSecond
                        else:
                            doubles[cSecond] = cMain

        doublesApplied = collections.defaultdict(collections.Counter)
        for d in doubles:
            doublesApplied[d] = collections.Counter()
        self.doublesApplied = doublesApplied

        finalsApplied = collections.defaultdict(collections.Counter)
        for f in finalSpace:
            finalsApplied[f] = collections.Counter()
        self.finalsApplied = finalsApplied

    def plainChar(self, c):
        &#34;&#34;&#34;Show the character code of a character.

        Parameters
        ----------
        c: string
            The character in question, may also be the empty string or
            the integer 1 (diacritic place holder).

        Returns
        -------
        string
            The hexadecimal unicode point of `c`, between `âŒŠ âŒ‹` - brackets.
        &#34;&#34;&#34;

        if c == &#34;&#34;:
            return &#34;âŒŠâŒ‹&#34;
        if c in {1}:
            return CODE_LETTER[c]
        return f&#34;âŒŠ{ord(c):&gt;04x}âŒ‹&#34;

    def plainString(self, s):
        &#34;&#34;&#34;Show the character codes of the characters in a string.

        Parameters
        ----------
        s: string
            The string to show, may be empty, may contain place holders.

        Returns
        -------
        string
            The concatenation of the unicode points of the characters in the string,
            each code point between brackets.

        See also `Lakhnawi.plainChar()`.
        &#34;&#34;&#34;

        return &#34; &#34;.join(self.plainChar(c) for c in s)

    def showChar(self, c):
        &#34;&#34;&#34;Pretty display of a single unicode character.

        We show the character itself and its name (if not a private-use one),
        its hexadecimal code, and we indicate by coloring the kind of
        white space that the character represents (ordinary space or emspace).

        Parameters
        ----------
        c: string
            The character in question, may also be the empty string or
            the integer 1 (diacritic place holder).
        &#34;&#34;&#34;

        if c in {1, 2}:
            return f&#34;&#34;&#34;
&lt;div class=&#34;ch p&#34;&gt;
    &lt;div class=&#34;cn&#34;&gt;{LETTER_KIND[c]}&lt;/div&gt;
&lt;/div&gt;
&#34;&#34;&#34;

        if c == &#34;&#34;:
            extra = &#34;&#34;
            ccode = &#34;&#34;
            crep = &#34;\u00a0&#34;
            cname = &#34;EMPTY&#34;
        else:
            puas = self.puas
            rls = self.rls

            ccode = (
                f&#34;&#34;&#34;&lt;span class=&#34;{&#34;p&#34; if c in puas else &#34;c&#34;}&#34;&gt;{ord(c):&gt;04x}&lt;/span&gt;&#34;&#34;&#34;
            )
            crep = (
                &#34;??&#34;
                if c in puas
                else f&#34;&#34;&#34;&lt;span class=&#34;{&#34;rc&#34; if c in rls else &#34;lc&#34;}&#34;&gt;{c}&#34;&#34;&#34;
            )
            cname = &#34;&#34; if c in puas else f&#34;&#34;&#34;&lt;span class=&#34;c&#34;&gt;{uName(c)}&lt;/span&gt;&#34;&#34;&#34;
            extra = (
                &#34;m&#34; if c == EMSPACE else &#34;s&#34; if c == &#34; &#34; else &#34;&#34;
            )

        return f&#34;&#34;&#34;
&lt;div class=&#34;ch{extra}&#34;&gt;
    &lt;div class=&#34;cn&#34;&gt;{ccode}&lt;/div&gt;
    &lt;div class=&#34;cn&#34;&gt;&lt;span class=&#34;cni&#34;&gt;{crep}&lt;/span&gt;&lt;/div&gt;
    &lt;div class=&#34;cn&#34;&gt;{cname}&lt;/div&gt;
&lt;/div&gt;
&#34;&#34;&#34;

    def showString(self, s, asString=False):
        &#34;&#34;&#34;Pretty display of a string as a series of unicode characters.

        Parameters
        ----------
        s: string
            The string to display, may be empty, may contain place holders.
        asString: boolean, optional `False`
            If True, return the result as an HTML string.

        Returns
        -------
        None | string
            If `asString`, returns an HTML string, otherwise returns None,
            but displays the HTML string.

        See also `Lakhnawi.showChar()`.
        &#34;&#34;&#34;

        shtml = f&#34;&#34;&#34;&lt;span class=&#34;r&#34;&gt;{s}&lt;/span&gt;&#34;&#34;&#34;
        html = &#34;&#34;&#34;&lt;div class=&#34;sr&#34;&gt;&#34;&#34;&#34; + (
            &#34;&#34;.join(self.showChar(c) for c in s) + &#34;&lt;/div&gt;&#34;
        )
        if asString:
            return f&#34;&#34;&#34;&lt;span&gt;{shtml}&lt;/span&gt;{html}&#34;&#34;&#34;

        display(HTML(f&#34;&#34;&#34;&lt;p&gt;{shtml}&lt;/p&gt;{html}&#34;&#34;&#34;))

    def showReplacements(self, rule=None, isApplied=False):
        &#34;&#34;&#34;Show a character conversion rule and how it has been applied.

        Parameters
        ----------
        rule: string|int, optional `None`
            A specification of zero or more rule numbers (see `fusus.lib.parseNums`).
            If None, all rules will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of rules with usage statistics.
        &#34;&#34;&#34;

        ruleIndex = self.ruleIndex
        rulesApplied = self.rulesApplied
        ruleNums = parseNums(rule)
        ruleNums = (
            set(ruleIndex)
            if ruleNums is None
            else sorted(r for r in ruleNums if r in ruleIndex)
        )

        html = []
        totalRules = len(ruleIndex)
        totalApplications = sum(sum(x.values()) for x in rulesApplied.values())
        totalPages = len(set(chain.from_iterable(rulesApplied.values())))
        ruleRep = &#34;rule&#34; + (&#34;&#34; if totalRules == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalRules} {ruleRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (rn, applied) in sorted(
            rulesApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if rn not in ruleNums:
                continue
            (vals, d, repls, e) = ruleIndex[rn]

            valRep = &#34;&#34;.join(self.showChar(c) for c in vals)
            replRep = &#34;&#34;.join(self.showChar(c) for c in repls)
            total = sum(applied.values())
            if isApplied and not applied:
                continue
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;rule {rn}&lt;/th&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{valRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;span class=&#34;lrg&#34;&gt;â‡’&lt;/span&gt;&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{replRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showDoubles(self, double=None):
        &#34;&#34;&#34;Show a character with double entry and how often it occurs.

        See `Lakhnawi.doubles`.

        Parameters
        ----------
        double: char, optional `None`
            A character from the doubles list (`Lakhnawi.doubles`).
            If None, all such characters will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of double-entry characters with occurrence statistics.
        &#34;&#34;&#34;

        doubles = self.doubles
        doublesApplied = self.doublesApplied

        theseDoubles = (
            set(doubles) if double is None else {double} if double in doubles else set()
        )

        html = []
        totalDoubles = len(doubles)
        totalApplications = sum(sum(x.values()) for x in doublesApplied.values())
        totalPages = len(set(chain.from_iterable(doublesApplied.values())))
        doubleRep = &#34;double&#34; + (&#34;&#34; if totalDoubles == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalDoubles} {doubleRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (d, applied) in sorted(
            doublesApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if d not in theseDoubles:
                continue
            e = doubles[d]
            doubleRep = f&#34;{self.showChar(e)} â‡’ {self.showChar(d)}&#34;

            total = sum(applied.values())
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{doubleRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showFinals(self, final=None):
        &#34;&#34;&#34;Show a character with final form and how often it has been replaced.

        Final forms will be normalized to ground forms
        and sometimes a space will be added.

        Parameters
        ----------
        final: char, optional `None`
            A character from the final space list (`fusus.char.UChar.finalSpace`).
            If None, all such characters will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of final space characters with occurrence statistics.
        &#34;&#34;&#34;

        finalSpace = self.finalSpace
        finalsApplied = self.finalsApplied

        theseFinals = (
            finalSpace if final is None else {final} if final in finalSpace else set()
        )

        html = []
        totalFinals = len(finalSpace)
        totalApplications = sum(sum(x.values()) for x in finalsApplied.values())
        totalPages = len(set(chain.from_iterable(finalsApplied.values())))
        finalRep = &#34;final&#34; + (&#34;&#34; if totalFinals == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalFinals} {finalRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (f, applied) in sorted(
            finalsApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if f not in theseFinals:
                continue
            finalRep = self.showChar(f)

            total = sum(applied.values())
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{finalRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showLineHeights(self, pageNumSpec):
        &#34;&#34;&#34;Shows how line heights have been determined.

        The pages can be selected by page numbers.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        &#34;&#34;&#34;

        heights = self.heights
        clusteredHeights = self.clusteredHeights

        for pageNum in self.parsePageNums(pageNumSpec):
            theseHeights = heights[pageNum]
            theseClusteredHeights = clusteredHeights[pageNum]

            print(f&#34;Line heights page {pageNum:&gt;3}&#34;)
            print(&#34;\nraw heights&#34;)
            for k in sorted(theseHeights):
                print(f&#34;{theseHeights[k]:&gt;4} characters @ height {int(round(k)):&gt;4}&#34;)

            print(&#34;line heights&#34;)
            for (ln, kc) in enumerate(sorted(theseClusteredHeights)):
                peak = &#34;, &#34;.join(
                    f&#34;{int(round(k)):&gt;4}&#34; for k in sorted(theseClusteredHeights[kc])
                )
                print(
                    f&#34;line {ln + 1:&gt;2}: &#34;
                    f&#34;{sum(theseHeights[k] for k in theseClusteredHeights[kc]):&gt;4}&#34;
                    f&#34; characters @height {peak}&#34;
                )

    def parsePageNums(self, pageNumSpec):
        &#34;&#34;&#34;Parses a value as one or more page numbers.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            If `None` results in all page numbers.
            If an `int`, it stands for that int.
            If a `string`, it is allowed to be a comma separated list of
            numbers or ranges, where a range is a lower bound and an upper bound
            separated by a `-`.
            If none of these, it should be an iterable of `int` values.

        Returns
        -------
        None | iterable of int
            Depending on the value.
        &#34;&#34;&#34;

        doc = self.doc
        pageNums = (
            list(range(1, len(doc) + 1))
            if not pageNumSpec
            else [pageNumSpec]
            if type(pageNumSpec) is int
            else setFromSpec(pageNumSpec)
            if type(pageNumSpec) is str
            else list(pageNumSpec)
        )
        return [i for i in sorted(pageNums) if 0 &lt; i &lt;= len(doc)]

    def drawPages(self, pageNumSpec, clip=None):
        &#34;&#34;&#34;Draws a (part) of page from the PDF as a raster image.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        clip: (int, int), optional `None`
            If None: produces the whole page.
            Otherwise it is `(top, bottom)`, and a stripe
            from top to bottom will be displayed.
        &#34;&#34;&#34;

        doc = self.doc

        for pageNum in self.parsePageNums(pageNumSpec):
            page = doc[pageNum - 1]
            if clip is not None:
                clip = (0, clip[0], page.rect.width, clip[1])

            pix = page.getPixmap(matrix=fitz.Matrix(4, 4), clip=clip, alpha=False)
            display(HTML(f&#34;&#34;&#34;&lt;p&gt;&lt;b&gt;page {pageNum}&lt;/b&gt;&lt;/p&gt;&#34;&#34;&#34;))
            display(Image(data=pix.getPNGData(), format=DEFAULT_EXTENSION))

    def getPages(
        self,
        pageNumSpec,
        refreshConfig=False,
        doRules=True,
        doFilter=True,
        onlyFnRules=False,
    ):
        &#34;&#34;&#34;Reads pages of the PDF and extracts text.

        This does all of the hard work of the text extraction.
        It saves the textual data in attributes of the Lakhnawi object,
        augmented with all kinds of diagnostic information.

        From all this data, various output representations can be generated
        rather easily by other methods.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        refreshConfig: boolean, optional `False`
            If `True`, rereads all character configuration.
            Ideal when you are iteratively developing the character configuration.
        doRules: boolean, optional `True`
            If `False`, suppresses the application of character transformation
            rules. Mainly used when debugging other aspects of the text extraction.
        doFilter: boolean, optional `True`
            If `False`, suppresses the application of unicode normalization,
            by which presentational characters are transformed into sequences
            of ordinary, basic characters.
            Used for debugging.
        onlyFnRules: boolean, optional `False`
            If `True`, skips most of the conversion.
            Only determine where the footnote rules are.
            Used for debugging.

        Returns
        -------
        None
           The effect is that attributes of the Lakhnawi object
           are filled:

           * `Lakhnawi.heights`
           * `Lakhnawi.clusteredHeights`
           * `Lakhnawi.fnRules`

           For the other attributes, see `Lakhnawi.collectPage()`.

        !!! hint &#34;multiple runs&#34;
            If you do multiple runs of this function for different pages,
            the results will not overwrite each other in general,
            because the attributes hold the results in dictionaries
            keyed by page number.
        &#34;&#34;&#34;

        if not self.good:
            print(&#34;SKIPPING because of config errors&#34;)
            return

        fnRules = self.fnRules
        spaces = self.spaces
        columns = self.columns

        self.doRules = doRules
        self.doFilter = doFilter

        ruleIndex = self.ruleIndex
        rulesApplied = self.rulesApplied

        if refreshConfig:
            self.getCharConfig()

        for rn in ruleIndex:
            rulesApplied[rn] = collections.Counter()

        for (i, pageNum) in enumerate(self.parsePageNums(pageNumSpec)):
            self.pageNum = pageNum
            rep = (
                f&#34;{i + 1:&gt;4} (page {pageNum:&gt;4})&#34;
                if pageNum != i + 1
                else (f&#34;{i + 1:&gt;4}&#34; + &#34; &#34; * 12)
            )
            sys.stdout.write(f&#34;\r\t{rep}&#34;)
            sys.stdout.flush()
            doc = self.doc
            page = doc[pageNum - 1]

            theseFnRules = set()

            for fnRule in page.getDrawings():
                if RECT in fnRule and fnRule.get(COLOR, None):
                    rect = fnRule[RECT]
                    width = rect.x1 - rect.x0
                    if width &gt; FNRULE_WIDTH:
                        theseFnRules.add(int(round(rect.y1)))

            fnRules[pageNum] = tuple(sorted(theseFnRules))
            spaces[pageNum] = {}
            columns[pageNum] = {}

            if onlyFnRules:
                continue

            textPage = page.getTextPage()
            data = textPage.extractRAWDICT()
            self.collectPage(data)

    def getPageRaw(self, pageNum):
        &#34;&#34;&#34;Do a rough/raw text extract of a specific page.

        The *fitz* method
        [extractRAWDICT()](https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT)
        is used to obtain very detailed information about each character on that page.
        Used for debugging.

        Parameters
        ----------
        pageNum: int
            A valid page number.
            It is the sequence number of the page within the PDF, counting from 1.

        Returns
        -------
        None
            It pretty prints the output of the fitz method, which is a big
            and deep dictionary.
        &#34;&#34;&#34;

        self.pageNum = pageNum
        rep = f&#34;page {pageNum:&gt;4}&#34;
        sys.stdout.write(f&#34;{rep}&#34;)
        sys.stdout.flush()
        doc = self.doc
        page = doc[pageNum - 1]

        textPage = page.getTextPage()
        data = textPage.extractRAWDICT()
        pprint(data)

    def getPageObj(self, pageNum):
        &#34;&#34;&#34;Get the *fitz* object for a specific page.

        Used for debugging.

        Parameters
        ----------
        pageNum: int
            A valid page number.
            It is the sequence number of the page within the PDF, counting from 1.

        Returns
        -------
        object
            A *fitz*
            [page object](https://pymupdf.readthedocs.io/en/latest/page.html)
        &#34;&#34;&#34;

        self.pageNum = pageNum
        doc = self.doc
        return doc[pageNum - 1]

    def plainPages(self, pageNumSpec):
        &#34;&#34;&#34;Outputs processed pages as plain text.

        Uses `Lakhnawi.plainLine()`.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.

        Returns
        -------
        None
            The plain text is printed to the output.
        &#34;&#34;&#34;

        text = self.text

        for pageNum in self.parsePageNums(pageNumSpec):
            lines = text.get(pageNum, [])

            for (i, line) in enumerate(lines):
                print(self.plainLine(line))

    def tsvPages(self, pageNumSpec):
        &#34;&#34;&#34;Outputs processed pages as tab-separated data.

        See `fusus.convert` for the details of the output format.

        Uses
        `Lakhnawi.tsvLine()`.
        and `Lakhnawi.tsvHeadLine()`.


        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.

        Returns
        -------
        None
            The tab-separated data is written to a single tsv file.
            There is a heading row.

            The file is in `fusus.parameters.UR_DIR`, under `Lakhnawi`.
            The name of the file includes a page specification.
        &#34;&#34;&#34;

        text = self.text

        destDir = f&#34;{UR_DIR}/{NAME}&#34;
        pageNums = self.parsePageNums(pageNumSpec)

        if not os.path.exists(destDir):
            os.makedirs(destDir, exist_ok=True)

        pageNumRep = ALL_PAGES if pageNumSpec is None else str(pageNumSpec)
        filePath = f&#34;{destDir}/{pageNumRep}.tsv&#34;
        fh = open(filePath, &#34;w&#34;)
        fh.write(self.tsvHeadLine())

        for pageNum in pageNums:
            lines = text.get(pageNum, [])

            for (ln, line) in enumerate(lines):
                fh.write(self.tsvLine(line, pageNum, ln + 1))

        fh.close()
        print(f&#34;TSV data written to {unexpanduser(filePath)}&#34;)

    def htmlPages(
        self,
        pageNumSpec,
        line=None,
        showSpaces=False,
        export=False,
        singleFile=False,
        toc=False,
    ):
        &#34;&#34;&#34;Outputs processed pages as formatted HTML pages.

        Uses
        `Lakhnawi.htmlLine()`.

        The HTML output is suitable to read the extracted text.
        Its layout matches the original closely, which makes it easier
        to see where the output deviates from the source page.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).
        showSpaces: boolean, optional `False`
            If `True`, shows the spaces with a conspicuous coloured background.
        export: boolean, optional `False`
            If `True`, writes the HTML results to disk.
            In this case, the HTML will not be displayed in the notebook.
        singleFile: boolean, optional `False`
            Only meaningful is `export=True`.
            If `True`, writes the output to a single HTML file,
            otherwise to one file per page, in a directory called `html`.
        toc: boolean, optional `False`
            Only meaningful is `export=True` and `singleFile=True`.
            If `True`, writes a table of contents to the file.
            The TOC points to every page that is included in the output file.

        Returns
        -------
        None
            Depending on `export`, the page is displayed in the notebook
            where this function is called, or exported to a file on disk.

            The file is in `fusus.parameters.UR_DIR`, under `Lakhnawi`.
            The name of the file includes a page specification.
        &#34;&#34;&#34;

        self.showSpaces = showSpaces
        text = self.text

        destDir = f&#34;{UR_DIR}/{NAME}&#34; if singleFile else f&#34;{UR_DIR}/{NAME}/html&#34;
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)
        lineNums = None if lineNums is None else set(lineNums)
        filesWritten = 0

        if export:
            if not os.path.exists(destDir):
                os.makedirs(destDir, exist_ok=True)
            if singleFile:
                pageNumRep = ALL_PAGES if pageNumSpec is None else str(pageNumSpec)
                tocRep = &#34;-with-toc&#34; if toc else &#34;&#34;
                filePath = f&#34;{destDir}/{pageNumRep}{tocRep}.html&#34;
                fh = open(filePath, &#34;w&#34;)
                fh.write(preHtml(f&#34;{pageNumRep}{tocRep}&#34;))
                if toc:
                    toc = getToc(pageNums)
                    fh.write(
                        f&#34;&#34;&#34;
&lt;div class=&#34;window&#34;&gt;
&lt;div class=&#34;sidebar&#34;&gt;
{toc}
&lt;/div&gt;
&lt;div class=&#34;pages bypage&#34;&gt;
&#34;&#34;&#34;
                    )
                else:
                    fh.write(
                        &#34;&#34;&#34;
&lt;div class=&#34;pages&#34;&gt;
&#34;&#34;&#34;
                    )

        pageClass = &#34;page&#34; + (&#34;&#34; if export else &#34;c&#34;)
        for pageNum in pageNums:
            lines = text.get(pageNum, [])
            nLines = len(lines)

            html = []
            html.append(
                f&#34;&#34;&#34;
&lt;div class=&#34;{pageClass}&#34;&gt;
&lt;div class=&#34;phead&#34;&gt;&lt;a name=&#34;p{pageNum:&gt;03}&#34;&gt;{pageNum}&lt;/a&gt;&lt;/div&gt;
&#34;&#34;&#34;
            )

            prevMulti = False

            for (i, line) in enumerate(lines):
                if lineNums is not None and i + 1 not in lineNums:
                    continue

                html.append(self.htmlLine(line, prevMulti, i == nLines - 1))
                prevMulti = len(line) &gt; 1

            html.append(&#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;)

            if export:
                htmlRep = &#34;&#34;.join(html)

                if singleFile:
                    fh.write(htmlRep)
                else:
                    html = preHtml(pageNum) + htmlRep + POST_HTML
                    filePath = f&#34;{destDir}/p{pageNum:&gt;03}.html&#34;
                    with open(filePath, &#34;w&#34;) as fh:
                        fh.write(html)
                        filesWritten += 1
            else:
                display(HTML(&#34;\n&#34;.join(html)))

        if export and singleFile:
            fh.write(
                &#34;&#34;&#34;
&lt;/div&gt;
&#34;&#34;&#34;
            )
            if toc:
                fh.write(
                    &#34;&#34;&#34;
    &lt;/div&gt;
    &#34;&#34;&#34;
                )
            fh.write(POST_HTML)
            fh.close()
            print(f&#34;HTML written to {unexpanduser(filePath)}&#34;)

        if export and not singleFile:
            print(f&#34;{filesWritten} HTML files written to {unexpanduser(destDir)}/&#34;)

    def showLines(
        self,
        pageNumSpec,
        line=None,
        start=None,
        end=None,
        search=None,
        orig=False,
        every=False,
    ):
        &#34;&#34;&#34;Outputs processed lines as a formatted HTML table.

        The lines can be selected by page numbers and line numbers.

        Within the selected lines, the characters can be selected by
        start/end postions, or by characters of interest.

        All of these indices start at 1.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).
        start: integer, optional `None`
            Starting word position in each line to be output.
            If `None`, starts at the beginning of each line.
        end: integer, optional `None`
            End word position in each line to be output.
            If `None`, ends at the end of each line.
        search: string or iterable of char, optional `None`
            If not none, all characters in `search` are deemed interesting.
            All occurrences of these characters within the selected lines are
            displayed, included a small context.
        orig: boolean, optional `False`
            Only meaningful if `search` is given.
            If `True`: the check for interesting
            characters is done in the original, untranslated characters.
            Otherwise, interesting characters are looked up in the translated
            characters.
        every: boolean, optional `False`
            Only meaningful if `search` is given.
            If `True`, when looking for interesting characters, all occurrences will
            be retrieved, otherwise only the first one.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        lines = self.lines
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)

        myLines = {pageNum: lines[pageNum] for pageNum in pageNums if pageNum in lines}

        html = []
        html.append(&#34;&lt;table&gt;&#34;)
        html.append(
            &#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;seq&lt;/th&gt;
    &lt;th&gt;top&lt;/th&gt;
    &lt;th&gt;bottom&lt;/th&gt;
    &lt;th&gt;left&lt;/th&gt;
    &lt;th&gt;right&lt;/th&gt;
    &lt;th&gt;spacing&lt;/th&gt;
    &lt;th&gt;font&lt;/th&gt;
    &lt;th&gt;size&lt;/th&gt;
    &lt;th&gt;orig char&lt;/th&gt;
    &lt;th&gt;char&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
        )

        shift = 5

        for (pageNum, pageLines) in myLines.items():
            myLineNums = (
                range(1, len(pageLines) + 1)
                if lineNums is None
                else [ln for ln in lineNums if 0 &lt; ln &lt;= len(pageLines)]
            )
            for ln in myLineNums:
                chars = pageLines[ln - 1]
                nChars = len(chars)
                html.append(
                    f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;th colspan=3&gt;page {pageNum}&lt;/th&gt;
    &lt;th colspan=2&gt;line {ln}&lt;/th&gt;
    &lt;th colspan=3&gt;{nChars} characters&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                )
                if search is None:
                    ranges = [(max((start or 0) - 1, 0), min(end or nChars, nChars))]
                else:
                    ranges = []

                    for (i, char) in enumerate(chars):
                        if search in char[-2 if orig else -1]:
                            occStart = max((i - shift, 0))
                            occEnd = min((i + shift + 1, nChars))
                            if ranges and occStart &lt;= ranges[-1][1]:
                                ranges[-1][1] = occEnd
                            else:
                                ranges.append([occStart, occEnd])
                            if not every:
                                break

                for (occStart, occEnd) in ranges:
                    for i in range(occStart, occEnd):
                        char = chars[i]
                        (le, to, ri, bo, font, size, spacing, oc, c) = char
                        html.append(
                            f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;{i + 1}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;{ptRepD(to)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(bo)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(le)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(ri)}&lt;/td&gt;
    &lt;td&gt;{spacing}&lt;/td&gt;
    &lt;td&gt;{font}&lt;/td&gt;
    &lt;td&gt;{size}pt&lt;/td&gt;
    &lt;td&gt;{&#34;&#34;.join(self.showChar(x) for x in reversed(oc))}&lt;/td&gt;
    &lt;td&gt;{&#34;&#34;.join(self.showChar(x) for x in reversed(c))}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                        )
                if search and ranges and not every:
                    break

        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showWords(self, pageNumSpec, line=None):
        &#34;&#34;&#34;Outputs processed words as a formatted HTML table.

        The lines can be selected by page numbers and line numbers.

        All words within the selected lines are put into a table with
        the same properties as in the TSV data,
        see `Lakhnawi.tsvPages`.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        text = self.text
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)

        myLines = {pageNum: text[pageNum] for pageNum in pageNums if pageNum in text}

        html = []
        html.append(&#34;&lt;table&gt;&#34;)
        html.append(
            &#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;page&lt;/th&gt;
    &lt;th&gt;line&lt;/th&gt;
    &lt;th&gt;col&lt;/th&gt;
    &lt;th&gt;span&lt;/th&gt;
    &lt;th&gt;dir&lt;/th&gt;
    &lt;th&gt;left&lt;/th&gt;
    &lt;th&gt;top&lt;/th&gt;
    &lt;th&gt;right&lt;/th&gt;
    &lt;th&gt;bottom&lt;/th&gt;
    &lt;th&gt;letters&lt;/th&gt;
    &lt;th&gt;punc&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
        )

        for (pageNum, pageLines) in myLines.items():
            myLineNums = (
                range(1, len(pageLines) + 1)
                if lineNums is None
                else [ln for ln in lineNums if 0 &lt; ln &lt;= len(pageLines)]
            )
            for ln in myLineNums:
                cols = pageLines[ln - 1]
                for (cn, spans) in enumerate(cols):
                    for (sn, (dr, words)) in enumerate(spans):
                        for (letters, punc, (le, to, ri, bo)) in words:
                            html.append(
                                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;{pageNum}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;{ln}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{cn + 1}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{sn + 1}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{dr}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;{ptRep(le)}&lt;/td&gt;
    &lt;td&gt;{ptRep(to)}&lt;/td&gt;
    &lt;td&gt;{ptRep(ri)}&lt;/td&gt;
    &lt;td&gt;{ptRep(bo)}&lt;/td&gt;
    &lt;td&gt;{self.showString(letters, asString=True)}&lt;/td&gt;
    &lt;td&gt;{self.showString(punc, asString=True)}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                            )

        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showUsedChars(
        self,
        pageNumSpec,
        orig=False,
        onlyPuas=False,
        onlyPresentational=False,
        long=False,
        byOcc=False,
    ):
        &#34;&#34;&#34;Show used characters.

        Gives an overview of character usage, either in the input PDF, or in
        the text output.


        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        orig: boolean, optional `False`
            If `True`: shows characters of the original PDF.
            Otherwise, shows characters of the translated output/
        onlyPuas: boolean, optional `False`
            If `True`, the result is restricted to private use characters.
        onlyPresentational: boolean, optional `False`
            If `True`, the result is restricted to presentational characters.
            See `fusus.char.UChar.presentational`.
        long: boolean, optional `False`
            If `True`, for each character output the complete list of pages
            where the character occurs. Otherwise, show only the most
            prominent pages.
        byOcc: boolean, optional `False`
            If `True`, sort the results by first occurrence of the characters.
            Otherwise, sort the results by unicode code point of the character.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        presentational = self.presentational
        pageNums = self.parsePageNums(pageNumSpec)
        text = self.text
        lines = self.lines
        puas = self.puas

        charsOut = collections.defaultdict(collections.Counter)

        def keyByOcc(c):
            pageNums = charsOut[c]
            return -sum(pageNums.values())

        sortKey = keyByOcc if byOcc else lambda x: x

        if orig:
            lns = {pageNum: lines[pageNum] for pageNum in pageNums if pageNum in lines}

            for (pageNum, pageLines) in lns.items():
                for line in pageLines:
                    for char in line:
                        c = char[-2]
                        if c in puas or (
                            not onlyPuas
                            and (c in presentational or not onlyPresentational)
                        ):
                            charsOut[c][pageNum] += 1

        else:
            texts = {pageNum: text[pageNum] for pageNum in pageNums if pageNum in text}

            for (pageNum, pageText) in texts.items():
                for line in pageText:
                    for col in line:
                        for span in col:
                            for word in span[1]:
                                letters = word[0]
                                punc = word[1]
                                thesePuas = PUA_RE.findall(letters)
                                for pua in thesePuas:
                                    charsOut[chr(int(pua, base=16))][pageNum] += 1
                                if not onlyPuas:
                                    rest = PUA_RE.sub(&#34;&#34;, f&#34;{letters}{punc}&#34;)
                                    for c in rest:
                                        if not (
                                            onlyPresentational
                                            and c not in presentational
                                        ):
                                            charsOut[c][pageNum] += 1

        totalChars = len(charsOut)
        totalPages = len(set(chain.from_iterable(charsOut.values())))
        totalOccs = sum(sum(pns.values()) for pns in charsOut.values())

        charRep = &#34;character&#34; + (&#34;&#34; if totalChars == 1 else &#34;s&#34;)
        occRep = &#34;occurence&#34; + (&#34;&#34; if totalOccs == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)

        label = &#34;private use &#34; if onlyPuas else &#34;&#34;

        html = []
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalChars} {label}{charRep} in {totalOccs} {occRep}
on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for c in sorted(charsOut, key=sortKey):
            pageNums = charsOut[c]
            nPageNums = len(pageNums)
            pageRep = &#34;page&#34; + (&#34;&#34; if nPageNums == 1 else &#34;s&#34;)
            thistotal = sum(pageNums.values())
            examplePageNum = sorted(pageNums, key=lambda p: -pageNums[p])[0]
            nExamples = pageNums[examplePageNum]
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{self.showChar(c)}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;b&gt;{thistotal}&lt;/b&gt; on &lt;i&gt;{nPageNums}&lt;/i&gt; {pageRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;e.g. page {examplePageNum} with &lt;b&gt;{nExamples}&lt;/b&gt; occurrences&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )
            if long:
                for pn in sorted(pageNums):
                    occs = pageNums[pn]
                    html.append(
                        f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;i&gt;page {pn:&gt;3}&lt;/i&gt;: &lt;b&gt;{occs:&gt;3}&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                    )
        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))

    def showColumns(self, pageNumSpec):
        &#34;&#34;&#34;Show used characters.

        Gives an overview of the columns in each line.
        The result is a readable, ascii overview of the columns
        that exists in the lines of the selected pages.

        It is useful to visually check column detection for many pages.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        pageNums = self.parsePageNums(pageNumSpec)

        columns = self.columns
        for pageNum in pageNums:
            if pageNum not in columns:
                continue
            lineInfo = columns[pageNum]
            multiple = []
            for lNum in sorted(lineInfo):
                (threshold, emspaces) = lineInfo[lNum]
                nEmspaces = len(emspaces)
                if threshold is not None and nEmspaces &gt; 0:
                    multiple.append((lNum, threshold, emspaces))
            if not len(multiple):
                print(f&#34;page {pageNum:&gt;3} -&#34;)
            else:
                print(f&#34;page {pageNum:&gt;3}:&#34;)
                for (lNum, threshold, emspaces) in multiple:
                    nEmspaces = len(emspaces)
                    print(f&#34;\t{lNum:&gt;2}: {&#39;- &#39; * (nEmspaces + 1)}&#34;)

    def showSpacing(self, pageNumSpec, line=None):
        &#34;&#34;&#34;Show where the spaces are.

        Gives an overview of the white space positions in each line.

        It is useful to debug the horizontal white space algorithm.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)
        lineNums = None if lineNums is None else set(lineNums)

        spaces = self.spaces

        for pageNum in pageNums:
            if pageNum not in spaces:
                continue

            print(f&#34;page {pageNum:&gt;3}&#34;)
            lineInfo = spaces[pageNum]

            for (ln, spaces) in lineInfo.items():
                if lineNums is not None and ln not in lineNums:
                    continue

                print(f&#34;\tline {ln:&gt;2}&#34;)

                for (i, after, isSpace) in spaces:
                    print(f&#34;\t\t{i + 1:&gt;3} {&#39;]  [&#39; if isSpace else &#39;]==[&#39;} {after}&#34;)

    def collectPage(self, data):
        &#34;&#34;&#34;Transforms raw text into proper textual data.

        Called by `Lakhnawi.getPages()` and delivers its results
        to attributes of the Lakhnawi object.

        Here are they

        * `Lakhnawi.lines`
        * `Lakhnawi.doubles`
        * `Lakhnawi.text`

        They are all dictionaries, keyed by page number first and then by line.

        Parameters
        ----------
        data: dict
            as obtained by the
            [extractRAWDICT()](https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT)
            method of *fitz*.

        Returns
        -------
        None
        &#34;&#34;&#34;

        doubles = self.doubles
        doublesApplied = self.doublesApplied
        pageNum = self.pageNum
        nospacings = self.nospacings
        fnRules = self.fnRules
        bracketMap = self.bracketMap
        text = self.text

        fnRule = fnRules.get(pageNum, None)
        fnRule = fnRule[0] if fnRule else None

        chars = []
        prevChar = None
        prevFont = None
        prevSize = None

        def addChar():
            box = prevChar[&#34;bbox&#34;]
            yBot = box[3]

            # skip chars below the footnote rule, if any
            if fnRule is not None and yBot &gt; fnRule:
                return

            c = prevChar[&#34;c&#34;]

            cr = &#34;&#34; if isEuDigit(c) else c
            cr = bracketMap.get(cr, cr)

            chars.append(
                (
                    *box,
                    prevFont,
                    prevSize,
                    &#34;&#34; if c in nospacings else True,
                    c,
                    cr,
                )
            )

        def collectChars(data, font, size):
            nonlocal prevChar
            nonlocal prevFont
            nonlocal prevSize

            if type(data) is list:
                for elem in data:
                    collectChars(elem, font, size)

            elif type(data) is dict:
                if &#34;font&#34; in data:
                    font = data[&#34;font&#34;]
                if &#34;size&#34; in data:
                    size = data[&#34;size&#34;]
                if &#34;c&#34; in data:
                    c = data[&#34;c&#34;]
                    skip = False
                    if c == &#34; &#34;:
                        skip = True

                    if prevChar is not None:
                        pc = prevChar[&#34;c&#34;]
                        if pc in doubles and doubles[pc] == c:
                            skip = True
                            doublesApplied[pc][pageNum] += 1
                        if c in doubles and doubles[c] == pc:
                            prevChar = data
                            skip = True
                            doublesApplied[c][pageNum] += 1

                    if not skip:
                        if prevChar is not None:
                            addChar()
                        prevChar = data
                        prevFont = font
                        prevSize = size

                for (k, v) in data.items():
                    if type(v) in {list, dict}:
                        collectChars(v, font, size)

        collectChars(data, None, None)
        if prevChar is not None:
            addChar()

        clusterKeyCharV = self.clusterVert(chars)
        lines = {}
        for char in sorted(chars, key=lambda c: (clusterKeyCharV(c), keyCharH(c))):
            k = clusterKeyCharV(char)
            lines.setdefault(k, []).append(list(char))

        theseLines = list(lines.values())
        if theseLines and self.isPageNum(theseLines[0]):
            theseLines = theseLines[1:]

        # remove arabic numerals between brackets

        for chars in theseLines:
            nChars = len(chars)
            if not nChars:
                continue

            i = 0

            while i &lt; nChars:
                char = chars[i]
                nextI = i + 1
                if char[-1] == &#34;(&#34;:
                    found = None
                    for j in range(i + 1, nChars):
                        theChar = chars[j][-1]
                        if theChar == &#34;)&#34;:
                            found = j + 1
                            nextI = found
                            break
                        if isArDigit(theChar):
                            continue
                        nextI = j
                        break
                    if found is not None:
                        for j in range(i, found):
                            chars[j][-1] = &#34;&#34;
                        i = found
                i = nextI

        self.lines[pageNum] = tuple(
            chars for chars in theseLines if not all(c[-1] == &#34;&#34; for c in chars)
        )

        text[pageNum] = []
        for (ln, line) in enumerate(self.lines[pageNum]):
            self.trimLine(pageNum, ln + 1, line)

    def isPageNum(self, chars):
        &#34;&#34;&#34;Checks whether a series of characters represents an arabic number.

        Parameters
        ----------
        chars: iterable of char reocrds
        &#34;&#34;&#34;

        return 1 &lt;= len(chars) &lt;= 3 and all(isArDigit(c[-1]) for c in chars)

    def trimLine(self, pageNum, ln, chars):
        &#34;&#34;&#34;Map character sequences to other sequences.

        Two tasks:

        1. Map private use characters to well-known unicode characters
        2. Insert space characters where the next character is separated from the
           previous one.

        Complications:

        Diacritical characters are mostly contained in a very wide box that overlaps
        with the boxes of the other characters. So the diacritical boxes must not be
        taken into account.

        Private use characters often come in sequences, so a sequence of characters
        must be transformed to another sequence.

        We do the tramsformation before the space insertion, because otherwise we
        might insert the space at the wrong point.

        When we transform characters we need to retain the box information,
        because we still have to insert the space.

        That&#39;s why we have as input a list of character records, where each record
        is itself a list with box information, orginal character, modified characters
        and space information.

        When we transform characters, we modify character records in place.
        We do not add or remove character records.

        The last member of a character record is the modified sequence.
        This can be zero, one, or multiple characters.
        The second last member is the original character.
        Initially, the the last and second last member of each record are equal.
        We call these members the original character and the result string.

        Space will be appended at the last member of the appropriate character records.

        The transformations are given as a set of rules.

        See `REPLACE_DEFS`.

        A rule consists of a sequence of characters to match and a sequence of
        characters to replace the match with. We call them the match sequence and the
        replacement sequence of the rule.

        For each character in the input list we check which rules have a match sequence
        that start with this character.
        Of these rules, we start with the one with the longest match sequence.
        We then check, by looking ahead, whether the whole match sequence matches the
        input.
        For the purposes of matching, we look into the result strings of the character,
        not to the original characters. This will prevent some rules to be applied
        after an earlier rule has been applied. This is intentional, and results
        in a more simple rule set.

        If there is a match, we walk through all the characters in the input for the
        length of the match sequence of the rule.
        For each input character record, we set its replacement string to the
        corresponding member of the replacement sequence of the rule.
        If the replacement sequence has run out, we replace with the empty string.
        If after this process the replacement sequence has not been exhausted,
        we join the remaining characters in the replacement string and append it
        after the replacement string of the last input character that we have visited.

        After succesful application of a rule, we do not apply other rules that would
        have been applicable at this point. Instead, we move our starting point to the
        next character record in the sequence and repeat the matching process.

        It might be that a character is replaced multiple times, for example when
        it is reached by a rule while looking ahead 3 places, and then later by a
        different rule looking ahead two places.

        However, once a character matches the first member of the match sequence of
        a rule, and the rule matches and is applied, that character will not be
        changed anymore by any other rule.

        !!! caution &#34;place holders for diacritics&#34;
            The following functionality exists in the code, but is not needed anymore
            to process the Lakhnawi PDF.

            The match sequence may contain the character `d`, which is a placeholder
            for a diacritic sign. It will match any diacritic.
            The replacement sequence of such a rule may or may not contain a `d`.
            It is an error if the replacement seqience of a rule contains a `d` while
            its match sequence does not.
            It is also an error of there are multiple `d`s in a match sequence
            of a replacement sequence.
            If so, the working of this rule is effectively two rules:

            Suppose the rule is

            x d y =&gt; r d s

            where x, y, r, s are sequences of arbitrary length.
            If the rule matches the input, then first the rule

            x =&gt; r

            will be applied at the current position.

            Then we shift temporarily to the position right after where the d has matched,
            and apply the rule

            y =&gt; s

            Then we shift back to the orginal position plus one, and continue applying
            rules.
        &#34;&#34;&#34;

        replace = self.replace
        puas = self.puas
        neutrals = self.neutrals
        rls = self.rls
        rulesApplied = self.rulesApplied
        spaces = self.spaces
        columns = self.columns
        diacritics = self.diacritics
        punct = self.punct
        diacriticLike = self.diacriticLike
        arabicLetters = self.arabicLetters
        presentationalC = self.presentationalC
        presentationalD = self.presentationalD
        finalSpace = self.finalSpace
        finalsApplied = self.finalsApplied
        nonLetter = self.nonLetter
        doRules = self.doRules
        doFilter = self.doFilter

        nChars = len(chars)

        # rule application stage

        if doRules:
            for (i, char) in enumerate(chars):
                c = char[-1]

                if c in replace:
                    rules = replace[c]
                    for (rn, vals, d, repls, e) in rules:

                        nVals = len(vals)

                        if i + nVals &gt; nChars:
                            # not enough characters left to match this rule
                            continue

                        if not all(
                            (
                                d is not None
                                and j == d
                                and chars[i + j][-1]
                                in (diacritics if vals[d] == 1 else arabicLetters)
                            )
                            or chars[i + j][-1] == vals[j]
                            for j in range(nVals)
                        ):
                            # the rule does not match after all
                            continue

                        # the rule matches: we are going to fill in the replacements
                        # if there is a diacritic in the match sequence or the
                        # replacement sequence, we restrict ourselves to the parts
                        # before the diacritics.

                        rulesApplied[rn][pageNum] += 1

                        nRepls = len(repls)
                        dEnd = nVals if d is None else d
                        eEnd = nRepls if e is None else e

                        # so, we are going to replace from here to dEnd (not including)

                        for j in range(dEnd):
                            # put the appropriate replacement character in the
                            # replacement part of the character record
                            # After running out of replacement characters, put in &#34;&#34;
                            chars[i + j][-1] = repls[j] if j &lt; eEnd else &#34;&#34;

                        if eEnd &gt; dEnd:
                            # if there are replacement characters left, put them
                            # in after the last character that we have visited.

                            if dEnd == 0:
                                # In case we have not visited any yet,
                                # we put them in before the current character
                                cd = chars[i + dEnd][-1]
                                r = &#34;&#34;.join(repls[dEnd + 1 :])
                                chars[i + dEnd][-1] = f&#34;{r}{cd}&#34;
                            else:
                                # this is the normal case
                                chars[i + dEnd - 1][-1] += &#34;&#34;.join(repls[dEnd:eEnd])

                        # if there is a diacritic in the match sequence
                        # we are going to perform the rule for the part
                        # after the diacritic

                        # Note that the case where d is None and e is not None
                        # does not occur

                        if d is not None:
                            # we set the starting points: just after the diacritics
                            dStart = d + 1
                            # if the replacement part does not have a diacritic,
                            # we have already consumed it, and we start right after it
                            eStart = nRepls if e is None else e + 1

                            # we compute the number of characters that still need to be
                            # matched and to be replaced
                            dn = nVals - dStart
                            en = nRepls - eStart

                            # we perform the replacement analogously to what we did
                            # for the first part

                            for j in range(dn):
                                # put the appropriate replacement character in the
                                # replacement part of the character record
                                # After running out of replacement characters, put in &#34;&#34;
                                chars[i + dStart + j][-1] = (
                                    repls[eStart + j] if eStart + j &lt; nRepls else &#34;&#34;
                                )
                            if en &gt; dn:
                                # if there are replacement characters left, put them
                                # in after the last character that we have visited.
                                chars[i + nVals - 1][-1] += &#34;&#34;.join(
                                    repls[eStart + dn :]
                                )
                        break

        # sift out all presentational characters

        if doFilter:
            trailSpace = False

            for (i, char) in enumerate(chars):
                c = char[-1]
                string = &#34;&#34;
                for x in c:
                    if trailSpace:
                        if x not in diacriticLike:
                            if x not in nonLetter:
                                if string == &#34;&#34; and i &gt; 0:
                                    chars[i - 1][-1] += &#34; &#34;
                                else:
                                    string += &#34; &#34;
                            trailSpace = False

                    hasFinalSpace = x in finalSpace
                    y = (
                        normalizeC(x)
                        if x in presentationalC
                        else normalizeD(x)
                        if x in presentationalD
                        else x
                    ).strip()
                    space = &#34; &#34; if hasFinalSpace or x in punct else &#34;&#34;
                    if hasFinalSpace:
                        finalsApplied[x][pageNum] += 1
                    string += y
                    if space:
                        trailSpace = True
                char[-1] = string

            if trailSpace:
                if chars:
                    chars[-1][-1] += &#34; &#34;

        # add horizontal spacing

        theseSpaces = []
        spaces[pageNum][ln] = theseSpaces

        threshold = None
        theseColumns = [threshold, []]
        columns[pageNum][ln] = theseColumns

        prevLeft = None
        prevLeftI = None

        for (i, char) in enumerate(chars):
            spacing = char[-3]

            if spacing:
                left = char[0]
                right = char[2]

                if prevLeft is not None:
                    prevChar = chars[prevLeftI]
                    after = prevLeft - right
                    theAfter = ptRepD(after)

                    isSpace = theAfter &gt;= SPACE_THRESHOLD
                    if isSpace:
                        lastChar = chars[i - 1]
                        if not lastChar[-1].endswith(&#34; &#34;):
                            lastChar[-1] += &#34; &#34;

                    prevChar[-3] = f&#34;âŒŠ{theAfter}âŒ‹&#34; if isSpace else f&#34;Â«{theAfter}Â»&#34;
                    theseSpaces.append((i - 1, theAfter, isSpace))

                prevLeft = left
                prevLeftI = i

        if chars:
            chars[-1][-3] = &#34;end&#34;

        # change big spaces to emspaces

        nSpaces = sum(1 for x in theseSpaces if x[2])

        if nSpaces == 1:
            threshold = 90
        elif nSpaces &gt; 1:
            spacesGrowing = sorted(x[1] for x in theseSpaces if x[2])
            maxSpace = spacesGrowing[-1]
            medialSpace = spacesGrowing[nSpaces // 2]
            if maxSpace &gt; 4 * medialSpace:
                threshold = maxSpace - medialSpace

        if threshold is not None:
            theseColumns[0] = threshold
            for (i, after, isSpace) in theseSpaces:
                if isSpace and after &gt; threshold:
                    theseColumns[1].append((i, after))
                    char = chars[i]
                    char[-1] = char[-1].rstrip(&#34; &#34;) + EMSPACE

        # remove space between alef and initial follower,
        # provided the alef is the single letter in its word.

        # also for the words yeh+alef(final) and mem+alef(final) do:
        # insert a space behind the alef(final)

        curLen = 0
        prevCons = None
        pprevCons = None

        for (i, char) in enumerate(chars):
            c = char[-1]
            co = char[-2]
            r = &#34;&#34;

            isAFinal = isAlefFinal(co)

            for x in c:
                skip = False
                if x == &#34; &#34;:
                    if curLen == 1:  # and prevC in PROCLITICS:
                        skip = True
                    curLen = 0
                    prevCons = None
                    pprevCons = None
                elif x in arabicLetters:
                    curLen += 1
                    if 2 &lt;= curLen &lt;= 3 and isAFinal:
                        if isMeemOrYeh(prevCons) and (curLen == 2 or isWaw(pprevCons)):
                            x += &#34; &#34;
                            curLen = 0
                            prevCons = None
                            pprevCons = None
                    pprevCons = prevCons
                    prevCons = x
                if not skip:
                    r += x
            char[-1] = r

        # divide lines into columns

        emspaces = theseColumns[1]
        emspacePositions = {t[0] for t in emspaces}

        columnedChars = [[]]
        dest = columnedChars[-1]

        for (i, char) in enumerate(chars):
            if i in emspacePositions:
                if char[-1]:
                    dest.append(char)
                columnedChars.append([])
                dest = columnedChars[-1]
            else:
                dest.append(char)

        # divide columns into ranges
        # and chunk the ranges into words
        # and save the word boundary boxes

        text = self.text

        # text is a dict keyed by pageNum and the values are tuples of line data
        # a line datum is a list of columns
        # a column is a list of spans
        # a span is a pair of a direction char (&#34;l&#34; or &#34;r&#34;) plus a list of word data
        # a word datum is a string plus a word box
        # a word box is a (left, top, right, bottom) tuple

        result = []
        text.setdefault(pageNum, []).append(result)
        prevDir = &#34;r&#34;

        # we transform letters into chunks, where each chunk is a pair of
        # word material
        # punctuation material

        outChars = [[], []]
        inWord = True
        box = [None, None, None, None]

        def addWord():
            if outChars[0] or outChars[1]:
                wordCharsRep = &#34;&#34;.join(
                    outChars[0] if prevDir == &#34;r&#34; else reversed(outChars[0])
                )
                puncCharsRep = &#34;&#34;.join(
                    outChars[1] if prevDir == &#34;r&#34; else reversed(outChars[1])
                )
                lastSpan = None if len(result[-1]) == 0 else result[-1][-1]
                element = (wordCharsRep, puncCharsRep, tuple(box))
                if lastSpan is None or lastSpan[0] != prevDir:
                    result[-1].append((prevDir, [element]))
                else:
                    result[-1][-1][-1].append(element)

        def setBox(char):
            for (i, coor) in enumerate(char[0:4]):
                if (
                    (b := box[i]) is None
                    or (i &lt; 2 and coor &lt; b)
                    or (i &gt;= 2 and coor &gt; b)
                ):
                    box[i] = coor

        for chars in columnedChars:
            result.append([])
            outChars = [[], []]
            box = [None, None, None, None]

            for char in chars:
                c = char[-1]

                if c == &#34;&#34;:
                    continue

                for d in c:
                    spaceSeen = d in {&#34; &#34;, EMSPACE}
                    changeWord = not inWord and d not in nonLetter

                    if spaceSeen:
                        outChars[1].append(d)
                    if spaceSeen or changeWord:
                        addWord()
                        box = [None, None, None, None]
                        outChars = [[d] if changeWord else [], []]
                        inWord = True
                        continue

                    thisDir = prevDir if d in neutrals else &#34;r&#34; if d in rls else &#34;l&#34;

                    if prevDir != thisDir:
                        addWord()
                        box = [None, None, None, None]
                        outChars = [[], []]
                        inWord = True
                        prevDir = thisDir

                    if inWord:
                        if d in nonLetter:
                            inWord = False
                    dest = 0 if inWord else 1
                    rep = d
                    if d in puas:
                        rep = f&#34;âŒŠ{ord(d):&gt;04x}âŒ‹&#34;
                    outChars[dest].append(rep)

                setBox(char)

            addWord()

    def plainLine(self, columns):
        &#34;&#34;&#34;Outputs a processed line as plain text.

        Used by `Lakhnawi.plainPages()`.

        Parameters
        ----------
        columns: iterable
            An iterable of columns that make up a line.
            Each column is an iterable of spans.
            Spans contain words plus an indication of the writing direction
            for that span.

        Returns
        -------
        string
            The concatenation of all words in all spans separated by white space.
        &#34;&#34;&#34;

        return &#34;\t&#34;.join(
            &#34; &#34;.join(
                &#34; &#34;.join(f&#34;{word[0]}{word[1]}&#34; for word in span[1]) for span in spans
            )
            for spans in columns
        )

    def tsvHeadLine(self):
        &#34;&#34;&#34;Outputs the field names of a word in TSV data.

        See `Lakhnawi.tsvPages()` for the structure of TSV data
        as output format for the extracted text of the Lakhnawi PDF.

        Returns
        -------
        string
            A tab-separated line of field names.
        &#34;&#34;&#34;

        return &#34;page\tline\tcolumn\tspan\tdirection\tleft\ttop\tright\tbottom\tletters\tpunc\n&#34;

    def tsvLine(self, columns, pageNum, ln):
        &#34;&#34;&#34;Outputs a processed line as lines of tab-separated fields for each word.

        Used by `Lakhnawi.tsvPages()`.

        Parameters
        ----------
        columns: iterable
            An iterable of columns that make up a line.
            Each column is an iterable of spans.
            Spans contain words plus an indication of the writing direction
            for that span.
        pageNum: int
            The page number of the page where this line occurs.

        Returns
        -------
        string
            The concatenation of the TSV lines for all words in all spans
            in all columns.
        &#34;&#34;&#34;

        material = []
        for (cn, spans) in enumerate(columns):
            for (sn, (dr, words)) in enumerate(spans):
                for (letters, punc, (le, to, ri, bo)) in words:
                    material.append(
                        (
                            &#34;\t&#34;.join(
                                str(x)
                                for x in (
                                    pageNum,
                                    ln,
                                    cn + 1,
                                    sn + 1,
                                    dr,
                                    ptRep(le),
                                    ptRep(to),
                                    ptRep(ri),
                                    ptRep(bo),
                                    letters,
                                    punc,
                                )
                            )
                        )
                        + &#34;\n&#34;
                    )
        return &#34;&#34;.join(material)

    def htmlLine(self, columns, prevMulti, isLast):
        &#34;&#34;&#34;Outputs a processed line as HTML.

        Used by `Lakhnawi.htmlPages()`.

        Parameters
        ----------
        columns: iterable
            An iterable of columns that make up a line.
            Each column is an iterable of spans.
            Spans contain words plus an indication of the writing direction
            for that span.
        prevMulti: boolean
            Whether the preceding line has multiple columns.
        isLast: boolean
            Whether this line is the last line on the page.

        Returns
        -------
        string
            The concatenation of the TSV lines for all words in all spans
            in all columns.
        &#34;&#34;&#34;

        showSpaces = self.showSpaces
        result = []

        nCols = len(columns)
        multi = nCols &gt; 1

        if prevMulti and not multi:
            result.append(&#34;&lt;/table&gt;\n&#34;)
        elif not prevMulti and multi:
            result.append(&#34;&#34;&#34;&lt;table class=&#34;linecols&#34;&gt;\n&#34;&#34;&#34;)

        if multi:
            result.append(&#34;&lt;tr&gt;\n&#34;)

        for spans in columns:
            result.append(
                f&#34;&#34;&#34;\t&lt;td class=&#34;cols col{nCols}&#34;&gt;&#34;&#34;&#34; if multi else &#34;&#34;&#34;&lt;p class=&#34;r&#34;&gt;&#34;&#34;&#34;
            )

            for (textDir, words) in spans:
                result.append(f&#34;&#34;&#34;&lt;span class=&#34;{textDir}&#34;&gt;&#34;&#34;&#34;)
                for word in words:
                    letters = normalizeD(word[0])
                    letters = letters.replace(&#34;âŒŠ&#34;, &#34;&#34;&#34;&lt;span class=&#34;p&#34;&gt;&#34;&#34;&#34;).replace(
                        &#34;âŒ‹&#34;, &#34;&lt;/span&gt;&#34;
                    )
                    if showSpaces:
                        letters = f&#34;&#34;&#34;&lt;span class=&#34;box&#34;&gt;{letters}&lt;/span&gt;&#34;&#34;&#34;
                    punc = word[1]
                    if showSpaces:
                        punc = punc.replace(&#34; &#34;, &#34;&#34;&#34;&lt;span class=&#34;sp&#34;&gt; &lt;/span&gt;&#34;&#34;&#34;)
                    result.append(f&#34;{letters}{punc}&#34;)
                result.append(&#34;&#34;&#34;&lt;/span&gt;&#34;&#34;&#34;)

            result.append(&#34;&lt;/td&gt;\n&#34; if multi else &#34;&lt;/p&gt;\n&#34;)

        if multi:
            result.append(&#34;&lt;/tr&gt;\n&#34;)
            if isLast:
                result.append(&#34;&lt;/table&gt;\n&#34;)

        return &#34;&#34;.join(result)

    def clusterVert(self, data):
        &#34;&#34;&#34;Cluster characters into lines based on their bounding boxes.

        Most characters on a line have their middle line in approximately the same height.
        But diacritics of characters in that line may occupy different heights.

        Without intervention, these would be clustered on separate lines.
        We take care to cluster them into the same lines as their main characters.

        It involves getting an idea of the regular line height, and clustering boxes
        that fall between the lines with the line above or below, whichever is closest.

        The result of the clustering is delivered as a key function, which will
        be used to sort characters.

        Parameters
        ----------
        data: iterable of record
            The character records

        Returns
        -------
        function
            A key function that assigns to each character record a value
            that corresponds to the vertical position of a real line,
            which is a clustered set of characters.

            The information on the vertical clustering of lines
            is delivered in the attributes `Lakhnawi.heights` and
            `Lakhnawi.clusteredHeights`, on a page by page basis.
        &#34;&#34;&#34;

        pageNum = self.pageNum

        heights = collections.Counter()
        for char in data:
            k = keyCharV(char)
            heights[k] += 1

        peaks = sorted(heights)

        if len(peaks) &gt; 1:
            nDistances = len(peaks) - 1
            distances = sorted(peaks[i + 1] - peaks[i] for i in range(nDistances))

            # remove the biggest distances if &gt; 50,
            # to prevent outliers pulling the average too high
            for _ in range(2):
                if len(distances) &gt; 1:
                    if distances[-1] &gt; 50:
                        distances = distances[0:-1]
            # remove distances &lt; 15, which are much smaller than a line
            distances = [d for d in distances if d &gt; 15]

            nDistances = len(distances)
            avPeakDist = sum(distances) / nDistances

            peakThreshold = avPeakDist * LINE_CLUSTER_FACTOR
            clusteredHeights = {}
            for (k, n) in sorted(heights.items(), key=lambda x: (-x[1], x[0])):
                added = False
                for kc in clusteredHeights:
                    if abs(k - kc) &lt;= peakThreshold:
                        clusteredHeights[kc].add(k)
                        added = True
                        break
                if not added:
                    clusteredHeights[k] = {k}

        toCluster = {}
        for (kc, ks) in clusteredHeights.items():
            for k in ks:
                toCluster[k] = kc

        self.heights[pageNum] = heights
        self.clusteredHeights[pageNum] = clusteredHeights

        def clusterKeyCharV(char):
            k = keyCharV(char)
            return toCluster[k]

        return clusterKeyCharV</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fusus.char.UChar" href="char.html#fusus.char.UChar">UChar</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fusus.lakhnawi.Lakhnawi.clusteredHeights"><code class="name">var <span class="ident">clusteredHeights</span></code></dt>
<dd>
<div class="desc"><p>Clustered heights of characters, indexed by page number.</p>
<p>The clustered heights correspond to the lines on a page.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Column information, indexed by page and line number.</p>
<p>Spaces that are significantly larger than a normal white space
are interpreted as an emspace, and these are considered as column separators.
We remember the character positions where this happens plus the amount
of space in question.</p>
<p>Columns in the Lakhnawi PDF correspond to <em>hemistic</em> poems,
where lines are divided into two halves, each occupying a column.</p>
<p>See <img alt="hemistic" src="images/hemistic.png"></p>
<div class="admonition caution">
<p class="admonition-title">hemistic poems versus blocks</p>
<p>This is very different from blocks (see <code><a title="fusus.layout" href="layout.html">fusus.layout</a></code>) in OCRed texts,
where blocks have been detected because of vertical strokes
that separate columns.</p>
<p>The reading progress in a hemistic poem is not changed by the
column division, where as in the case of blocks, reading proceeds
by reading the complete blocks in order.</p>
</div></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.doc"><code class="name">var <span class="ident">doc</span></code></dt>
<dd>
<div class="desc"><p>A handle to the PDF document, after it has been read by <em>fitz</em>.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.doubles"><code class="name">var <span class="ident">doubles</span></code></dt>
<dd>
<div class="desc"><p>Glyphs with double unicode points.</p>
<p>Some private use characters have two unicode points assigned to them
by fonts in the PDF.
This is the cause that straightforward text extractions deliver
double occurrences of those letters. Even <em>fitz</em> does that.</p>
<p>We have collected these cases, and choose to use the lower unicode point,
which is usually an ordinary character, whereas the other is usually a
related presentational character.</p>
<p>This dictionary maps the lower character to the higher character.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.fnRules"><code class="name">var <span class="ident">fnRules</span></code></dt>
<dd>
<div class="desc"><p>Vertical positions of footnote lines, indexed by page number</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.good"><code class="name">var <span class="ident">good</span></code></dt>
<dd>
<div class="desc"><p>Whether processing is still ok, i.e. no errors encountered.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.heights"><code class="name">var <span class="ident">heights</span></code></dt>
<dd>
<div class="desc"><p>Heights of characters, indexed by page number.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.lines"><code class="name">var <span class="ident">lines</span></code></dt>
<dd>
<div class="desc"><p>Lines as tuples of original character objects, indexed by page number</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.privateDias"><code class="name">var <span class="ident">privateDias</span></code></dt>
<dd>
<div class="desc"><p>Private-use unicodes that correspond to diacritics.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.privateLetters"><code class="name">var <span class="ident">privateLetters</span></code></dt>
<dd>
<div class="desc"><p>Private-use unicodes that correspond to full letters.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.privateSpace"><code class="name">var <span class="ident">privateSpace</span></code></dt>
<dd>
<div class="desc"><p>Private-use-unicode used to represent a space.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.spaces"><code class="name">var <span class="ident">spaces</span></code></dt>
<dd>
<div class="desc"><p>Spacing information for each character, indexed by page and line number.</p>
<p>For character that has space behind it, it gives the index position of that
character in the line, the amount of space detected,
and whether this counts as a full white space.</p></div>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"><p>Lines as tuples of converted character objects, indexed by page number</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fusus.lakhnawi.Lakhnawi.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the PDF handle, offered by <em>fitz</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L862-L865" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close the PDF handle, offered by *fitz*.&#34;&#34;&#34;

    self.doc.close()</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.clusterVert"><code class="name flex">
<span>def <span class="ident">clusterVert</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Cluster characters into lines based on their bounding boxes.</p>
<p>Most characters on a line have their middle line in approximately the same height.
But diacritics of characters in that line may occupy different heights.</p>
<p>Without intervention, these would be clustered on separate lines.
We take care to cluster them into the same lines as their main characters.</p>
<p>It involves getting an idea of the regular line height, and clustering boxes
that fall between the lines with the line above or below, whichever is closest.</p>
<p>The result of the clustering is delivered as a key function, which will
be used to sort characters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>iterable</code> of <code>record</code></dt>
<dd>The character records</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>
<p>A key function that assigns to each character record a value
that corresponds to the vertical position of a real line,
which is a clustered set of characters.</p>
<p>The information on the vertical clustering of lines
is delivered in the attributes <code><a title="fusus.lakhnawi.Lakhnawi.heights" href="#fusus.lakhnawi.Lakhnawi.heights">Lakhnawi.heights</a></code> and
<code><a title="fusus.lakhnawi.Lakhnawi.clusteredHeights" href="#fusus.lakhnawi.Lakhnawi.clusteredHeights">Lakhnawi.clusteredHeights</a></code>, on a page by page basis.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L3023-L3104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clusterVert(self, data):
    &#34;&#34;&#34;Cluster characters into lines based on their bounding boxes.

    Most characters on a line have their middle line in approximately the same height.
    But diacritics of characters in that line may occupy different heights.

    Without intervention, these would be clustered on separate lines.
    We take care to cluster them into the same lines as their main characters.

    It involves getting an idea of the regular line height, and clustering boxes
    that fall between the lines with the line above or below, whichever is closest.

    The result of the clustering is delivered as a key function, which will
    be used to sort characters.

    Parameters
    ----------
    data: iterable of record
        The character records

    Returns
    -------
    function
        A key function that assigns to each character record a value
        that corresponds to the vertical position of a real line,
        which is a clustered set of characters.

        The information on the vertical clustering of lines
        is delivered in the attributes `Lakhnawi.heights` and
        `Lakhnawi.clusteredHeights`, on a page by page basis.
    &#34;&#34;&#34;

    pageNum = self.pageNum

    heights = collections.Counter()
    for char in data:
        k = keyCharV(char)
        heights[k] += 1

    peaks = sorted(heights)

    if len(peaks) &gt; 1:
        nDistances = len(peaks) - 1
        distances = sorted(peaks[i + 1] - peaks[i] for i in range(nDistances))

        # remove the biggest distances if &gt; 50,
        # to prevent outliers pulling the average too high
        for _ in range(2):
            if len(distances) &gt; 1:
                if distances[-1] &gt; 50:
                    distances = distances[0:-1]
        # remove distances &lt; 15, which are much smaller than a line
        distances = [d for d in distances if d &gt; 15]

        nDistances = len(distances)
        avPeakDist = sum(distances) / nDistances

        peakThreshold = avPeakDist * LINE_CLUSTER_FACTOR
        clusteredHeights = {}
        for (k, n) in sorted(heights.items(), key=lambda x: (-x[1], x[0])):
            added = False
            for kc in clusteredHeights:
                if abs(k - kc) &lt;= peakThreshold:
                    clusteredHeights[kc].add(k)
                    added = True
                    break
            if not added:
                clusteredHeights[k] = {k}

    toCluster = {}
    for (kc, ks) in clusteredHeights.items():
        for k in ks:
            toCluster[k] = kc

    self.heights[pageNum] = heights
    self.clusteredHeights[pageNum] = clusteredHeights

    def clusterKeyCharV(char):
        k = keyCharV(char)
        return toCluster[k]

    return clusterKeyCharV</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.collectPage"><code class="name flex">
<span>def <span class="ident">collectPage</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms raw text into proper textual data.</p>
<p>Called by <code><a title="fusus.lakhnawi.Lakhnawi.getPages" href="#fusus.lakhnawi.Lakhnawi.getPages">Lakhnawi.getPages()</a></code> and delivers its results
to attributes of the Lakhnawi object.</p>
<p>Here are they</p>
<ul>
<li><code><a title="fusus.lakhnawi.Lakhnawi.lines" href="#fusus.lakhnawi.Lakhnawi.lines">Lakhnawi.lines</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.doubles" href="#fusus.lakhnawi.Lakhnawi.doubles">Lakhnawi.doubles</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.text" href="#fusus.lakhnawi.Lakhnawi.text">Lakhnawi.text</a></code></li>
</ul>
<p>They are all dictionaries, keyed by page number first and then by line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>as obtained by the
<a href="https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT">extractRAWDICT()</a>
method of <em>fitz</em>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2218-L2375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def collectPage(self, data):
    &#34;&#34;&#34;Transforms raw text into proper textual data.

    Called by `Lakhnawi.getPages()` and delivers its results
    to attributes of the Lakhnawi object.

    Here are they

    * `Lakhnawi.lines`
    * `Lakhnawi.doubles`
    * `Lakhnawi.text`

    They are all dictionaries, keyed by page number first and then by line.

    Parameters
    ----------
    data: dict
        as obtained by the
        [extractRAWDICT()](https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT)
        method of *fitz*.

    Returns
    -------
    None
    &#34;&#34;&#34;

    doubles = self.doubles
    doublesApplied = self.doublesApplied
    pageNum = self.pageNum
    nospacings = self.nospacings
    fnRules = self.fnRules
    bracketMap = self.bracketMap
    text = self.text

    fnRule = fnRules.get(pageNum, None)
    fnRule = fnRule[0] if fnRule else None

    chars = []
    prevChar = None
    prevFont = None
    prevSize = None

    def addChar():
        box = prevChar[&#34;bbox&#34;]
        yBot = box[3]

        # skip chars below the footnote rule, if any
        if fnRule is not None and yBot &gt; fnRule:
            return

        c = prevChar[&#34;c&#34;]

        cr = &#34;&#34; if isEuDigit(c) else c
        cr = bracketMap.get(cr, cr)

        chars.append(
            (
                *box,
                prevFont,
                prevSize,
                &#34;&#34; if c in nospacings else True,
                c,
                cr,
            )
        )

    def collectChars(data, font, size):
        nonlocal prevChar
        nonlocal prevFont
        nonlocal prevSize

        if type(data) is list:
            for elem in data:
                collectChars(elem, font, size)

        elif type(data) is dict:
            if &#34;font&#34; in data:
                font = data[&#34;font&#34;]
            if &#34;size&#34; in data:
                size = data[&#34;size&#34;]
            if &#34;c&#34; in data:
                c = data[&#34;c&#34;]
                skip = False
                if c == &#34; &#34;:
                    skip = True

                if prevChar is not None:
                    pc = prevChar[&#34;c&#34;]
                    if pc in doubles and doubles[pc] == c:
                        skip = True
                        doublesApplied[pc][pageNum] += 1
                    if c in doubles and doubles[c] == pc:
                        prevChar = data
                        skip = True
                        doublesApplied[c][pageNum] += 1

                if not skip:
                    if prevChar is not None:
                        addChar()
                    prevChar = data
                    prevFont = font
                    prevSize = size

            for (k, v) in data.items():
                if type(v) in {list, dict}:
                    collectChars(v, font, size)

    collectChars(data, None, None)
    if prevChar is not None:
        addChar()

    clusterKeyCharV = self.clusterVert(chars)
    lines = {}
    for char in sorted(chars, key=lambda c: (clusterKeyCharV(c), keyCharH(c))):
        k = clusterKeyCharV(char)
        lines.setdefault(k, []).append(list(char))

    theseLines = list(lines.values())
    if theseLines and self.isPageNum(theseLines[0]):
        theseLines = theseLines[1:]

    # remove arabic numerals between brackets

    for chars in theseLines:
        nChars = len(chars)
        if not nChars:
            continue

        i = 0

        while i &lt; nChars:
            char = chars[i]
            nextI = i + 1
            if char[-1] == &#34;(&#34;:
                found = None
                for j in range(i + 1, nChars):
                    theChar = chars[j][-1]
                    if theChar == &#34;)&#34;:
                        found = j + 1
                        nextI = found
                        break
                    if isArDigit(theChar):
                        continue
                    nextI = j
                    break
                if found is not None:
                    for j in range(i, found):
                        chars[j][-1] = &#34;&#34;
                    i = found
            i = nextI

    self.lines[pageNum] = tuple(
        chars for chars in theseLines if not all(c[-1] == &#34;&#34; for c in chars)
    )

    text[pageNum] = []
    for (ln, line) in enumerate(self.lines[pageNum]):
        self.trimLine(pageNum, ln + 1, line)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.drawPages"><code class="name flex">
<span>def <span class="ident">drawPages</span></span>(<span>self, pageNumSpec, clip=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws a (part) of page from the PDF as a raster image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>clip</code></strong> :&ensp;<code>(int, int)</code>, optional <code>None</code></dt>
<dd>If None: produces the whole page.
Otherwise it is <code>(top, bottom)</code>, and a stripe
from top to bottom will be displayed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1379-L1401" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def drawPages(self, pageNumSpec, clip=None):
    &#34;&#34;&#34;Draws a (part) of page from the PDF as a raster image.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.
    clip: (int, int), optional `None`
        If None: produces the whole page.
        Otherwise it is `(top, bottom)`, and a stripe
        from top to bottom will be displayed.
    &#34;&#34;&#34;

    doc = self.doc

    for pageNum in self.parsePageNums(pageNumSpec):
        page = doc[pageNum - 1]
        if clip is not None:
            clip = (0, clip[0], page.rect.width, clip[1])

        pix = page.getPixmap(matrix=fitz.Matrix(4, 4), clip=clip, alpha=False)
        display(HTML(f&#34;&#34;&#34;&lt;p&gt;&lt;b&gt;page {pageNum}&lt;/b&gt;&lt;/p&gt;&#34;&#34;&#34;))
        display(Image(data=pix.getPNGData(), format=DEFAULT_EXTENSION))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.getCharConfig"><code class="name flex">
<span>def <span class="ident">getCharConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure all character information.</p>
<p>Private-use characters, transformation rules, character categories.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L875-L883" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCharConfig(self):
    &#34;&#34;&#34;Configure all character information.

    Private-use characters, transformation rules, character categories.
    &#34;&#34;&#34;

    self.privateInfo()
    self.setupRules()
    self.getCharInfo()</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.getCharInfo"><code class="name flex">
<span>def <span class="ident">getCharInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain detailed character information by reading the font report file.</p>
<p>From this file we read:</p>
<ul>
<li>which are the private use characters?</li>
<li>which of them have a double unicode?</li>
</ul>
<p>The font file is
<a href="https://github.com/among/fusus/blob/master/ur/Lakhnawi/FontReport-Lakhnawi.pdf">here</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L917-L977" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCharInfo(self):
    &#34;&#34;&#34;Obtain detailed character information by reading the font report file.

    From this file we read:

    * which are the private use characters?
    * which of them have a double unicode?

    The font file is
    [here](https://github.com/among/fusus/blob/master/ur/Lakhnawi/FontReport-Lakhnawi.pdf).
    &#34;&#34;&#34;

    self.doubles = {}
    self.privates = set()
    doubles = self.doubles
    privates = self.privates
    finalSpace = self.finalSpace
    puas = self.puas

    doc = fitz.open(FONT)

    for page in doc:
        textPage = page.getTextPage()
        data = textPage.extractText()

        for (ln, line) in enumerate(data.split(&#34;\n&#34;)):
            if line.startswith(&#34;U+&#34;):
                match = U_LINE_RE.match(line)
                if not match:
                    continue
                (main, rest) = match.group(1, 2)
                main = main.lower()
                nMain = int(main, base=16)
                cMain = chr(nMain)
                if cMain in puas:
                    privates.add(cMain)
                    continue
                if cMain == chr(0):
                    continue
                second = None
                rest = rest.replace(&#34; &#34;, &#34;&#34;)
                if rest:
                    if HEX_RE.match(rest):
                        second = rest.lower()
                if second:
                    nSecond = int(second, base=16)
                    cSecond = chr(nSecond)
                    if nSecond &gt; nMain:
                        doubles[cMain] = cSecond
                    else:
                        doubles[cSecond] = cMain

    doublesApplied = collections.defaultdict(collections.Counter)
    for d in doubles:
        doublesApplied[d] = collections.Counter()
    self.doublesApplied = doublesApplied

    finalsApplied = collections.defaultdict(collections.Counter)
    for f in finalSpace:
        finalsApplied[f] = collections.Counter()
    self.finalsApplied = finalsApplied</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.getPageObj"><code class="name flex">
<span>def <span class="ident">getPageObj</span></span>(<span>self, pageNum)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the <em>fitz</em> object for a specific page.</p>
<p>Used for debugging.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNum</code></strong> :&ensp;<code>int</code></dt>
<dd>A valid page number.
It is the sequence number of the page within the PDF, counting from 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>A <em>fitz</em>
<a href="https://pymupdf.readthedocs.io/en/latest/page.html">page object</a></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1543-L1563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getPageObj(self, pageNum):
    &#34;&#34;&#34;Get the *fitz* object for a specific page.

    Used for debugging.

    Parameters
    ----------
    pageNum: int
        A valid page number.
        It is the sequence number of the page within the PDF, counting from 1.

    Returns
    -------
    object
        A *fitz*
        [page object](https://pymupdf.readthedocs.io/en/latest/page.html)
    &#34;&#34;&#34;

    self.pageNum = pageNum
    doc = self.doc
    return doc[pageNum - 1]</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.getPageRaw"><code class="name flex">
<span>def <span class="ident">getPageRaw</span></span>(<span>self, pageNum)</span>
</code></dt>
<dd>
<div class="desc"><p>Do a rough/raw text extract of a specific page.</p>
<p>The <em>fitz</em> method
<a href="https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT">extractRAWDICT()</a>
is used to obtain very detailed information about each character on that page.
Used for debugging.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNum</code></strong> :&ensp;<code>int</code></dt>
<dd>A valid page number.
It is the sequence number of the page within the PDF, counting from 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>It pretty prints the output of the fitz method, which is a big
and deep dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1511-L1541" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getPageRaw(self, pageNum):
    &#34;&#34;&#34;Do a rough/raw text extract of a specific page.

    The *fitz* method
    [extractRAWDICT()](https://pymupdf.readthedocs.io/en/latest/textpage.html#TextPage.extractRAWDICT)
    is used to obtain very detailed information about each character on that page.
    Used for debugging.

    Parameters
    ----------
    pageNum: int
        A valid page number.
        It is the sequence number of the page within the PDF, counting from 1.

    Returns
    -------
    None
        It pretty prints the output of the fitz method, which is a big
        and deep dictionary.
    &#34;&#34;&#34;

    self.pageNum = pageNum
    rep = f&#34;page {pageNum:&gt;4}&#34;
    sys.stdout.write(f&#34;{rep}&#34;)
    sys.stdout.flush()
    doc = self.doc
    page = doc[pageNum - 1]

    textPage = page.getTextPage()
    data = textPage.extractRAWDICT()
    pprint(data)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.getPages"><code class="name flex">
<span>def <span class="ident">getPages</span></span>(<span>self, pageNumSpec, refreshConfig=False, doRules=True, doFilter=True, onlyFnRules=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads pages of the PDF and extracts text.</p>
<p>This does all of the hard work of the text extraction.
It saves the textual data in attributes of the Lakhnawi object,
augmented with all kinds of diagnostic information.</p>
<p>From all this data, various output representations can be generated
rather easily by other methods.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>refreshConfig</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, rereads all character configuration.
Ideal when you are iteratively developing the character configuration.</dd>
<dt><strong><code>doRules</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If <code>False</code>, suppresses the application of character transformation
rules. Mainly used when debugging other aspects of the text extraction.</dd>
<dt><strong><code>doFilter</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If <code>False</code>, suppresses the application of unicode normalization,
by which presentational characters are transformed into sequences
of ordinary, basic characters.
Used for debugging.</dd>
<dt><strong><code>onlyFnRules</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, skips most of the conversion.
Only determine where the footnote rules are.
Used for debugging.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>The effect is that attributes of the Lakhnawi object
are filled:</p>
<ul>
<li><code><a title="fusus.lakhnawi.Lakhnawi.heights" href="#fusus.lakhnawi.Lakhnawi.heights">Lakhnawi.heights</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.clusteredHeights" href="#fusus.lakhnawi.Lakhnawi.clusteredHeights">Lakhnawi.clusteredHeights</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.fnRules" href="#fusus.lakhnawi.Lakhnawi.fnRules">Lakhnawi.fnRules</a></code></li>
</ul>
<p>For the other attributes, see <code><a title="fusus.lakhnawi.Lakhnawi.collectPage" href="#fusus.lakhnawi.Lakhnawi.collectPage">Lakhnawi.collectPage()</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">multiple runs</p>
<p>If you do multiple runs of this function for different pages,
the results will not overwrite each other in general,
because the attributes hold the results in dictionaries
keyed by page number.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1403-L1509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getPages(
    self,
    pageNumSpec,
    refreshConfig=False,
    doRules=True,
    doFilter=True,
    onlyFnRules=False,
):
    &#34;&#34;&#34;Reads pages of the PDF and extracts text.

    This does all of the hard work of the text extraction.
    It saves the textual data in attributes of the Lakhnawi object,
    augmented with all kinds of diagnostic information.

    From all this data, various output representations can be generated
    rather easily by other methods.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.
    refreshConfig: boolean, optional `False`
        If `True`, rereads all character configuration.
        Ideal when you are iteratively developing the character configuration.
    doRules: boolean, optional `True`
        If `False`, suppresses the application of character transformation
        rules. Mainly used when debugging other aspects of the text extraction.
    doFilter: boolean, optional `True`
        If `False`, suppresses the application of unicode normalization,
        by which presentational characters are transformed into sequences
        of ordinary, basic characters.
        Used for debugging.
    onlyFnRules: boolean, optional `False`
        If `True`, skips most of the conversion.
        Only determine where the footnote rules are.
        Used for debugging.

    Returns
    -------
    None
       The effect is that attributes of the Lakhnawi object
       are filled:

       * `Lakhnawi.heights`
       * `Lakhnawi.clusteredHeights`
       * `Lakhnawi.fnRules`

       For the other attributes, see `Lakhnawi.collectPage()`.

    !!! hint &#34;multiple runs&#34;
        If you do multiple runs of this function for different pages,
        the results will not overwrite each other in general,
        because the attributes hold the results in dictionaries
        keyed by page number.
    &#34;&#34;&#34;

    if not self.good:
        print(&#34;SKIPPING because of config errors&#34;)
        return

    fnRules = self.fnRules
    spaces = self.spaces
    columns = self.columns

    self.doRules = doRules
    self.doFilter = doFilter

    ruleIndex = self.ruleIndex
    rulesApplied = self.rulesApplied

    if refreshConfig:
        self.getCharConfig()

    for rn in ruleIndex:
        rulesApplied[rn] = collections.Counter()

    for (i, pageNum) in enumerate(self.parsePageNums(pageNumSpec)):
        self.pageNum = pageNum
        rep = (
            f&#34;{i + 1:&gt;4} (page {pageNum:&gt;4})&#34;
            if pageNum != i + 1
            else (f&#34;{i + 1:&gt;4}&#34; + &#34; &#34; * 12)
        )
        sys.stdout.write(f&#34;\r\t{rep}&#34;)
        sys.stdout.flush()
        doc = self.doc
        page = doc[pageNum - 1]

        theseFnRules = set()

        for fnRule in page.getDrawings():
            if RECT in fnRule and fnRule.get(COLOR, None):
                rect = fnRule[RECT]
                width = rect.x1 - rect.x0
                if width &gt; FNRULE_WIDTH:
                    theseFnRules.add(int(round(rect.y1)))

        fnRules[pageNum] = tuple(sorted(theseFnRules))
        spaces[pageNum] = {}
        columns[pageNum] = {}

        if onlyFnRules:
            continue

        textPage = page.getTextPage()
        data = textPage.extractRAWDICT()
        self.collectPage(data)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.htmlLine"><code class="name flex">
<span>def <span class="ident">htmlLine</span></span>(<span>self, columns, prevMulti, isLast)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a processed line as HTML.</p>
<p>Used by <code><a title="fusus.lakhnawi.Lakhnawi.htmlPages" href="#fusus.lakhnawi.Lakhnawi.htmlPages">Lakhnawi.htmlPages()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>iterable</code></dt>
<dd>An iterable of columns that make up a line.
Each column is an iterable of spans.
Spans contain words plus an indication of the writing direction
for that span.</dd>
<dt><strong><code>prevMulti</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the preceding line has multiple columns.</dd>
<dt><strong><code>isLast</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether this line is the last line on the page.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The concatenation of the TSV lines for all words in all spans
in all columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2956-L3021" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def htmlLine(self, columns, prevMulti, isLast):
    &#34;&#34;&#34;Outputs a processed line as HTML.

    Used by `Lakhnawi.htmlPages()`.

    Parameters
    ----------
    columns: iterable
        An iterable of columns that make up a line.
        Each column is an iterable of spans.
        Spans contain words plus an indication of the writing direction
        for that span.
    prevMulti: boolean
        Whether the preceding line has multiple columns.
    isLast: boolean
        Whether this line is the last line on the page.

    Returns
    -------
    string
        The concatenation of the TSV lines for all words in all spans
        in all columns.
    &#34;&#34;&#34;

    showSpaces = self.showSpaces
    result = []

    nCols = len(columns)
    multi = nCols &gt; 1

    if prevMulti and not multi:
        result.append(&#34;&lt;/table&gt;\n&#34;)
    elif not prevMulti and multi:
        result.append(&#34;&#34;&#34;&lt;table class=&#34;linecols&#34;&gt;\n&#34;&#34;&#34;)

    if multi:
        result.append(&#34;&lt;tr&gt;\n&#34;)

    for spans in columns:
        result.append(
            f&#34;&#34;&#34;\t&lt;td class=&#34;cols col{nCols}&#34;&gt;&#34;&#34;&#34; if multi else &#34;&#34;&#34;&lt;p class=&#34;r&#34;&gt;&#34;&#34;&#34;
        )

        for (textDir, words) in spans:
            result.append(f&#34;&#34;&#34;&lt;span class=&#34;{textDir}&#34;&gt;&#34;&#34;&#34;)
            for word in words:
                letters = normalizeD(word[0])
                letters = letters.replace(&#34;âŒŠ&#34;, &#34;&#34;&#34;&lt;span class=&#34;p&#34;&gt;&#34;&#34;&#34;).replace(
                    &#34;âŒ‹&#34;, &#34;&lt;/span&gt;&#34;
                )
                if showSpaces:
                    letters = f&#34;&#34;&#34;&lt;span class=&#34;box&#34;&gt;{letters}&lt;/span&gt;&#34;&#34;&#34;
                punc = word[1]
                if showSpaces:
                    punc = punc.replace(&#34; &#34;, &#34;&#34;&#34;&lt;span class=&#34;sp&#34;&gt; &lt;/span&gt;&#34;&#34;&#34;)
                result.append(f&#34;{letters}{punc}&#34;)
            result.append(&#34;&#34;&#34;&lt;/span&gt;&#34;&#34;&#34;)

        result.append(&#34;&lt;/td&gt;\n&#34; if multi else &#34;&lt;/p&gt;\n&#34;)

    if multi:
        result.append(&#34;&lt;/tr&gt;\n&#34;)
        if isLast:
            result.append(&#34;&lt;/table&gt;\n&#34;)

    return &#34;&#34;.join(result)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.htmlPages"><code class="name flex">
<span>def <span class="ident">htmlPages</span></span>(<span>self, pageNumSpec, line=None, showSpaces=False, export=False, singleFile=False, toc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs processed pages as formatted HTML pages.</p>
<p>Uses
<code><a title="fusus.lakhnawi.Lakhnawi.htmlLine" href="#fusus.lakhnawi.Lakhnawi.htmlLine">Lakhnawi.htmlLine()</a></code>.</p>
<p>The HTML output is suitable to read the extracted text.
Its layout matches the original closely, which makes it easier
to see where the output deviates from the source page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>A specification of zero or more line numbers (see <code><a title="fusus.lib.parseNums" href="lib.html#fusus.lib.parseNums">parseNums()</a></code>).</dd>
<dt><strong><code>showSpaces</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, shows the spaces with a conspicuous coloured background.</dd>
<dt><strong><code>export</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, writes the HTML results to disk.
In this case, the HTML will not be displayed in the notebook.</dd>
<dt><strong><code>singleFile</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only meaningful is <code>export=True</code>.
If <code>True</code>, writes the output to a single HTML file,
otherwise to one file per page, in a directory called <code>html</code>.</dd>
<dt><strong><code>toc</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only meaningful is <code>export=True</code> and <code>singleFile=True</code>.
If <code>True</code>, writes a table of contents to the file.
The TOC points to every page that is included in the output file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>
<p>Depending on <code>export</code>, the page is displayed in the notebook
where this function is called, or exported to a file on disk.</p>
<p>The file is in <code><a title="fusus.parameters.UR_DIR" href="parameters.html#fusus.parameters.UR_DIR">UR_DIR</a></code>, under <code><a title="fusus.lakhnawi.Lakhnawi" href="#fusus.lakhnawi.Lakhnawi">Lakhnawi</a></code>.
The name of the file includes a page specification.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1636-L1775" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def htmlPages(
        self,
        pageNumSpec,
        line=None,
        showSpaces=False,
        export=False,
        singleFile=False,
        toc=False,
    ):
        &#34;&#34;&#34;Outputs processed pages as formatted HTML pages.

        Uses
        `Lakhnawi.htmlLine()`.

        The HTML output is suitable to read the extracted text.
        Its layout matches the original closely, which makes it easier
        to see where the output deviates from the source page.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).
        showSpaces: boolean, optional `False`
            If `True`, shows the spaces with a conspicuous coloured background.
        export: boolean, optional `False`
            If `True`, writes the HTML results to disk.
            In this case, the HTML will not be displayed in the notebook.
        singleFile: boolean, optional `False`
            Only meaningful is `export=True`.
            If `True`, writes the output to a single HTML file,
            otherwise to one file per page, in a directory called `html`.
        toc: boolean, optional `False`
            Only meaningful is `export=True` and `singleFile=True`.
            If `True`, writes a table of contents to the file.
            The TOC points to every page that is included in the output file.

        Returns
        -------
        None
            Depending on `export`, the page is displayed in the notebook
            where this function is called, or exported to a file on disk.

            The file is in `fusus.parameters.UR_DIR`, under `Lakhnawi`.
            The name of the file includes a page specification.
        &#34;&#34;&#34;

        self.showSpaces = showSpaces
        text = self.text

        destDir = f&#34;{UR_DIR}/{NAME}&#34; if singleFile else f&#34;{UR_DIR}/{NAME}/html&#34;
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)
        lineNums = None if lineNums is None else set(lineNums)
        filesWritten = 0

        if export:
            if not os.path.exists(destDir):
                os.makedirs(destDir, exist_ok=True)
            if singleFile:
                pageNumRep = ALL_PAGES if pageNumSpec is None else str(pageNumSpec)
                tocRep = &#34;-with-toc&#34; if toc else &#34;&#34;
                filePath = f&#34;{destDir}/{pageNumRep}{tocRep}.html&#34;
                fh = open(filePath, &#34;w&#34;)
                fh.write(preHtml(f&#34;{pageNumRep}{tocRep}&#34;))
                if toc:
                    toc = getToc(pageNums)
                    fh.write(
                        f&#34;&#34;&#34;
&lt;div class=&#34;window&#34;&gt;
&lt;div class=&#34;sidebar&#34;&gt;
{toc}
&lt;/div&gt;
&lt;div class=&#34;pages bypage&#34;&gt;
&#34;&#34;&#34;
                    )
                else:
                    fh.write(
                        &#34;&#34;&#34;
&lt;div class=&#34;pages&#34;&gt;
&#34;&#34;&#34;
                    )

        pageClass = &#34;page&#34; + (&#34;&#34; if export else &#34;c&#34;)
        for pageNum in pageNums:
            lines = text.get(pageNum, [])
            nLines = len(lines)

            html = []
            html.append(
                f&#34;&#34;&#34;
&lt;div class=&#34;{pageClass}&#34;&gt;
&lt;div class=&#34;phead&#34;&gt;&lt;a name=&#34;p{pageNum:&gt;03}&#34;&gt;{pageNum}&lt;/a&gt;&lt;/div&gt;
&#34;&#34;&#34;
            )

            prevMulti = False

            for (i, line) in enumerate(lines):
                if lineNums is not None and i + 1 not in lineNums:
                    continue

                html.append(self.htmlLine(line, prevMulti, i == nLines - 1))
                prevMulti = len(line) &gt; 1

            html.append(&#34;&#34;&#34;&lt;/div&gt;&#34;&#34;&#34;)

            if export:
                htmlRep = &#34;&#34;.join(html)

                if singleFile:
                    fh.write(htmlRep)
                else:
                    html = preHtml(pageNum) + htmlRep + POST_HTML
                    filePath = f&#34;{destDir}/p{pageNum:&gt;03}.html&#34;
                    with open(filePath, &#34;w&#34;) as fh:
                        fh.write(html)
                        filesWritten += 1
            else:
                display(HTML(&#34;\n&#34;.join(html)))

        if export and singleFile:
            fh.write(
                &#34;&#34;&#34;
&lt;/div&gt;
&#34;&#34;&#34;
            )
            if toc:
                fh.write(
                    &#34;&#34;&#34;
    &lt;/div&gt;
    &#34;&#34;&#34;
                )
            fh.write(POST_HTML)
            fh.close()
            print(f&#34;HTML written to {unexpanduser(filePath)}&#34;)

        if export and not singleFile:
            print(f&#34;{filesWritten} HTML files written to {unexpanduser(destDir)}/&#34;)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.isPageNum"><code class="name flex">
<span>def <span class="ident">isPageNum</span></span>(<span>self, chars)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a series of characters represents an arabic number.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>chars</code></strong> :&ensp;<code>iterable</code> of <code>char reocrds</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2377-L2385" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isPageNum(self, chars):
    &#34;&#34;&#34;Checks whether a series of characters represents an arabic number.

    Parameters
    ----------
    chars: iterable of char reocrds
    &#34;&#34;&#34;

    return 1 &lt;= len(chars) &lt;= 3 and all(isArDigit(c[-1]) for c in chars)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.parsePageNums"><code class="name flex">
<span>def <span class="ident">parsePageNums</span></span>(<span>self, pageNumSpec)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses a value as one or more page numbers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>If <code>None</code> results in all page numbers.
If an <code>int</code>, it stands for that int.
If a <code>string</code>, it is allowed to be a comma separated list of
numbers or ranges, where a range is a lower bound and an upper bound
separated by a <code>-</code>.
If none of these, it should be an iterable of <code>int</code> values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None | iterable</code> of <code>int</code></dt>
<dd>Depending on the value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1348-L1377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parsePageNums(self, pageNumSpec):
    &#34;&#34;&#34;Parses a value as one or more page numbers.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        If `None` results in all page numbers.
        If an `int`, it stands for that int.
        If a `string`, it is allowed to be a comma separated list of
        numbers or ranges, where a range is a lower bound and an upper bound
        separated by a `-`.
        If none of these, it should be an iterable of `int` values.

    Returns
    -------
    None | iterable of int
        Depending on the value.
    &#34;&#34;&#34;

    doc = self.doc
    pageNums = (
        list(range(1, len(doc) + 1))
        if not pageNumSpec
        else [pageNumSpec]
        if type(pageNumSpec) is int
        else setFromSpec(pageNumSpec)
        if type(pageNumSpec) is str
        else list(pageNumSpec)
    )
    return [i for i in sorted(pageNums) if 0 &lt; i &lt;= len(doc)]</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.plainChar"><code class="name flex">
<span>def <span class="ident">plainChar</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the character code of a character.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>string</code></dt>
<dd>The character in question, may also be the empty string or
the integer 1 (diacritic place holder).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The hexadecimal unicode point of <code>c</code>, between <code>âŒŠ âŒ‹</code> - brackets.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L979-L998" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plainChar(self, c):
    &#34;&#34;&#34;Show the character code of a character.

    Parameters
    ----------
    c: string
        The character in question, may also be the empty string or
        the integer 1 (diacritic place holder).

    Returns
    -------
    string
        The hexadecimal unicode point of `c`, between `âŒŠ âŒ‹` - brackets.
    &#34;&#34;&#34;

    if c == &#34;&#34;:
        return &#34;âŒŠâŒ‹&#34;
    if c in {1}:
        return CODE_LETTER[c]
    return f&#34;âŒŠ{ord(c):&gt;04x}âŒ‹&#34;</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.plainLine"><code class="name flex">
<span>def <span class="ident">plainLine</span></span>(<span>self, columns)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a processed line as plain text.</p>
<p>Used by <code><a title="fusus.lakhnawi.Lakhnawi.plainPages" href="#fusus.lakhnawi.Lakhnawi.plainPages">Lakhnawi.plainPages()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>iterable</code></dt>
<dd>An iterable of columns that make up a line.
Each column is an iterable of spans.
Spans contain words plus an indication of the writing direction
for that span.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The concatenation of all words in all spans separated by white space.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2867-L2891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plainLine(self, columns):
    &#34;&#34;&#34;Outputs a processed line as plain text.

    Used by `Lakhnawi.plainPages()`.

    Parameters
    ----------
    columns: iterable
        An iterable of columns that make up a line.
        Each column is an iterable of spans.
        Spans contain words plus an indication of the writing direction
        for that span.

    Returns
    -------
    string
        The concatenation of all words in all spans separated by white space.
    &#34;&#34;&#34;

    return &#34;\t&#34;.join(
        &#34; &#34;.join(
            &#34; &#34;.join(f&#34;{word[0]}{word[1]}&#34; for word in span[1]) for span in spans
        )
        for spans in columns
    )</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.plainPages"><code class="name flex">
<span>def <span class="ident">plainPages</span></span>(<span>self, pageNumSpec)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs processed pages as plain text.</p>
<p>Uses <code><a title="fusus.lakhnawi.Lakhnawi.plainLine" href="#fusus.lakhnawi.Lakhnawi.plainLine">Lakhnawi.plainLine()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The plain text is printed to the output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1565-L1587" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plainPages(self, pageNumSpec):
    &#34;&#34;&#34;Outputs processed pages as plain text.

    Uses `Lakhnawi.plainLine()`.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.

    Returns
    -------
    None
        The plain text is printed to the output.
    &#34;&#34;&#34;

    text = self.text

    for pageNum in self.parsePageNums(pageNumSpec):
        lines = text.get(pageNum, [])

        for (i, line) in enumerate(lines):
            print(self.plainLine(line))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.plainString"><code class="name flex">
<span>def <span class="ident">plainString</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the character codes of the characters in a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>string</code></dt>
<dd>The string to show, may be empty, may contain place holders.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The concatenation of the unicode points of the characters in the string,
each code point between brackets.</dd>
</dl>
<p>See also <code><a title="fusus.lakhnawi.Lakhnawi.plainChar" href="#fusus.lakhnawi.Lakhnawi.plainChar">Lakhnawi.plainChar()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1000-L1017" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plainString(self, s):
    &#34;&#34;&#34;Show the character codes of the characters in a string.

    Parameters
    ----------
    s: string
        The string to show, may be empty, may contain place holders.

    Returns
    -------
    string
        The concatenation of the unicode points of the characters in the string,
        each code point between brackets.

    See also `Lakhnawi.plainChar()`.
    &#34;&#34;&#34;

    return &#34; &#34;.join(self.plainChar(c) for c in s)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.privateInfo"><code class="name flex">
<span>def <span class="ident">privateInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up additional character categories wrt. private-use characters.</p>
<p>Several categories will receive additional members from the
private use characters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L885-L900" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def privateInfo(self):
    &#34;&#34;&#34;Set up additional character categories wrt. private-use characters.

    Several categories will receive additional members from the
    private use characters.
    &#34;&#34;&#34;

    self.privateLetters = getSetFromDef(PRIVATE_LETTERS_DEF)
    self.privateDias = getSetFromDef(PRIVATE_DIAS_DEF)
    self.privateSpace = PRIVATE_SPACE
    self.nospacings |= self.privateDias
    # self.nospacings.add(PRIVATE_TATWEEL)
    self.diacritics |= self.privateDias
    self.diacriticLike |= self.privateDias
    self.arabicLetters = self.arabic - self.privateDias
    self.rls |= self.puas</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.setStyle"><code class="name flex">
<span>def <span class="ident">setStyle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Import the CSS styles into the notebook.</p>
<p>See <code><a title="fusus.lakhnawi.CSS" href="#fusus.lakhnawi.CSS">CSS</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L867-L873" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setStyle(self):
    &#34;&#34;&#34;Import the CSS styles into the notebook.

    See `CSS`.
    &#34;&#34;&#34;

    display(HTML(CSS))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.setupRules"><code class="name flex">
<span>def <span class="ident">setupRules</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set up character transformation rules.</p>
<p>Prepare for counting how much rules will be applied
when extracting text from pages of the Lakhnawi PDF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L902-L915" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setupRules(self):
    &#34;&#34;&#34;Set up character transformation rules.

    Prepare for counting how much rules will be applied
    when extracting text from pages of the Lakhnawi PDF.
    &#34;&#34;&#34;

    (self.replace, self.ruleIndex) = getDictFromDef(REPLACE_DEF)
    if self.replace is None:
        self.replace = {}
        self.good = False
    self.rulesApplied = collections.defaultdict(collections.Counter)
    for rn in self.ruleIndex:
        self.rulesApplied[rn] = collections.Counter()</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showChar"><code class="name flex">
<span>def <span class="ident">showChar</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty display of a single unicode character.</p>
<p>We show the character itself and its name (if not a private-use one),
its hexadecimal code, and we indicate by coloring the kind of
white space that the character represents (ordinary space or emspace).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>string</code></dt>
<dd>The character in question, may also be the empty string or
the integer 1 (diacritic place holder).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1019-L1068" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showChar(self, c):
        &#34;&#34;&#34;Pretty display of a single unicode character.

        We show the character itself and its name (if not a private-use one),
        its hexadecimal code, and we indicate by coloring the kind of
        white space that the character represents (ordinary space or emspace).

        Parameters
        ----------
        c: string
            The character in question, may also be the empty string or
            the integer 1 (diacritic place holder).
        &#34;&#34;&#34;

        if c in {1, 2}:
            return f&#34;&#34;&#34;
&lt;div class=&#34;ch p&#34;&gt;
    &lt;div class=&#34;cn&#34;&gt;{LETTER_KIND[c]}&lt;/div&gt;
&lt;/div&gt;
&#34;&#34;&#34;

        if c == &#34;&#34;:
            extra = &#34;&#34;
            ccode = &#34;&#34;
            crep = &#34;\u00a0&#34;
            cname = &#34;EMPTY&#34;
        else:
            puas = self.puas
            rls = self.rls

            ccode = (
                f&#34;&#34;&#34;&lt;span class=&#34;{&#34;p&#34; if c in puas else &#34;c&#34;}&#34;&gt;{ord(c):&gt;04x}&lt;/span&gt;&#34;&#34;&#34;
            )
            crep = (
                &#34;??&#34;
                if c in puas
                else f&#34;&#34;&#34;&lt;span class=&#34;{&#34;rc&#34; if c in rls else &#34;lc&#34;}&#34;&gt;{c}&#34;&#34;&#34;
            )
            cname = &#34;&#34; if c in puas else f&#34;&#34;&#34;&lt;span class=&#34;c&#34;&gt;{uName(c)}&lt;/span&gt;&#34;&#34;&#34;
            extra = (
                &#34;m&#34; if c == EMSPACE else &#34;s&#34; if c == &#34; &#34; else &#34;&#34;
            )

        return f&#34;&#34;&#34;
&lt;div class=&#34;ch{extra}&#34;&gt;
    &lt;div class=&#34;cn&#34;&gt;{ccode}&lt;/div&gt;
    &lt;div class=&#34;cn&#34;&gt;&lt;span class=&#34;cni&#34;&gt;{crep}&lt;/span&gt;&lt;/div&gt;
    &lt;div class=&#34;cn&#34;&gt;{cname}&lt;/div&gt;
&lt;/div&gt;
&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showColumns"><code class="name flex">
<span>def <span class="ident">showColumns</span></span>(<span>self, pageNumSpec)</span>
</code></dt>
<dd>
<div class="desc"><p>Show used characters.</p>
<p>Gives an overview of the columns in each line.
The result is a readable, ascii overview of the columns
that exists in the lines of the selected pages.</p>
<p>It is useful to visually check column detection for many pages.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The output material will be displayed in the notebook.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2135-L2174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showColumns(self, pageNumSpec):
    &#34;&#34;&#34;Show used characters.

    Gives an overview of the columns in each line.
    The result is a readable, ascii overview of the columns
    that exists in the lines of the selected pages.

    It is useful to visually check column detection for many pages.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.

    Returns
    -------
    None
        The output material will be displayed in the notebook.
    &#34;&#34;&#34;

    pageNums = self.parsePageNums(pageNumSpec)

    columns = self.columns
    for pageNum in pageNums:
        if pageNum not in columns:
            continue
        lineInfo = columns[pageNum]
        multiple = []
        for lNum in sorted(lineInfo):
            (threshold, emspaces) = lineInfo[lNum]
            nEmspaces = len(emspaces)
            if threshold is not None and nEmspaces &gt; 0:
                multiple.append((lNum, threshold, emspaces))
        if not len(multiple):
            print(f&#34;page {pageNum:&gt;3} -&#34;)
        else:
            print(f&#34;page {pageNum:&gt;3}:&#34;)
            for (lNum, threshold, emspaces) in multiple:
                nEmspaces = len(emspaces)
                print(f&#34;\t{lNum:&gt;2}: {&#39;- &#39; * (nEmspaces + 1)}&#34;)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showDoubles"><code class="name flex">
<span>def <span class="ident">showDoubles</span></span>(<span>self, double=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a character with double entry and how often it occurs.</p>
<p>See <code><a title="fusus.lakhnawi.Lakhnawi.doubles" href="#fusus.lakhnawi.Lakhnawi.doubles">Lakhnawi.doubles</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>double</code></strong> :&ensp;<code>char</code>, optional <code>None</code></dt>
<dd>A character from the doubles list (<code><a title="fusus.lakhnawi.Lakhnawi.doubles" href="#fusus.lakhnawi.Lakhnawi.doubles">Lakhnawi.doubles</a></code>).
If None, all such characters will be taken.</dd>
<dt><strong><code>isApplied</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only show rules that have been applied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Displays a table of double-entry characters with occurrence statistics.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1174-L1242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showDoubles(self, double=None):
        &#34;&#34;&#34;Show a character with double entry and how often it occurs.

        See `Lakhnawi.doubles`.

        Parameters
        ----------
        double: char, optional `None`
            A character from the doubles list (`Lakhnawi.doubles`).
            If None, all such characters will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of double-entry characters with occurrence statistics.
        &#34;&#34;&#34;

        doubles = self.doubles
        doublesApplied = self.doublesApplied

        theseDoubles = (
            set(doubles) if double is None else {double} if double in doubles else set()
        )

        html = []
        totalDoubles = len(doubles)
        totalApplications = sum(sum(x.values()) for x in doublesApplied.values())
        totalPages = len(set(chain.from_iterable(doublesApplied.values())))
        doubleRep = &#34;double&#34; + (&#34;&#34; if totalDoubles == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalDoubles} {doubleRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (d, applied) in sorted(
            doublesApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if d not in theseDoubles:
                continue
            e = doubles[d]
            doubleRep = f&#34;{self.showChar(e)} â‡’ {self.showChar(d)}&#34;

            total = sum(applied.values())
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{doubleRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showFinals"><code class="name flex">
<span>def <span class="ident">showFinals</span></span>(<span>self, final=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a character with final form and how often it has been replaced.</p>
<p>Final forms will be normalized to ground forms
and sometimes a space will be added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>final</code></strong> :&ensp;<code>char</code>, optional <code>None</code></dt>
<dd>A character from the final space list (<code><a title="fusus.char.UChar.finalSpace" href="char.html#fusus.char.UChar.finalSpace">UChar.finalSpace</a></code>).
If None, all such characters will be taken.</dd>
<dt><strong><code>isApplied</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only show rules that have been applied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Displays a table of final space characters with occurrence statistics.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1244-L1312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showFinals(self, final=None):
        &#34;&#34;&#34;Show a character with final form and how often it has been replaced.

        Final forms will be normalized to ground forms
        and sometimes a space will be added.

        Parameters
        ----------
        final: char, optional `None`
            A character from the final space list (`fusus.char.UChar.finalSpace`).
            If None, all such characters will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of final space characters with occurrence statistics.
        &#34;&#34;&#34;

        finalSpace = self.finalSpace
        finalsApplied = self.finalsApplied

        theseFinals = (
            finalSpace if final is None else {final} if final in finalSpace else set()
        )

        html = []
        totalFinals = len(finalSpace)
        totalApplications = sum(sum(x.values()) for x in finalsApplied.values())
        totalPages = len(set(chain.from_iterable(finalsApplied.values())))
        finalRep = &#34;final&#34; + (&#34;&#34; if totalFinals == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalFinals} {finalRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (f, applied) in sorted(
            finalsApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if f not in theseFinals:
                continue
            finalRep = self.showChar(f)

            total = sum(applied.values())
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{finalRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showLineHeights"><code class="name flex">
<span>def <span class="ident">showLineHeights</span></span>(<span>self, pageNumSpec)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows how line heights have been determined.</p>
<p>The pages can be selected by page numbers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1314-L1346" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showLineHeights(self, pageNumSpec):
    &#34;&#34;&#34;Shows how line heights have been determined.

    The pages can be selected by page numbers.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.
    &#34;&#34;&#34;

    heights = self.heights
    clusteredHeights = self.clusteredHeights

    for pageNum in self.parsePageNums(pageNumSpec):
        theseHeights = heights[pageNum]
        theseClusteredHeights = clusteredHeights[pageNum]

        print(f&#34;Line heights page {pageNum:&gt;3}&#34;)
        print(&#34;\nraw heights&#34;)
        for k in sorted(theseHeights):
            print(f&#34;{theseHeights[k]:&gt;4} characters @ height {int(round(k)):&gt;4}&#34;)

        print(&#34;line heights&#34;)
        for (ln, kc) in enumerate(sorted(theseClusteredHeights)):
            peak = &#34;, &#34;.join(
                f&#34;{int(round(k)):&gt;4}&#34; for k in sorted(theseClusteredHeights[kc])
            )
            print(
                f&#34;line {ln + 1:&gt;2}: &#34;
                f&#34;{sum(theseHeights[k] for k in theseClusteredHeights[kc]):&gt;4}&#34;
                f&#34; characters @height {peak}&#34;
            )</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showLines"><code class="name flex">
<span>def <span class="ident">showLines</span></span>(<span>self, pageNumSpec, line=None, start=None, end=None, search=None, orig=False, every=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs processed lines as a formatted HTML table.</p>
<p>The lines can be selected by page numbers and line numbers.</p>
<p>Within the selected lines, the characters can be selected by
start/end postions, or by characters of interest.</p>
<p>All of these indices start at 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>A specification of zero or more line numbers (see <code><a title="fusus.lib.parseNums" href="lib.html#fusus.lib.parseNums">parseNums()</a></code>).</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>Starting word position in each line to be output.
If <code>None</code>, starts at the beginning of each line.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>End word position in each line to be output.
If <code>None</code>, ends at the end of each line.</dd>
<dt><strong><code>search</code></strong> :&ensp;<code>string</code> or <code>iterable</code> of <code>char</code>, optional <code>None</code></dt>
<dd>If not none, all characters in <code>search</code> are deemed interesting.
All occurrences of these characters within the selected lines are
displayed, included a small context.</dd>
<dt><strong><code>orig</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only meaningful if <code>search</code> is given.
If <code>True</code>: the check for interesting
characters is done in the original, untranslated characters.
Otherwise, interesting characters are looked up in the translated
characters.</dd>
<dt><strong><code>every</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only meaningful if <code>search</code> is given.
If <code>True</code>, when looking for interesting characters, all occurrences will
be retrieved, otherwise only the first one.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The output material will be displayed in the notebook.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1777-L1914" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showLines(
        self,
        pageNumSpec,
        line=None,
        start=None,
        end=None,
        search=None,
        orig=False,
        every=False,
    ):
        &#34;&#34;&#34;Outputs processed lines as a formatted HTML table.

        The lines can be selected by page numbers and line numbers.

        Within the selected lines, the characters can be selected by
        start/end postions, or by characters of interest.

        All of these indices start at 1.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).
        start: integer, optional `None`
            Starting word position in each line to be output.
            If `None`, starts at the beginning of each line.
        end: integer, optional `None`
            End word position in each line to be output.
            If `None`, ends at the end of each line.
        search: string or iterable of char, optional `None`
            If not none, all characters in `search` are deemed interesting.
            All occurrences of these characters within the selected lines are
            displayed, included a small context.
        orig: boolean, optional `False`
            Only meaningful if `search` is given.
            If `True`: the check for interesting
            characters is done in the original, untranslated characters.
            Otherwise, interesting characters are looked up in the translated
            characters.
        every: boolean, optional `False`
            Only meaningful if `search` is given.
            If `True`, when looking for interesting characters, all occurrences will
            be retrieved, otherwise only the first one.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        lines = self.lines
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)

        myLines = {pageNum: lines[pageNum] for pageNum in pageNums if pageNum in lines}

        html = []
        html.append(&#34;&lt;table&gt;&#34;)
        html.append(
            &#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;seq&lt;/th&gt;
    &lt;th&gt;top&lt;/th&gt;
    &lt;th&gt;bottom&lt;/th&gt;
    &lt;th&gt;left&lt;/th&gt;
    &lt;th&gt;right&lt;/th&gt;
    &lt;th&gt;spacing&lt;/th&gt;
    &lt;th&gt;font&lt;/th&gt;
    &lt;th&gt;size&lt;/th&gt;
    &lt;th&gt;orig char&lt;/th&gt;
    &lt;th&gt;char&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
        )

        shift = 5

        for (pageNum, pageLines) in myLines.items():
            myLineNums = (
                range(1, len(pageLines) + 1)
                if lineNums is None
                else [ln for ln in lineNums if 0 &lt; ln &lt;= len(pageLines)]
            )
            for ln in myLineNums:
                chars = pageLines[ln - 1]
                nChars = len(chars)
                html.append(
                    f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;th colspan=3&gt;page {pageNum}&lt;/th&gt;
    &lt;th colspan=2&gt;line {ln}&lt;/th&gt;
    &lt;th colspan=3&gt;{nChars} characters&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                )
                if search is None:
                    ranges = [(max((start or 0) - 1, 0), min(end or nChars, nChars))]
                else:
                    ranges = []

                    for (i, char) in enumerate(chars):
                        if search in char[-2 if orig else -1]:
                            occStart = max((i - shift, 0))
                            occEnd = min((i + shift + 1, nChars))
                            if ranges and occStart &lt;= ranges[-1][1]:
                                ranges[-1][1] = occEnd
                            else:
                                ranges.append([occStart, occEnd])
                            if not every:
                                break

                for (occStart, occEnd) in ranges:
                    for i in range(occStart, occEnd):
                        char = chars[i]
                        (le, to, ri, bo, font, size, spacing, oc, c) = char
                        html.append(
                            f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;{i + 1}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;{ptRepD(to)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(bo)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(le)}&lt;/td&gt;
    &lt;td&gt;{ptRepD(ri)}&lt;/td&gt;
    &lt;td&gt;{spacing}&lt;/td&gt;
    &lt;td&gt;{font}&lt;/td&gt;
    &lt;td&gt;{size}pt&lt;/td&gt;
    &lt;td&gt;{&#34;&#34;.join(self.showChar(x) for x in reversed(oc))}&lt;/td&gt;
    &lt;td&gt;{&#34;&#34;.join(self.showChar(x) for x in reversed(c))}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                        )
                if search and ranges and not every:
                    break

        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showReplacements"><code class="name flex">
<span>def <span class="ident">showReplacements</span></span>(<span>self, rule=None, isApplied=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a character conversion rule and how it has been applied.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rule</code></strong> :&ensp;<code>string|int</code>, optional <code>None</code></dt>
<dd>A specification of zero or more rule numbers (see <code><a title="fusus.lib.parseNums" href="lib.html#fusus.lib.parseNums">parseNums()</a></code>).
If None, all rules will be taken.</dd>
<dt><strong><code>isApplied</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Only show rules that have been applied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>Displays a table of rules with usage statistics.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1098-L1172" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showReplacements(self, rule=None, isApplied=False):
        &#34;&#34;&#34;Show a character conversion rule and how it has been applied.

        Parameters
        ----------
        rule: string|int, optional `None`
            A specification of zero or more rule numbers (see `fusus.lib.parseNums`).
            If None, all rules will be taken.
        isApplied: boolean, optional `False`
            Only show rules that have been applied.

        Returns
        -------
        None
            Displays a table of rules with usage statistics.
        &#34;&#34;&#34;

        ruleIndex = self.ruleIndex
        rulesApplied = self.rulesApplied
        ruleNums = parseNums(rule)
        ruleNums = (
            set(ruleIndex)
            if ruleNums is None
            else sorted(r for r in ruleNums if r in ruleIndex)
        )

        html = []
        totalRules = len(ruleIndex)
        totalApplications = sum(sum(x.values()) for x in rulesApplied.values())
        totalPages = len(set(chain.from_iterable(rulesApplied.values())))
        ruleRep = &#34;rule&#34; + (&#34;&#34; if totalRules == 1 else &#34;s&#34;)
        appRep = &#34;application&#34; + (&#34;&#34; if totalApplications == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalRules} {ruleRep} with
{totalApplications} {appRep} on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for (rn, applied) in sorted(
            rulesApplied.items(), key=lambda x: (-sum(x[1].values()), x[0])
        ):
            if rn not in ruleNums:
                continue
            (vals, d, repls, e) = ruleIndex[rn]

            valRep = &#34;&#34;.join(self.showChar(c) for c in vals)
            replRep = &#34;&#34;.join(self.showChar(c) for c in repls)
            total = sum(applied.values())
            if isApplied and not applied:
                continue
            if applied:
                examplePageNum = sorted(applied, key=lambda p: -applied[p])[0]
                nExamples = applied[examplePageNum]
                appliedEx = f&#34;e.g. page {examplePageNum} with {nExamples} applications&#34;
            else:
                appliedEx = &#34;&#34;
            appliedRep = f&#34;&lt;b&gt;{total}&lt;/b&gt; x applied on &lt;i&gt;{len(applied)}&lt;/i&gt; pages&#34;
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;rule {rn}&lt;/th&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{appliedEx}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{valRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;span class=&#34;lrg&#34;&gt;â‡’&lt;/span&gt;&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;{replRep}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )

        html.append(&#34;&lt;table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showSpacing"><code class="name flex">
<span>def <span class="ident">showSpacing</span></span>(<span>self, pageNumSpec, line=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show where the spaces are.</p>
<p>Gives an overview of the white space positions in each line.</p>
<p>It is useful to debug the horizontal white space algorithm.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>A specification of zero or more line numbers (see <code><a title="fusus.lib.parseNums" href="lib.html#fusus.lib.parseNums">parseNums()</a></code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The output material will be displayed in the notebook.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2176-L2216" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showSpacing(self, pageNumSpec, line=None):
    &#34;&#34;&#34;Show where the spaces are.

    Gives an overview of the white space positions in each line.

    It is useful to debug the horizontal white space algorithm.

    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.
    line: None | int | string | iterable
        A specification of zero or more line numbers (see `fusus.lib.parseNums`).

    Returns
    -------
    None
        The output material will be displayed in the notebook.
    &#34;&#34;&#34;

    pageNums = self.parsePageNums(pageNumSpec)
    lineNums = parseNums(line)
    lineNums = None if lineNums is None else set(lineNums)

    spaces = self.spaces

    for pageNum in pageNums:
        if pageNum not in spaces:
            continue

        print(f&#34;page {pageNum:&gt;3}&#34;)
        lineInfo = spaces[pageNum]

        for (ln, spaces) in lineInfo.items():
            if lineNums is not None and ln not in lineNums:
                continue

            print(f&#34;\tline {ln:&gt;2}&#34;)

            for (i, after, isSpace) in spaces:
                print(f&#34;\t\t{i + 1:&gt;3} {&#39;]  [&#39; if isSpace else &#39;]==[&#39;} {after}&#34;)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showString"><code class="name flex">
<span>def <span class="ident">showString</span></span>(<span>self, s, asString=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty display of a string as a series of unicode characters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>string</code></dt>
<dd>The string to display, may be empty, may contain place holders.</dd>
<dt><strong><code>asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, return the result as an HTML string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None | string</code></dt>
<dd>If <code>asString</code>, returns an HTML string, otherwise returns None,
but displays the HTML string.</dd>
</dl>
<p>See also <code><a title="fusus.lakhnawi.Lakhnawi.showChar" href="#fusus.lakhnawi.Lakhnawi.showChar">Lakhnawi.showChar()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1070-L1096" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showString(self, s, asString=False):
    &#34;&#34;&#34;Pretty display of a string as a series of unicode characters.

    Parameters
    ----------
    s: string
        The string to display, may be empty, may contain place holders.
    asString: boolean, optional `False`
        If True, return the result as an HTML string.

    Returns
    -------
    None | string
        If `asString`, returns an HTML string, otherwise returns None,
        but displays the HTML string.

    See also `Lakhnawi.showChar()`.
    &#34;&#34;&#34;

    shtml = f&#34;&#34;&#34;&lt;span class=&#34;r&#34;&gt;{s}&lt;/span&gt;&#34;&#34;&#34;
    html = &#34;&#34;&#34;&lt;div class=&#34;sr&#34;&gt;&#34;&#34;&#34; + (
        &#34;&#34;.join(self.showChar(c) for c in s) + &#34;&lt;/div&gt;&#34;
    )
    if asString:
        return f&#34;&#34;&#34;&lt;span&gt;{shtml}&lt;/span&gt;{html}&#34;&#34;&#34;

    display(HTML(f&#34;&#34;&#34;&lt;p&gt;{shtml}&lt;/p&gt;{html}&#34;&#34;&#34;))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showUsedChars"><code class="name flex">
<span>def <span class="ident">showUsedChars</span></span>(<span>self, pageNumSpec, orig=False, onlyPuas=False, onlyPresentational=False, long=False, byOcc=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Show used characters.</p>
<p>Gives an overview of character usage, either in the input PDF, or in
the text output.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>orig</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>: shows characters of the original PDF.
Otherwise, shows characters of the translated output/</dd>
<dt><strong><code>onlyPuas</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, the result is restricted to private use characters.</dd>
<dt><strong><code>onlyPresentational</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, the result is restricted to presentational characters.
See <code><a title="fusus.char.UChar.presentational" href="char.html#fusus.char.UChar.presentational">UChar.presentational</a></code>.</dd>
<dt><strong><code>long</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, for each character output the complete list of pages
where the character occurs. Otherwise, show only the most
prominent pages.</dd>
<dt><strong><code>byOcc</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If <code>True</code>, sort the results by first occurrence of the characters.
Otherwise, sort the results by unicode code point of the character.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The output material will be displayed in the notebook.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1996-L2133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showUsedChars(
        self,
        pageNumSpec,
        orig=False,
        onlyPuas=False,
        onlyPresentational=False,
        long=False,
        byOcc=False,
    ):
        &#34;&#34;&#34;Show used characters.

        Gives an overview of character usage, either in the input PDF, or in
        the text output.


        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        orig: boolean, optional `False`
            If `True`: shows characters of the original PDF.
            Otherwise, shows characters of the translated output/
        onlyPuas: boolean, optional `False`
            If `True`, the result is restricted to private use characters.
        onlyPresentational: boolean, optional `False`
            If `True`, the result is restricted to presentational characters.
            See `fusus.char.UChar.presentational`.
        long: boolean, optional `False`
            If `True`, for each character output the complete list of pages
            where the character occurs. Otherwise, show only the most
            prominent pages.
        byOcc: boolean, optional `False`
            If `True`, sort the results by first occurrence of the characters.
            Otherwise, sort the results by unicode code point of the character.

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        presentational = self.presentational
        pageNums = self.parsePageNums(pageNumSpec)
        text = self.text
        lines = self.lines
        puas = self.puas

        charsOut = collections.defaultdict(collections.Counter)

        def keyByOcc(c):
            pageNums = charsOut[c]
            return -sum(pageNums.values())

        sortKey = keyByOcc if byOcc else lambda x: x

        if orig:
            lns = {pageNum: lines[pageNum] for pageNum in pageNums if pageNum in lines}

            for (pageNum, pageLines) in lns.items():
                for line in pageLines:
                    for char in line:
                        c = char[-2]
                        if c in puas or (
                            not onlyPuas
                            and (c in presentational or not onlyPresentational)
                        ):
                            charsOut[c][pageNum] += 1

        else:
            texts = {pageNum: text[pageNum] for pageNum in pageNums if pageNum in text}

            for (pageNum, pageText) in texts.items():
                for line in pageText:
                    for col in line:
                        for span in col:
                            for word in span[1]:
                                letters = word[0]
                                punc = word[1]
                                thesePuas = PUA_RE.findall(letters)
                                for pua in thesePuas:
                                    charsOut[chr(int(pua, base=16))][pageNum] += 1
                                if not onlyPuas:
                                    rest = PUA_RE.sub(&#34;&#34;, f&#34;{letters}{punc}&#34;)
                                    for c in rest:
                                        if not (
                                            onlyPresentational
                                            and c not in presentational
                                        ):
                                            charsOut[c][pageNum] += 1

        totalChars = len(charsOut)
        totalPages = len(set(chain.from_iterable(charsOut.values())))
        totalOccs = sum(sum(pns.values()) for pns in charsOut.values())

        charRep = &#34;character&#34; + (&#34;&#34; if totalChars == 1 else &#34;s&#34;)
        occRep = &#34;occurence&#34; + (&#34;&#34; if totalOccs == 1 else &#34;s&#34;)
        pageRep = &#34;page&#34; + (&#34;&#34; if totalPages == 1 else &#34;s&#34;)

        label = &#34;private use &#34; if onlyPuas else &#34;&#34;

        html = []
        html.append(
            f&#34;&#34;&#34;
&lt;p&gt;&lt;b&gt;{totalChars} {label}{charRep} in {totalOccs} {occRep}
on {totalPages} {pageRep}&lt;/b&gt;&lt;/p&gt;
&lt;table&gt;
&#34;&#34;&#34;
        )

        for c in sorted(charsOut, key=sortKey):
            pageNums = charsOut[c]
            nPageNums = len(pageNums)
            pageRep = &#34;page&#34; + (&#34;&#34; if nPageNums == 1 else &#34;s&#34;)
            thistotal = sum(pageNums.values())
            examplePageNum = sorted(pageNums, key=lambda p: -pageNums[p])[0]
            nExamples = pageNums[examplePageNum]
            html.append(
                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td class=&#34;al&#34;&gt;{self.showChar(c)}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;b&gt;{thistotal}&lt;/b&gt; on &lt;i&gt;{nPageNums}&lt;/i&gt; {pageRep}&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;e.g. page {examplePageNum} with &lt;b&gt;{nExamples}&lt;/b&gt; occurrences&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
            )
            if long:
                for pn in sorted(pageNums):
                    occs = pageNums[pn]
                    html.append(
                        f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;/td&gt;
    &lt;td class=&#34;al&#34;&gt;&lt;i&gt;page {pn:&gt;3}&lt;/i&gt;: &lt;b&gt;{occs:&gt;3}&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                    )
        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.showWords"><code class="name flex">
<span>def <span class="ident">showWords</span></span>(<span>self, pageNumSpec, line=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs processed words as a formatted HTML table.</p>
<p>The lines can be selected by page numbers and line numbers.</p>
<p>All words within the selected lines are put into a table with
the same properties as in the TSV data,
see <code><a title="fusus.lakhnawi.Lakhnawi.tsvPages" href="#fusus.lakhnawi.Lakhnawi.tsvPages">Lakhnawi.tsvPages()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>A specification of zero or more line numbers (see <code><a title="fusus.lib.parseNums" href="lib.html#fusus.lib.parseNums">parseNums()</a></code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The output material will be displayed in the notebook.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1916-L1994" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def showWords(self, pageNumSpec, line=None):
        &#34;&#34;&#34;Outputs processed words as a formatted HTML table.

        The lines can be selected by page numbers and line numbers.

        All words within the selected lines are put into a table with
        the same properties as in the TSV data,
        see `Lakhnawi.tsvPages`.

        Parameters
        ----------
        pageNumSpec: None | int | string | iterable
            As in `Lakhnawi.parsePageNums()`.
        line: None | int | string | iterable
            A specification of zero or more line numbers (see `fusus.lib.parseNums`).

        Returns
        -------
        None
            The output material will be displayed in the notebook.
        &#34;&#34;&#34;

        text = self.text
        pageNums = self.parsePageNums(pageNumSpec)
        lineNums = parseNums(line)

        myLines = {pageNum: text[pageNum] for pageNum in pageNums if pageNum in text}

        html = []
        html.append(&#34;&lt;table&gt;&#34;)
        html.append(
            &#34;&#34;&#34;
&lt;tr&gt;
    &lt;th&gt;page&lt;/th&gt;
    &lt;th&gt;line&lt;/th&gt;
    &lt;th&gt;col&lt;/th&gt;
    &lt;th&gt;span&lt;/th&gt;
    &lt;th&gt;dir&lt;/th&gt;
    &lt;th&gt;left&lt;/th&gt;
    &lt;th&gt;top&lt;/th&gt;
    &lt;th&gt;right&lt;/th&gt;
    &lt;th&gt;bottom&lt;/th&gt;
    &lt;th&gt;letters&lt;/th&gt;
    &lt;th&gt;punc&lt;/th&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
        )

        for (pageNum, pageLines) in myLines.items():
            myLineNums = (
                range(1, len(pageLines) + 1)
                if lineNums is None
                else [ln for ln in lineNums if 0 &lt; ln &lt;= len(pageLines)]
            )
            for ln in myLineNums:
                cols = pageLines[ln - 1]
                for (cn, spans) in enumerate(cols):
                    for (sn, (dr, words)) in enumerate(spans):
                        for (letters, punc, (le, to, ri, bo)) in words:
                            html.append(
                                f&#34;&#34;&#34;
&lt;tr&gt;
    &lt;td&gt;&lt;b&gt;{pageNum}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;b&gt;{ln}&lt;/b&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{cn + 1}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{sn + 1}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;&lt;i&gt;{dr}&lt;/i&gt;&lt;/td&gt;
    &lt;td&gt;{ptRep(le)}&lt;/td&gt;
    &lt;td&gt;{ptRep(to)}&lt;/td&gt;
    &lt;td&gt;{ptRep(ri)}&lt;/td&gt;
    &lt;td&gt;{ptRep(bo)}&lt;/td&gt;
    &lt;td&gt;{self.showString(letters, asString=True)}&lt;/td&gt;
    &lt;td&gt;{self.showString(punc, asString=True)}&lt;/td&gt;
&lt;/tr&gt;
&#34;&#34;&#34;
                            )

        html.append(&#34;&lt;/table&gt;&#34;)
        display(HTML(&#34;&#34;.join(html)))</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.trimLine"><code class="name flex">
<span>def <span class="ident">trimLine</span></span>(<span>self, pageNum, ln, chars)</span>
</code></dt>
<dd>
<div class="desc"><p>Map character sequences to other sequences.</p>
<p>Two tasks:</p>
<ol>
<li>Map private use characters to well-known unicode characters</li>
<li>Insert space characters where the next character is separated from the
previous one.</li>
</ol>
<p>Complications:</p>
<p>Diacritical characters are mostly contained in a very wide box that overlaps
with the boxes of the other characters. So the diacritical boxes must not be
taken into account.</p>
<p>Private use characters often come in sequences, so a sequence of characters
must be transformed to another sequence.</p>
<p>We do the tramsformation before the space insertion, because otherwise we
might insert the space at the wrong point.</p>
<p>When we transform characters we need to retain the box information,
because we still have to insert the space.</p>
<p>That's why we have as input a list of character records, where each record
is itself a list with box information, orginal character, modified characters
and space information.</p>
<p>When we transform characters, we modify character records in place.
We do not add or remove character records.</p>
<p>The last member of a character record is the modified sequence.
This can be zero, one, or multiple characters.
The second last member is the original character.
Initially, the the last and second last member of each record are equal.
We call these members the original character and the result string.</p>
<p>Space will be appended at the last member of the appropriate character records.</p>
<p>The transformations are given as a set of rules.</p>
<p>See <code>REPLACE_DEFS</code>.</p>
<p>A rule consists of a sequence of characters to match and a sequence of
characters to replace the match with. We call them the match sequence and the
replacement sequence of the rule.</p>
<p>For each character in the input list we check which rules have a match sequence
that start with this character.
Of these rules, we start with the one with the longest match sequence.
We then check, by looking ahead, whether the whole match sequence matches the
input.
For the purposes of matching, we look into the result strings of the character,
not to the original characters. This will prevent some rules to be applied
after an earlier rule has been applied. This is intentional, and results
in a more simple rule set.</p>
<p>If there is a match, we walk through all the characters in the input for the
length of the match sequence of the rule.
For each input character record, we set its replacement string to the
corresponding member of the replacement sequence of the rule.
If the replacement sequence has run out, we replace with the empty string.
If after this process the replacement sequence has not been exhausted,
we join the remaining characters in the replacement string and append it
after the replacement string of the last input character that we have visited.</p>
<p>After succesful application of a rule, we do not apply other rules that would
have been applicable at this point. Instead, we move our starting point to the
next character record in the sequence and repeat the matching process.</p>
<p>It might be that a character is replaced multiple times, for example when
it is reached by a rule while looking ahead 3 places, and then later by a
different rule looking ahead two places.</p>
<p>However, once a character matches the first member of the match sequence of
a rule, and the rule matches and is applied, that character will not be
changed anymore by any other rule.</p>
<div class="admonition caution">
<p class="admonition-title">place holders for diacritics</p>
<p>The following functionality exists in the code, but is not needed anymore
to process the Lakhnawi PDF.</p>
<p>The match sequence may contain the character <code>d</code>, which is a placeholder
for a diacritic sign. It will match any diacritic.
The replacement sequence of such a rule may or may not contain a <code>d</code>.
It is an error if the replacement seqience of a rule contains a <code>d</code> while
its match sequence does not.
It is also an error of there are multiple <code>d</code>s in a match sequence
of a replacement sequence.
If so, the working of this rule is effectively two rules:</p>
<p>Suppose the rule is</p>
<p>x d y =&gt; r d s</p>
<p>where x, y, r, s are sequences of arbitrary length.
If the rule matches the input, then first the rule</p>
<p>x =&gt; r</p>
<p>will be applied at the current position.</p>
<p>Then we shift temporarily to the position right after where the d has matched,
and apply the rule</p>
<p>y =&gt; s</p>
<p>Then we shift back to the orginal position plus one, and continue applying
rules.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2387-L2865" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trimLine(self, pageNum, ln, chars):
    &#34;&#34;&#34;Map character sequences to other sequences.

    Two tasks:

    1. Map private use characters to well-known unicode characters
    2. Insert space characters where the next character is separated from the
       previous one.

    Complications:

    Diacritical characters are mostly contained in a very wide box that overlaps
    with the boxes of the other characters. So the diacritical boxes must not be
    taken into account.

    Private use characters often come in sequences, so a sequence of characters
    must be transformed to another sequence.

    We do the tramsformation before the space insertion, because otherwise we
    might insert the space at the wrong point.

    When we transform characters we need to retain the box information,
    because we still have to insert the space.

    That&#39;s why we have as input a list of character records, where each record
    is itself a list with box information, orginal character, modified characters
    and space information.

    When we transform characters, we modify character records in place.
    We do not add or remove character records.

    The last member of a character record is the modified sequence.
    This can be zero, one, or multiple characters.
    The second last member is the original character.
    Initially, the the last and second last member of each record are equal.
    We call these members the original character and the result string.

    Space will be appended at the last member of the appropriate character records.

    The transformations are given as a set of rules.

    See `REPLACE_DEFS`.

    A rule consists of a sequence of characters to match and a sequence of
    characters to replace the match with. We call them the match sequence and the
    replacement sequence of the rule.

    For each character in the input list we check which rules have a match sequence
    that start with this character.
    Of these rules, we start with the one with the longest match sequence.
    We then check, by looking ahead, whether the whole match sequence matches the
    input.
    For the purposes of matching, we look into the result strings of the character,
    not to the original characters. This will prevent some rules to be applied
    after an earlier rule has been applied. This is intentional, and results
    in a more simple rule set.

    If there is a match, we walk through all the characters in the input for the
    length of the match sequence of the rule.
    For each input character record, we set its replacement string to the
    corresponding member of the replacement sequence of the rule.
    If the replacement sequence has run out, we replace with the empty string.
    If after this process the replacement sequence has not been exhausted,
    we join the remaining characters in the replacement string and append it
    after the replacement string of the last input character that we have visited.

    After succesful application of a rule, we do not apply other rules that would
    have been applicable at this point. Instead, we move our starting point to the
    next character record in the sequence and repeat the matching process.

    It might be that a character is replaced multiple times, for example when
    it is reached by a rule while looking ahead 3 places, and then later by a
    different rule looking ahead two places.

    However, once a character matches the first member of the match sequence of
    a rule, and the rule matches and is applied, that character will not be
    changed anymore by any other rule.

    !!! caution &#34;place holders for diacritics&#34;
        The following functionality exists in the code, but is not needed anymore
        to process the Lakhnawi PDF.

        The match sequence may contain the character `d`, which is a placeholder
        for a diacritic sign. It will match any diacritic.
        The replacement sequence of such a rule may or may not contain a `d`.
        It is an error if the replacement seqience of a rule contains a `d` while
        its match sequence does not.
        It is also an error of there are multiple `d`s in a match sequence
        of a replacement sequence.
        If so, the working of this rule is effectively two rules:

        Suppose the rule is

        x d y =&gt; r d s

        where x, y, r, s are sequences of arbitrary length.
        If the rule matches the input, then first the rule

        x =&gt; r

        will be applied at the current position.

        Then we shift temporarily to the position right after where the d has matched,
        and apply the rule

        y =&gt; s

        Then we shift back to the orginal position plus one, and continue applying
        rules.
    &#34;&#34;&#34;

    replace = self.replace
    puas = self.puas
    neutrals = self.neutrals
    rls = self.rls
    rulesApplied = self.rulesApplied
    spaces = self.spaces
    columns = self.columns
    diacritics = self.diacritics
    punct = self.punct
    diacriticLike = self.diacriticLike
    arabicLetters = self.arabicLetters
    presentationalC = self.presentationalC
    presentationalD = self.presentationalD
    finalSpace = self.finalSpace
    finalsApplied = self.finalsApplied
    nonLetter = self.nonLetter
    doRules = self.doRules
    doFilter = self.doFilter

    nChars = len(chars)

    # rule application stage

    if doRules:
        for (i, char) in enumerate(chars):
            c = char[-1]

            if c in replace:
                rules = replace[c]
                for (rn, vals, d, repls, e) in rules:

                    nVals = len(vals)

                    if i + nVals &gt; nChars:
                        # not enough characters left to match this rule
                        continue

                    if not all(
                        (
                            d is not None
                            and j == d
                            and chars[i + j][-1]
                            in (diacritics if vals[d] == 1 else arabicLetters)
                        )
                        or chars[i + j][-1] == vals[j]
                        for j in range(nVals)
                    ):
                        # the rule does not match after all
                        continue

                    # the rule matches: we are going to fill in the replacements
                    # if there is a diacritic in the match sequence or the
                    # replacement sequence, we restrict ourselves to the parts
                    # before the diacritics.

                    rulesApplied[rn][pageNum] += 1

                    nRepls = len(repls)
                    dEnd = nVals if d is None else d
                    eEnd = nRepls if e is None else e

                    # so, we are going to replace from here to dEnd (not including)

                    for j in range(dEnd):
                        # put the appropriate replacement character in the
                        # replacement part of the character record
                        # After running out of replacement characters, put in &#34;&#34;
                        chars[i + j][-1] = repls[j] if j &lt; eEnd else &#34;&#34;

                    if eEnd &gt; dEnd:
                        # if there are replacement characters left, put them
                        # in after the last character that we have visited.

                        if dEnd == 0:
                            # In case we have not visited any yet,
                            # we put them in before the current character
                            cd = chars[i + dEnd][-1]
                            r = &#34;&#34;.join(repls[dEnd + 1 :])
                            chars[i + dEnd][-1] = f&#34;{r}{cd}&#34;
                        else:
                            # this is the normal case
                            chars[i + dEnd - 1][-1] += &#34;&#34;.join(repls[dEnd:eEnd])

                    # if there is a diacritic in the match sequence
                    # we are going to perform the rule for the part
                    # after the diacritic

                    # Note that the case where d is None and e is not None
                    # does not occur

                    if d is not None:
                        # we set the starting points: just after the diacritics
                        dStart = d + 1
                        # if the replacement part does not have a diacritic,
                        # we have already consumed it, and we start right after it
                        eStart = nRepls if e is None else e + 1

                        # we compute the number of characters that still need to be
                        # matched and to be replaced
                        dn = nVals - dStart
                        en = nRepls - eStart

                        # we perform the replacement analogously to what we did
                        # for the first part

                        for j in range(dn):
                            # put the appropriate replacement character in the
                            # replacement part of the character record
                            # After running out of replacement characters, put in &#34;&#34;
                            chars[i + dStart + j][-1] = (
                                repls[eStart + j] if eStart + j &lt; nRepls else &#34;&#34;
                            )
                        if en &gt; dn:
                            # if there are replacement characters left, put them
                            # in after the last character that we have visited.
                            chars[i + nVals - 1][-1] += &#34;&#34;.join(
                                repls[eStart + dn :]
                            )
                    break

    # sift out all presentational characters

    if doFilter:
        trailSpace = False

        for (i, char) in enumerate(chars):
            c = char[-1]
            string = &#34;&#34;
            for x in c:
                if trailSpace:
                    if x not in diacriticLike:
                        if x not in nonLetter:
                            if string == &#34;&#34; and i &gt; 0:
                                chars[i - 1][-1] += &#34; &#34;
                            else:
                                string += &#34; &#34;
                        trailSpace = False

                hasFinalSpace = x in finalSpace
                y = (
                    normalizeC(x)
                    if x in presentationalC
                    else normalizeD(x)
                    if x in presentationalD
                    else x
                ).strip()
                space = &#34; &#34; if hasFinalSpace or x in punct else &#34;&#34;
                if hasFinalSpace:
                    finalsApplied[x][pageNum] += 1
                string += y
                if space:
                    trailSpace = True
            char[-1] = string

        if trailSpace:
            if chars:
                chars[-1][-1] += &#34; &#34;

    # add horizontal spacing

    theseSpaces = []
    spaces[pageNum][ln] = theseSpaces

    threshold = None
    theseColumns = [threshold, []]
    columns[pageNum][ln] = theseColumns

    prevLeft = None
    prevLeftI = None

    for (i, char) in enumerate(chars):
        spacing = char[-3]

        if spacing:
            left = char[0]
            right = char[2]

            if prevLeft is not None:
                prevChar = chars[prevLeftI]
                after = prevLeft - right
                theAfter = ptRepD(after)

                isSpace = theAfter &gt;= SPACE_THRESHOLD
                if isSpace:
                    lastChar = chars[i - 1]
                    if not lastChar[-1].endswith(&#34; &#34;):
                        lastChar[-1] += &#34; &#34;

                prevChar[-3] = f&#34;âŒŠ{theAfter}âŒ‹&#34; if isSpace else f&#34;Â«{theAfter}Â»&#34;
                theseSpaces.append((i - 1, theAfter, isSpace))

            prevLeft = left
            prevLeftI = i

    if chars:
        chars[-1][-3] = &#34;end&#34;

    # change big spaces to emspaces

    nSpaces = sum(1 for x in theseSpaces if x[2])

    if nSpaces == 1:
        threshold = 90
    elif nSpaces &gt; 1:
        spacesGrowing = sorted(x[1] for x in theseSpaces if x[2])
        maxSpace = spacesGrowing[-1]
        medialSpace = spacesGrowing[nSpaces // 2]
        if maxSpace &gt; 4 * medialSpace:
            threshold = maxSpace - medialSpace

    if threshold is not None:
        theseColumns[0] = threshold
        for (i, after, isSpace) in theseSpaces:
            if isSpace and after &gt; threshold:
                theseColumns[1].append((i, after))
                char = chars[i]
                char[-1] = char[-1].rstrip(&#34; &#34;) + EMSPACE

    # remove space between alef and initial follower,
    # provided the alef is the single letter in its word.

    # also for the words yeh+alef(final) and mem+alef(final) do:
    # insert a space behind the alef(final)

    curLen = 0
    prevCons = None
    pprevCons = None

    for (i, char) in enumerate(chars):
        c = char[-1]
        co = char[-2]
        r = &#34;&#34;

        isAFinal = isAlefFinal(co)

        for x in c:
            skip = False
            if x == &#34; &#34;:
                if curLen == 1:  # and prevC in PROCLITICS:
                    skip = True
                curLen = 0
                prevCons = None
                pprevCons = None
            elif x in arabicLetters:
                curLen += 1
                if 2 &lt;= curLen &lt;= 3 and isAFinal:
                    if isMeemOrYeh(prevCons) and (curLen == 2 or isWaw(pprevCons)):
                        x += &#34; &#34;
                        curLen = 0
                        prevCons = None
                        pprevCons = None
                pprevCons = prevCons
                prevCons = x
            if not skip:
                r += x
        char[-1] = r

    # divide lines into columns

    emspaces = theseColumns[1]
    emspacePositions = {t[0] for t in emspaces}

    columnedChars = [[]]
    dest = columnedChars[-1]

    for (i, char) in enumerate(chars):
        if i in emspacePositions:
            if char[-1]:
                dest.append(char)
            columnedChars.append([])
            dest = columnedChars[-1]
        else:
            dest.append(char)

    # divide columns into ranges
    # and chunk the ranges into words
    # and save the word boundary boxes

    text = self.text

    # text is a dict keyed by pageNum and the values are tuples of line data
    # a line datum is a list of columns
    # a column is a list of spans
    # a span is a pair of a direction char (&#34;l&#34; or &#34;r&#34;) plus a list of word data
    # a word datum is a string plus a word box
    # a word box is a (left, top, right, bottom) tuple

    result = []
    text.setdefault(pageNum, []).append(result)
    prevDir = &#34;r&#34;

    # we transform letters into chunks, where each chunk is a pair of
    # word material
    # punctuation material

    outChars = [[], []]
    inWord = True
    box = [None, None, None, None]

    def addWord():
        if outChars[0] or outChars[1]:
            wordCharsRep = &#34;&#34;.join(
                outChars[0] if prevDir == &#34;r&#34; else reversed(outChars[0])
            )
            puncCharsRep = &#34;&#34;.join(
                outChars[1] if prevDir == &#34;r&#34; else reversed(outChars[1])
            )
            lastSpan = None if len(result[-1]) == 0 else result[-1][-1]
            element = (wordCharsRep, puncCharsRep, tuple(box))
            if lastSpan is None or lastSpan[0] != prevDir:
                result[-1].append((prevDir, [element]))
            else:
                result[-1][-1][-1].append(element)

    def setBox(char):
        for (i, coor) in enumerate(char[0:4]):
            if (
                (b := box[i]) is None
                or (i &lt; 2 and coor &lt; b)
                or (i &gt;= 2 and coor &gt; b)
            ):
                box[i] = coor

    for chars in columnedChars:
        result.append([])
        outChars = [[], []]
        box = [None, None, None, None]

        for char in chars:
            c = char[-1]

            if c == &#34;&#34;:
                continue

            for d in c:
                spaceSeen = d in {&#34; &#34;, EMSPACE}
                changeWord = not inWord and d not in nonLetter

                if spaceSeen:
                    outChars[1].append(d)
                if spaceSeen or changeWord:
                    addWord()
                    box = [None, None, None, None]
                    outChars = [[d] if changeWord else [], []]
                    inWord = True
                    continue

                thisDir = prevDir if d in neutrals else &#34;r&#34; if d in rls else &#34;l&#34;

                if prevDir != thisDir:
                    addWord()
                    box = [None, None, None, None]
                    outChars = [[], []]
                    inWord = True
                    prevDir = thisDir

                if inWord:
                    if d in nonLetter:
                        inWord = False
                dest = 0 if inWord else 1
                rep = d
                if d in puas:
                    rep = f&#34;âŒŠ{ord(d):&gt;04x}âŒ‹&#34;
                outChars[dest].append(rep)

            setBox(char)

        addWord()</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.tsvHeadLine"><code class="name flex">
<span>def <span class="ident">tsvHeadLine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs the field names of a word in TSV data.</p>
<p>See <code><a title="fusus.lakhnawi.Lakhnawi.tsvPages" href="#fusus.lakhnawi.Lakhnawi.tsvPages">Lakhnawi.tsvPages()</a></code> for the structure of TSV data
as output format for the extracted text of the Lakhnawi PDF.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>A tab-separated line of field names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2893-L2905" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tsvHeadLine(self):
    &#34;&#34;&#34;Outputs the field names of a word in TSV data.

    See `Lakhnawi.tsvPages()` for the structure of TSV data
    as output format for the extracted text of the Lakhnawi PDF.

    Returns
    -------
    string
        A tab-separated line of field names.
    &#34;&#34;&#34;

    return &#34;page\tline\tcolumn\tspan\tdirection\tleft\ttop\tright\tbottom\tletters\tpunc\n&#34;</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.tsvLine"><code class="name flex">
<span>def <span class="ident">tsvLine</span></span>(<span>self, columns, pageNum, ln)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a processed line as lines of tab-separated fields for each word.</p>
<p>Used by <code><a title="fusus.lakhnawi.Lakhnawi.tsvPages" href="#fusus.lakhnawi.Lakhnawi.tsvPages">Lakhnawi.tsvPages()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>columns</code></strong> :&ensp;<code>iterable</code></dt>
<dd>An iterable of columns that make up a line.
Each column is an iterable of spans.
Spans contain words plus an indication of the writing direction
for that span.</dd>
<dt><strong><code>pageNum</code></strong> :&ensp;<code>int</code></dt>
<dd>The page number of the page where this line occurs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The concatenation of the TSV lines for all words in all spans
in all columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L2907-L2954" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tsvLine(self, columns, pageNum, ln):
    &#34;&#34;&#34;Outputs a processed line as lines of tab-separated fields for each word.

    Used by `Lakhnawi.tsvPages()`.

    Parameters
    ----------
    columns: iterable
        An iterable of columns that make up a line.
        Each column is an iterable of spans.
        Spans contain words plus an indication of the writing direction
        for that span.
    pageNum: int
        The page number of the page where this line occurs.

    Returns
    -------
    string
        The concatenation of the TSV lines for all words in all spans
        in all columns.
    &#34;&#34;&#34;

    material = []
    for (cn, spans) in enumerate(columns):
        for (sn, (dr, words)) in enumerate(spans):
            for (letters, punc, (le, to, ri, bo)) in words:
                material.append(
                    (
                        &#34;\t&#34;.join(
                            str(x)
                            for x in (
                                pageNum,
                                ln,
                                cn + 1,
                                sn + 1,
                                dr,
                                ptRep(le),
                                ptRep(to),
                                ptRep(ri),
                                ptRep(bo),
                                letters,
                                punc,
                            )
                        )
                    )
                    + &#34;\n&#34;
                )
    return &#34;&#34;.join(material)</code></pre>
</details>
</dd>
<dt id="fusus.lakhnawi.Lakhnawi.tsvPages"><code class="name flex">
<span>def <span class="ident">tsvPages</span></span>(<span>self, pageNumSpec)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs processed pages as tab-separated data.</p>
<p>See <code><a title="fusus.convert" href="convert.html">fusus.convert</a></code> for the details of the output format.</p>
<p>Uses
<code><a title="fusus.lakhnawi.Lakhnawi.tsvLine" href="#fusus.lakhnawi.Lakhnawi.tsvLine">Lakhnawi.tsvLine()</a></code>.
and <code><a title="fusus.lakhnawi.Lakhnawi.tsvHeadLine" href="#fusus.lakhnawi.Lakhnawi.tsvHeadLine">Lakhnawi.tsvHeadLine()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pageNumSpec</code></strong> :&ensp;<code>None | int | string | iterable</code></dt>
<dd>As in <code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">Lakhnawi.parsePageNums()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>
<p>The tab-separated data is written to a single tsv file.
There is a heading row.</p>
<p>The file is in <code><a title="fusus.parameters.UR_DIR" href="parameters.html#fusus.parameters.UR_DIR">UR_DIR</a></code>, under <code><a title="fusus.lakhnawi.Lakhnawi" href="#fusus.lakhnawi.Lakhnawi">Lakhnawi</a></code>.
The name of the file includes a page specification.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/among/fusus/blob/5e0a845cdcc0aadbfa2c0d41f16154b9bdaa56e2/fusus/lakhnawi.py#L1589-L1634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tsvPages(self, pageNumSpec):
    &#34;&#34;&#34;Outputs processed pages as tab-separated data.

    See `fusus.convert` for the details of the output format.

    Uses
    `Lakhnawi.tsvLine()`.
    and `Lakhnawi.tsvHeadLine()`.


    Parameters
    ----------
    pageNumSpec: None | int | string | iterable
        As in `Lakhnawi.parsePageNums()`.

    Returns
    -------
    None
        The tab-separated data is written to a single tsv file.
        There is a heading row.

        The file is in `fusus.parameters.UR_DIR`, under `Lakhnawi`.
        The name of the file includes a page specification.
    &#34;&#34;&#34;

    text = self.text

    destDir = f&#34;{UR_DIR}/{NAME}&#34;
    pageNums = self.parsePageNums(pageNumSpec)

    if not os.path.exists(destDir):
        os.makedirs(destDir, exist_ok=True)

    pageNumRep = ALL_PAGES if pageNumSpec is None else str(pageNumSpec)
    filePath = f&#34;{destDir}/{pageNumRep}.tsv&#34;
    fh = open(filePath, &#34;w&#34;)
    fh.write(self.tsvHeadLine())

    for pageNum in pageNums:
        lines = text.get(pageNum, [])

        for (ln, line) in enumerate(lines):
            fh.write(self.tsvLine(line, pageNum, ln + 1))

    fh.close()
    print(f&#34;TSV data written to {unexpanduser(filePath)}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fusus.char.UChar" href="char.html#fusus.char.UChar">UChar</a></b></code>:
<ul class="hlist">
<li><code><a title="fusus.char.UChar.arabic" href="char.html#fusus.char.UChar.arabic">arabic</a></code></li>
<li><code><a title="fusus.char.UChar.arabicLetters" href="char.html#fusus.char.UChar.arabicLetters">arabicLetters</a></code></li>
<li><code><a title="fusus.char.UChar.arabicPresentational" href="char.html#fusus.char.UChar.arabicPresentational">arabicPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.bracketMap" href="char.html#fusus.char.UChar.bracketMap">bracketMap</a></code></li>
<li><code><a title="fusus.char.UChar.diacriticLike" href="char.html#fusus.char.UChar.diacriticLike">diacriticLike</a></code></li>
<li><code><a title="fusus.char.UChar.diacritics" href="char.html#fusus.char.UChar.diacritics">diacritics</a></code></li>
<li><code><a title="fusus.char.UChar.finalSpace" href="char.html#fusus.char.UChar.finalSpace">finalSpace</a></code></li>
<li><code><a title="fusus.char.UChar.greekPresentational" href="char.html#fusus.char.UChar.greekPresentational">greekPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.hebrew" href="char.html#fusus.char.UChar.hebrew">hebrew</a></code></li>
<li><code><a title="fusus.char.UChar.hebrewPresentational" href="char.html#fusus.char.UChar.hebrewPresentational">hebrewPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.latinPresentational" href="char.html#fusus.char.UChar.latinPresentational">latinPresentational</a></code></li>
<li><code><a title="fusus.char.UChar.neutrals" href="char.html#fusus.char.UChar.neutrals">neutrals</a></code></li>
<li><code><a title="fusus.char.UChar.nonLetter" href="char.html#fusus.char.UChar.nonLetter">nonLetter</a></code></li>
<li><code><a title="fusus.char.UChar.nospacings" href="char.html#fusus.char.UChar.nospacings">nospacings</a></code></li>
<li><code><a title="fusus.char.UChar.presentational" href="char.html#fusus.char.UChar.presentational">presentational</a></code></li>
<li><code><a title="fusus.char.UChar.presentationalC" href="char.html#fusus.char.UChar.presentationalC">presentationalC</a></code></li>
<li><code><a title="fusus.char.UChar.presentationalD" href="char.html#fusus.char.UChar.presentationalD">presentationalD</a></code></li>
<li><code><a title="fusus.char.UChar.puas" href="char.html#fusus.char.UChar.puas">puas</a></code></li>
<li><code><a title="fusus.char.UChar.punct" href="char.html#fusus.char.UChar.punct">punct</a></code></li>
<li><code><a title="fusus.char.UChar.rls" href="char.html#fusus.char.UChar.rls">rls</a></code></li>
<li><code><a title="fusus.char.UChar.semis" href="char.html#fusus.char.UChar.semis">semis</a></code></li>
<li><code><a title="fusus.char.UChar.stops" href="char.html#fusus.char.UChar.stops">stops</a></code></li>
<li><code><a title="fusus.char.UChar.syriac" href="char.html#fusus.char.UChar.syriac">syriac</a></code></li>
<li><code><a title="fusus.char.UChar.wordRe" href="char.html#fusus.char.UChar.wordRe">wordRe</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/among" title="among Digital Manuscripts on GitHub"><img src="../fusus/images/fusus-small.png"></a></p>
<p><a href="../fusus/index.html">fusus home</a> -
<a href="../fusus/about/howto.html">HowTo</a>
<a href="https://github.com/among/fusus" title="GitHub repo"><img src="../fusus/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#private-use-characters">Private use characters</a></li>
<li><a href="#dual-code-points">Dual code points</a></li>
<li><a href="#reading-order">Reading order</a></li>
<li><a href="#horizontal-whitespace">Horizontal whitespace</a></li>
<li><a href="#output-format">Output format</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fusus" href="index.html">fusus</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="two-column">
<li><code><a title="fusus.lakhnawi.CSS" href="#fusus.lakhnawi.CSS">CSS</a></code></li>
<li><code><a title="fusus.lakhnawi.FNRULE_WIDTH" href="#fusus.lakhnawi.FNRULE_WIDTH">FNRULE_WIDTH</a></code></li>
<li><code><a title="fusus.lakhnawi.LETTER_CODE_DEF" href="#fusus.lakhnawi.LETTER_CODE_DEF">LETTER_CODE_DEF</a></code></li>
<li><code><a title="fusus.lakhnawi.POST_HTML" href="#fusus.lakhnawi.POST_HTML">POST_HTML</a></code></li>
<li><code><a title="fusus.lakhnawi.REPLACE_DEF" href="#fusus.lakhnawi.REPLACE_DEF">REPLACE_DEF</a></code></li>
<li><code><a title="fusus.lakhnawi.SPACE_THRESHOLD" href="#fusus.lakhnawi.SPACE_THRESHOLD">SPACE_THRESHOLD</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="fusus.lakhnawi.getDictFromDef" href="#fusus.lakhnawi.getDictFromDef">getDictFromDef</a></code></li>
<li><code><a title="fusus.lakhnawi.getToc" href="#fusus.lakhnawi.getToc">getToc</a></code></li>
<li><code><a title="fusus.lakhnawi.keyCharH" href="#fusus.lakhnawi.keyCharH">keyCharH</a></code></li>
<li><code><a title="fusus.lakhnawi.keyCharV" href="#fusus.lakhnawi.keyCharV">keyCharV</a></code></li>
<li><code><a title="fusus.lakhnawi.preHtml" href="#fusus.lakhnawi.preHtml">preHtml</a></code></li>
<li><code><a title="fusus.lakhnawi.ptRep" href="#fusus.lakhnawi.ptRep">ptRep</a></code></li>
<li><code><a title="fusus.lakhnawi.ptRepD" href="#fusus.lakhnawi.ptRepD">ptRepD</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fusus.lakhnawi.Lakhnawi" href="#fusus.lakhnawi.Lakhnawi">Lakhnawi</a></code></h4>
<ul class="two-column">
<li><code><a title="fusus.lakhnawi.Lakhnawi.close" href="#fusus.lakhnawi.Lakhnawi.close">close</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.clusterVert" href="#fusus.lakhnawi.Lakhnawi.clusterVert">clusterVert</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.clusteredHeights" href="#fusus.lakhnawi.Lakhnawi.clusteredHeights">clusteredHeights</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.collectPage" href="#fusus.lakhnawi.Lakhnawi.collectPage">collectPage</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.columns" href="#fusus.lakhnawi.Lakhnawi.columns">columns</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.doc" href="#fusus.lakhnawi.Lakhnawi.doc">doc</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.doubles" href="#fusus.lakhnawi.Lakhnawi.doubles">doubles</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.drawPages" href="#fusus.lakhnawi.Lakhnawi.drawPages">drawPages</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.fnRules" href="#fusus.lakhnawi.Lakhnawi.fnRules">fnRules</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.getCharConfig" href="#fusus.lakhnawi.Lakhnawi.getCharConfig">getCharConfig</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.getCharInfo" href="#fusus.lakhnawi.Lakhnawi.getCharInfo">getCharInfo</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.getPageObj" href="#fusus.lakhnawi.Lakhnawi.getPageObj">getPageObj</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.getPageRaw" href="#fusus.lakhnawi.Lakhnawi.getPageRaw">getPageRaw</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.getPages" href="#fusus.lakhnawi.Lakhnawi.getPages">getPages</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.good" href="#fusus.lakhnawi.Lakhnawi.good">good</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.heights" href="#fusus.lakhnawi.Lakhnawi.heights">heights</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.htmlLine" href="#fusus.lakhnawi.Lakhnawi.htmlLine">htmlLine</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.htmlPages" href="#fusus.lakhnawi.Lakhnawi.htmlPages">htmlPages</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.isPageNum" href="#fusus.lakhnawi.Lakhnawi.isPageNum">isPageNum</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.lines" href="#fusus.lakhnawi.Lakhnawi.lines">lines</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.parsePageNums" href="#fusus.lakhnawi.Lakhnawi.parsePageNums">parsePageNums</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.plainChar" href="#fusus.lakhnawi.Lakhnawi.plainChar">plainChar</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.plainLine" href="#fusus.lakhnawi.Lakhnawi.plainLine">plainLine</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.plainPages" href="#fusus.lakhnawi.Lakhnawi.plainPages">plainPages</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.plainString" href="#fusus.lakhnawi.Lakhnawi.plainString">plainString</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.privateDias" href="#fusus.lakhnawi.Lakhnawi.privateDias">privateDias</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.privateInfo" href="#fusus.lakhnawi.Lakhnawi.privateInfo">privateInfo</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.privateLetters" href="#fusus.lakhnawi.Lakhnawi.privateLetters">privateLetters</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.privateSpace" href="#fusus.lakhnawi.Lakhnawi.privateSpace">privateSpace</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.setStyle" href="#fusus.lakhnawi.Lakhnawi.setStyle">setStyle</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.setupRules" href="#fusus.lakhnawi.Lakhnawi.setupRules">setupRules</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showChar" href="#fusus.lakhnawi.Lakhnawi.showChar">showChar</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showColumns" href="#fusus.lakhnawi.Lakhnawi.showColumns">showColumns</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showDoubles" href="#fusus.lakhnawi.Lakhnawi.showDoubles">showDoubles</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showFinals" href="#fusus.lakhnawi.Lakhnawi.showFinals">showFinals</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showLineHeights" href="#fusus.lakhnawi.Lakhnawi.showLineHeights">showLineHeights</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showLines" href="#fusus.lakhnawi.Lakhnawi.showLines">showLines</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showReplacements" href="#fusus.lakhnawi.Lakhnawi.showReplacements">showReplacements</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showSpacing" href="#fusus.lakhnawi.Lakhnawi.showSpacing">showSpacing</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showString" href="#fusus.lakhnawi.Lakhnawi.showString">showString</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showUsedChars" href="#fusus.lakhnawi.Lakhnawi.showUsedChars">showUsedChars</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.showWords" href="#fusus.lakhnawi.Lakhnawi.showWords">showWords</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.spaces" href="#fusus.lakhnawi.Lakhnawi.spaces">spaces</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.text" href="#fusus.lakhnawi.Lakhnawi.text">text</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.trimLine" href="#fusus.lakhnawi.Lakhnawi.trimLine">trimLine</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.tsvHeadLine" href="#fusus.lakhnawi.Lakhnawi.tsvHeadLine">tsvHeadLine</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.tsvLine" href="#fusus.lakhnawi.Lakhnawi.tsvLine">tsvLine</a></code></li>
<li><code><a title="fusus.lakhnawi.Lakhnawi.tsvPages" href="#fusus.lakhnawi.Lakhnawi.tsvPages">tsvPages</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://digitalorientalist.com/about-cornelis-van-lit/">Cornelis van Lit</a>
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../fusus/images/dans.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>